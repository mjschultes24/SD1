Zerocoin: Anonymous Distributed E-Cash from Bitcoin
Ian Miers, Christina Garman, Matthew Green, Aviel D. Rubin
The Johns Hopkins University Department of Computer Science, Baltimore, USA
{imiers, cgarman, mgreen, rubin}@cs.jhu.edu
Abstract—Bitcoin is the first e-cash system to see widespread                 typically associated with e-cash schemes. On top of such
adoption. While Bitcoin offers the potential for new types of                 transactions, one could build mechanisms to partially or
financial  interaction,  it  has  significant  limitations  regarding
explicitly identify participants to authorized parties  (e.g.,
privacy.  Specifically,  because  the  Bitcoin  transaction  log  is
law enforcement). However, to limit this information to
completely public, users’ privacy is protected only through the
use of pseudonyms. In this paper we propose Zerocoin, a crypto-               authorized parties, we must first anonymize the underlying
graphic extension to Bitcoin that augments the protocol to allow              public transactions.
for fully anonymous currency transactions. Our system uses
The  Bitcoin  community  generally  acknowledges  the
standard  cryptographic  assumptions  and  does  not  introduce
privacy  weaknesses  of  the  currency.  Unfortunately,  the
new trusted parties or otherwise change the security model of
available mitigations are quite limited. The most common
Bitcoin.  We detail  Zerocoin’s cryptographic  construction, its
integration into Bitcoin, and examine its performance both in                 recommendation  is  to  employ  a  laundry  service  which
terms of computation and impact on the Bitcoin protocol.                      exchanges different users’ bitcoins. Several of these are in
                                                                              commercial operation today [6, 7]. These services, however,
                                                                              have severe limitations: operators can steal funds, track coins,
I.  INTRODUCTION
                                                                              or simply go out of business, taking users’ funds with them.
Digital currencies have a long academic pedigree. As of
                                                                              Perhaps in recognition of these risks, many services offer
yet, however, no system from the academic literature has
                                                                              short laundering periods, which lead to minimal transaction
seen widespread use. Bitcoin, on the other hand, is a viable                  volumes and hence to limited anonymity.
digital currency with a market capitalization valued at more
than $100 million [1] and between $2 and $5 million USD                       Our contribution. In this paper we describe Zerocoin, a
in transactions a day  [2]. Unlike many proposed digital                      distributed e-cash system that uses cryptographic techniques
currencies, Bitcoin is fully decentralized and requires no                    to break the link between individual Bitcoin transactions
central bank or authority. Instead, its security depends on a                 without adding trusted parties. To do this, we first define
distributed architecture and two assumptions: that a majority                 the abstract functionality and security requirements of a new
of its nodes are honest and that a substantive proof-of-                      primitive that we call a decentralized e-cash scheme. We next
work can deter Sybil attacks. As a consequence, Bitcoin                       propose a concrete instantiation and prove it secure under
requires neither legal mechanisms to detect and punish double                 standard cryptographic assumptions. Finally, we describe
spending nor trusted parties to be chosen, monitored, or                      the specific extensions required to integrate our protocol
policed. This decentralized design is likely responsible for                  into the Bitcoin system and evaluate the performance of a
Bitcoin’s success, but it comes at a price: all transactions                  prototype implementation derived from the original open-
are public and conducted between cryptographically binding                    source bitcoind client.
pseudonyms.                                                                   We are not the first to propose e-cash techniques for
While relatively few academic works have considered the                       solving Bitcoin’s privacy problems. However, a common
privacy implications of Bitcoin’s design [2, 3], the preliminary              problem  with  many  e-cash  protocols  is  that  they  rely
results are not encouraging. In one example, researchers                      fundamentally on a trusted currency issuer or “bank,” who
were able to trace the spending of 25,000 bitcoins that were                  creates electronic “coins” using a blind signature scheme.
allegedly stolen in 2011 [3, 4]. Although tracking stolen coins               One solution  (attempted unsuccessfully with Bitcoin  [8])
may seem harmless, we note that similar techniques could                      is to simply appoint such a party. Alternatively, one can
also be applied to trace sensitive transactions, thus violating               distribute the responsibility among a quorum of nodes using
users’ privacy. Moreover, there is reason to believe that                     threshold cryptography. Unfortunately, both of these solutions
sophisticated results from other domains (e.g., efforts to de-                introduce points of failure and seem inconsistent with the
anonymize social network data using network topology [5])                     Bitcoin network model, which consists of many untrusted
will soon be applied to the Bitcoin transaction graph.                        nodes that routinely enter and exit the network. Moreover, the
Since  all  Bitcoin  transactions  are  public,  anonymous                    problem of choosing long-term trusted parties, especially in
transactions are necessary to avoid tracking by third parties                 the legal and regulatory grey area Bitcoin operates in, seems
even if we do not wish to provide the absolute anonymity                      like a major impediment to adoption. Zerocoin eliminates




Block 1                                                                                                                        Block 2                                                                     Block N
Block N
(a)
Block 1                                                                                                                        Block 2                                                                     Block N
                                                                                                                                                                                                           Block N
(b)
Bitcoin                                                                                                                        Zerocoin Mint                                                               Zerocoin Spend
Figure 1: Two example block chains. Chain (a) illustrates a normal Bitcoin transaction history, with each transaction linked
to a preceding transaction. Chain (b) illustrates a Zerocoin chain. The linkage between mint and spend (dotted line) cannot
be determined from the block chain data.
the need for such coin issuers by allowing individual Bitcoin                                                                  Alice to collect $1 from any location on the bulletin board;
clients to generate their own coins — provided that they                                                                       otherwise they reject her transaction and prevent her from
have sufficient classical bitcoins to do so.                                                                                   collecting the currency.
                                                                                                                               This simple protocol achieves some important aims. First,
Intuition behind our construction. To understand the intuition
                                                                                                                               Alice’s minted coin cannot be linked to her retrieved funds:
behind Zerocoin, consider the following “pencil and paper”
                                                                                                                               in order to link the coin C to the the serial number S used
protocol example. Imagine that all users share access to
                                                                                                                               in her withdrawal, one must either know r or directly know
a  physical  bulletin  board.  To  mint  a  zerocoin  of  fixed
                                                                                                                               which coin Alice proved knowledge of, neither of which are
denomination $1, a user Alice first generates a random coin
                                                                                                                               revealed by the proof. Thus, even if the original dollar bill
serial number S, then commits to S using a secure digital
                                                                                                                               is recognizably tainted (e.g., it was used in a controversial
commitment scheme. The resulting commitment is a coin,
                                                                                                                               transaction), it cannot be linked to Alice’s new dollar bill.
denoted C , which can only be opened by a random number
                                                                                                                               At the same time, if the commitment and zero-knowledge
r to reveal the serial number S. Alice pins C to the public
                                                                                                                               proof are secure, then Alice cannot double-spend any coin
bulletin board, along with $1 of physical currency. All users
                                                                                                                               without re-using the serial number S and thus being detected
will accept C provided it is correctly structured and carries
                                                                                                                               by the network participants.
the correct sum of currency.
                                                                                                                               Of course, the above protocol is not workable: bulletin
To redeem her coin C , Alice first scans the bulletin board
                                                                                                                               boards are a poor place to store money and critical informa-
to obtain the set of valid commitments (C1 , . . . , CN ) that
                                                                                                                               tion. Currency might be stolen or serial numbers removed
have thus far been posted by all users in the system. She next
                                                                                                                               to allow double spends. More importantly, to conduct this
produces a non-interactive zero-knowledge proof π for the
                                                                                                                               protocol over a network, Alice requires a distributed digital
following two statements: (1) she knows a C ∈ (C1 , . . . , CN )
                                                                                                                               backing currency.2
and (2) she knows a hidden value r such that the commitment
                                                                                                                               The first and most basic contribution of our work is
C  opens to S. In full view of the others, Alice, using a
                                                                                                                               to recognize that Bitcoin answers all of these concerns,
disguise to hide her identity,1  posts a “spend” transaction
                                                                                                                               providing us with a backing currency, a bulletin board, and
containing (S, π). The remaining users verify the proof π
                                                                                                                               a conditional currency redemption mechanism. Indeed, the
and check that S has not previously appeared in any other
                                                                                                                               core of the Bitcoin protocol is the decentralized calculation
spend transaction. If these conditions are met, the users allow
                                                                                                                               2 One could easily imagine a solution based on existing payment networks,
1 Of course, in the real protocol Alice will emulate this by using an                                                          e.g., Visa or Paypal. However, this would introduce the need for trusted
anonymity network such as Tor [9].                                                                                             parties or exchanges.




of  a  block  chain  which  acts  as  a  trusted,  append-only      security and anonymity provided, and detail experimental
bulletin board that can both store information and process          results showing that our solution is practical.
financial transactions. Alice can add her commitments and
escrow funds by placing them in the block chain while               II.  OVERVIEW OF BITCOIN
being assured that strict protocol conditions (and not her
In this section we provide a short overview of the Bitcoin
colleagues’ scruples) determine when her committed funds
protocol. For a more detailed explanation, we refer the reader
may be accessed.
                                                                    to the original specification of Nakamoto  [15] or to the
Of course, even when integrated with the Bitcoin block
                                                                    summary of Barber et al. [2].
chain, the protocol above has another practical challenge.
Specifically, it is difficult to efficiently prove that a commit-
                                                                    The Bitcoin network. Bitcoin is a peer-to-peer network of
ment C is in the set (C1 , . . . , CN ). The naive solution is to
                                                                    nodes that distribute and record transactions, and clients used
prove the disjunction (C = C1 ) ∨ (C = C2 ) ∨  . . .  ∨ (C =
                                                                    to interact with the network. The heart of Bitcoin is the
CN ). Unfortunately such  “OR proofs” have size O(N ),
                                                                    block chain, which serves as an append-only bulletin board
which renders them impractical for all but small values of
                                                                    maintained in a distributed fashion by the Bitcoin peers.
N .
                                                                    The block chain consists of a series of blocks connected in
Our second contribution is to solve this problem, producing         a hash chain.3  Every Bitcoin block memorializes a set of
a new construction with proofs that do not grow linearly as         transactions that are collected from the Bitcoin broadcast
N increases. Rather than specifying an expensive OR proof,          network.
we employ a “public” one-way accumulator to reduce the              Bitcoin  peers  compete  to  determine  which  node  will
size of this proof. One-way accumulators [10, 11, 12, 13, 14],      generate the next canonical block. This competition requires
first proposed by Benaloh and de Mare [10], allow parties to
                                                                    each node to solve a proof of work based on identifying
combine many elements into a constant-sized data structure,
                                                                    specific SHA-256 preimages, specifically a block B such
while efficiently proving that one specific value is contained
                                                                    that SHA256(SHA256(B)) = (0ℓ ||{0, 1}256−ℓ ).4  The value
within the set. In our construction, the Bitcoin network com-
                                                                    ℓ is selected by a periodic network vote to ensure that on
putes an accumulator A over the commitments (C1 , . . . , CN ),
                                                                    average a block is created every 10 minutes. When a peer
along with the appropriate membership witnesses for each
generates a valid solution, a process known as mining, it
item in the set. The spender need only prove knowledge of
broadcasts the new block to all nodes in the system. If the
one such witness. In practice, this can reduce the cost of the
                                                                    block is valid (i.e., all transactions validate and a valid proof
spender’s proof to O(log N ) or even constant size.
                                                                    of work links the block to the chain thus far), then the new
Our  application  requires  specific  properties  from  the         block is accepted as the head of the block chain. The process
accumulator. With no trusted parties, the accumulator and           then repeats.
its associated witnesses must be publicly computable and            Bitcoin provides two separate incentives to peers that mine
verifiable (though we are willing to relax this requirement         new blocks. First, successfully mining a new block (which
to include a single, trusted setup phase in which parameters        requires a non-trivial computational investment) entitles the
are generated). Moreover, the accumulator must bind even            creator to a reward, currently set at 25 BTC.5  Second, nodes
the computing party to the values in the set. Lastly, the           who mine blocks are entitled to collect transaction fees from
accumulator must support an efficient non-interactive witness-      every transaction they include. The fee paid by a given
indistinguishable or zero-knowledge proof of set membership.        transaction is determined by its author (though miners may
Fortunately such accumulators do exist. In our concrete             exclude transactions with insufficient fees or prioritize high
proposal of Section IV we use a construction based on the           fee transactions).
Strong RSA accumulator of Camenisch and Lysyanskaya [12],
which is in turn based on an accumulator of Baric and               Bitcoin transactions. A Bitcoin transaction consists of a set
Pfitzmann [11] and Benaloh and de Mare [10].                        of outputs and inputs. Each output is described by the tuple
                                                                    (a, V ) where a is the amount, denominated in Satoshi (one
Outline of this work. The rest of this paper proceeds as            bitcoin = 109  Satoshi), and V  is a specification of who is
follows. In Section II we provide a brief technical overview        authorized to spend that output. This specification, denoted
of the Bitcoin protocol. In Section III we formally define          scriptPubKey, is given in Bitcoin script, a stack-based non-
the notion of decentralized e-cash and provide correctness          Turing-complete language similar to Forth. Transaction inputs
and security requirements for such a system. In Section IV
we give a concrete realization of our scheme based on               3 For efficiency reasons, this chain is actually constructed using a hash
standard cryptographic hardness assumptions including the           tree, but we use the simpler description for this overview.
                                                                    4 Each block includes a counter value that may be incremented until the
Discrete Logarithm problem and Strong RSA. Finally, in
                                                                    hash satisfies these requirements.
Sections V, VI, and VII, we describe how we integrate our
                                                                    5 The Bitcoin specification holds that this reward should be reduced every
e-cash construction into the Bitcoin protocol, discuss the          few years, eventually being eliminated altogether.




Input:                                                                     and (b) give the users back the money they put in to the pot,
Previous tx:  030b5937d9f4aaa1a3133b...
                                                                           use of these systems involves a fair amount of risk.
Index:  0
scriptSig:  0dcd253cdf8ea11cdc710e5e92af7647...
                                                                           III.  DECENTRALIZED E-CASH
Output:
Our approach to anonymizing the Bitcoin network uses a
Value:  5000000000
scriptPubKey: OP_DUP OP_HASH160                                            form of cryptographic e-cash. Since our construction does not
a45f2757f94fd2337ebf7ddd018c11a21fb6c283
                                                                           require a central coin issuer, we refer to it as a decentralized
OP_EQUALVERIFY OP_CHECKSIG
                                                                           e-cash scheme. In this section we define the algorithms
                                                                           that make up a decentralized e-cash scheme and describe
Figure 2: Example Bitcoin transaction. The output script
                                                                           the correctness and security properties required of such a
specifies that the redeeming party provide a public key that
system.
hashes to the given value and that the transaction be signed
with the corresponding private key.                                        Notation. Let λ represent an adjustable security parameter,
                                                                           let poly(·) represent some polynomial function, and let ν(·)
                                                                           represent a negligible function. We use C to indicate the set
are simply a reference to a previous transaction output,6                  of allowable coin values.
as well as a second script, scriptSig, with code and data
                                                                           Definition 3.1 (Decentralized E-Cash Scheme):  A decen-
that when combined with scriptPubKey evaluates to true.
Coinbase transactions, which start off every block and pay                 tralized  e-cash  scheme  consists  of  a  tuple  of  possibly
its creator, do not include a transaction input.                           randomized algorithms (Setup, Mint, Spend, Verify).
To send d bitcoins to Bob, Alice embeds the hash7  of                      •   Setup(1λ ) → params. On input a security parameter,
Bob’s ECDSA public key pkb , the amount d, and some script                 output a set of global public parameters params and a
instructions in scriptPubKey as one output of a transaction                description of the set C.
whose referenced inputs total at least d bitcoins (see Figure 2).          •   Mint(params)                                                   →   (c, skc).  On  input  parameters
Since any excess input is paid as a transaction fee to the node            params, output a coin c  ∈ C, as well as a trapdoor
who includes it in a block, Alice typically adds a second                  skc.
output paying the surplus change back to herself. Once the                 •   Spend(params, c, skc, R, C)                                    →                                      (π, S).   Given
transaction is broadcasted to the network and included in                  params, a coin c, its trapdoor skc, some transaction
a block, the bitcoins belong to Bob. However, Bob should                   string R  ∈  {0, 1}∗ , and an arbitrary set of coins C,
only consider the coins his once at least five subsequent                  output a coin spend transaction consisting of a proof π
blocks reference this block.8  Bob can spend these coins in                and serial number S if c ∈ C ⊆ C. Otherwise output
a transaction by referencing it as an input and including in               ⊥.
scriptSig a signature on the claiming transaction under skb                •   Verify(params, π, S, R, C) → {0, 1}. Given params,
and the public key pkb .                                                   a proof π, a serial number S, transaction information R,
                                                                           and a set of coins C, output 1 if C ⊆ C and (π, S, R)
Anonymity. Anonymity was not one of the design goals
                                                                           is valid. Otherwise output 0.
of Bitcoin [3, 15, 17]. Bitcoin provides only pseudonymity
                                                                           We  note  that  the  Setup  routine  may  be  executed  by  a
through the use of Bitcoin identities (public keys or their
                                                                           trusted party. Since this setup occurs only once and does not
hashes), of which a Bitcoin user can generate an unlimited
                                                                           produce any corresponding secret values, we believe that this
number. Indeed, many Bitcoin clients routinely generate new
                                                                           relaxation is acceptable for real-world applications. Some
identities in an effort to preserve the user’s privacy.
                                                                           concrete instantiations may use different assumptions.
Regardless of Bitcoin design goals, Bitcoin’s user base
                                                                           Each  coin  is  generated  using  a  randomized  minting
seems willing to go through considerable effort to maintain
                                                                           algorithm. The serial number S is a unique value released
their anonymity — including risking their money and paying
                                                                           during the spending of a coin and is designed to prevent
transaction fees. One illustration of this is the existence of
                                                                           any  user  from  spending  the  same  coin  twice.  We  will
laundries that (for a fee) will mix together different users’
                                                                           now formalize the correctness and security properties of
funds in the hopes that shuffling makes them difficult to
                                                                           a  decentralized  e-cash  scheme.  Each  call  to  the  Spend
trace [2, 6, 7]. Because such systems require the users to trust
                                                                           algorithm can include an arbitrary string R, which is intended
the laundry to both (a) not record how the mixing is done
                                                                           to store transaction-specific information (e.g., the identity of
6 This reference consists of a transaction hash identifier as well as an   a transaction recipient).
index into the transaction’s output list.
7 A 34 character hash that contains the double SHA-256 hash of the key     Correctness. Every decentralized e-cash scheme must satisfy
and some checksum data.
                                                                           the  following  correctness  requirement.  Let  params                                                    ←
8 Individual recipients are free to disregard this advice. However, this
                                                                           Setup(1λ )  and  (c, skc)                                          ←  Mint(params). Let C  ⊆  C
could make them vulnerable to double-spending attacks as described by
Karame et al. [16].                                                        be  any  valid  set  of  coins,  where                             |C|                                    ≤  poly(λ),  and




                                                                                                                                                                                                                 assign (π, S) ← Spend(params, c, skc, R, C). The scheme                                                                                                                                                                                                                                                                     The  oracle  Ospend    operates  as  follows:  on  the  jth
                                                                                                                                                                                                                 is correct if, over all C, R, and random coins used in                                                                                                                                                                                                           query   Ospend (cj , Cj , Rj ),   the   oracle   outputs                                                                                                                                               ⊥   if
                                                                                                                                                                                                                 the above algorithms, the following equality holds with                                                                                              cj                                                            ∈                                             {c1 , . . . , cN }.  Otherwise  it  returns                                                                                                                                               (πj , Sj )            ←
probability 1 − ν(λ):                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Spend(params, cj , skcj , Rj , Cj ) to A and records (Sj , Rj )
                                                                                                                                                                                                                                                                                                                                                                      in the set T .
                                                                                                                                               Verify(params, π, S, R, C ∪ {c}) = 1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             We say that A  wins  (i.e., she produces more spends
                                                                                                                                                                                                                 Security. The security of a decentralized e-cash system is                                                                                           than  minted  coins)  if                                                                                                                                                                                                                   ∀s                   ∈  {S1 , . . . , Sm , Sm+1 }  where
                                                                                                                                                                                                                 defined by the following two games: Anonymity and Balance.                                                                                           s = (π′ , S′ , R′ , C′ ):
                                                                                                                                                                                                                 We first describe the Anonymity experiment, which ensures                                                                                                                                                          •   Verify(params, π′ , S′ , R′ , C′ ) = 1.
                                                                                                                                                                                                                 that the adversary cannot link a given coin spend transaction                                                                                                                    •   C′  ⊆ {c1 , . . . , cN , c′
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 1 , . . . , c′m }.
                                                                                                                                                                                                                 (π, S) to the coin associated with it, even when the attacker                                                                                                                    •                                 (S′ , R′ ) ∈ T .
                                                                                                                                                                                                                 provides many of the coins used in generating the spend                                                                                                                                                                                                                                                                     •   S′  appears in only one tuple from {S1 , . . . , Sm , Sm+1 }.
transaction.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             We define A’s advantage as the probability that A wins
                                                                                                                                                                                                                 Definition 3.2 (Anonymity):  A    decentralized    e-cash                                                                                            the above game.
scheme  Π                                                                                                                                                                                                                                                                        =   (Setup, Mint, Spend, Verify)  satisfies  the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             IV.  DECENTRALIZED E-CASH FROM STRONG RSA
                                                                                                                                                                                                                 Anonymity requirement if every probabilistic polynomial-
time                                                                           (p.p.t.)  adversary  A                                                                                                                                                                                                                               =   (A1 , A2 )  has  negligible
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             In this section we describe a concrete instantiation of a
advantage in the following experiment.
decentralized e-cash scheme. We first define the necessary
Anonymity(Π, A, λ)                                                             cryptographic ingredients.
params ← Setup(1λ )
                                                                               A.  Cryptographic Building Blocks
For i ∈ {0, 1}: (ci , skci ) ← Mint(params)
(C, R, z) ← A1 (params, c0 , c1 ); b ← {0, 1}
                                                                               Zero-knowledge proofs and signatures of knowledge. Our
(π, S) ← Spend(params, cb , skcb , R, C ∪ {c0 , c1 })
                                                                               protocols use zero-knowledge proofs that can be instantiated
Output: b′  ← A2 (z, π, S)
                                                                               using the technique of Schnorr [18], with extensions due to
We   define   A’s   advantage   in   the   above   game   as
                                                                               e.g., [19, 20, 21, 22]. We convert these into non-interactive
|Pr [ b = b′ ] − 1/2|.
                                                                               proofs by applying the Fiat-Shamir heuristic [23]. In the
The Balance property requires more consideration. Intu-                        latter case, we refer to the resulting non-interactive proofs
itively, we wish to ensure that an attacker cannot spend more                  as signatures of knowledge as defined in [24].
coins than she mints, even when she has access to coins and                    When referring to these proofs we will use the notation of
spend transactions produced by honest parties. Note that to                    Camenisch and Stadler [25]. For instance, NIZKPoK{(x, y) :
strengthen our definition, we also capture the property that                   h = gx  ∧ c = gy } denotes a non-interactive zero-knowledge
an attacker might alter valid coins, e.g., by modifying their                  proof of knowledge of the elements x and y that satisfy both
transaction information string R.                                              h  = gx  and c  = gy . All values not enclosed in ()’s are
Our definition is reminiscent of the “one-more forgery”                        assumed to be known to the verifier. Similarly, the extension
definition commonly used for blind signatures. We provide                      ZKSoK[m]{(x, y) : h = gx  ∧ c = gy } indicates a signature
the attacker with a collection of valid coins and an oracle                    of knowledge on message m.
Ospend  that she may use to spend any of them.9  Ultimately
                                                                               Accumulators. Our construction uses an accumulator based
A must produce m coins and m + 1 valid spend transactions
                                                                               on the Strong RSA assumption. The accumulator we use
such that no transaction duplicates a serial number or modifies
was first proposed by Benaloh and de Mare [10] and later
a transaction produced by the honest oracle.
improved by Baric and Pfitzmann [11] and Camenisch and
Definition 3.3 (Balance):  A decentralized e-cash scheme                                                                                       Lysyanskaya [12]. We describe the accumulator using the
Π   =   (Setup, Mint, Spend, Verify)  satisfies  the  Balance                                                                                  following algorithms:
property if  ∀N                                                                ≤  poly(λ) every p.p.t. adversary A has                         •   AccumSetup(λ) → params. On input a security param-
negligible advantage in the following experiment.                                                                                              eter, sample primes p, q (with polynomial dependence on
Balance(Π, A, N, λ)                                                                                                                            the security parameter), compute N = pq, and sample a
params ← Setup(1λ )                                                                                                                            seed value u ∈ QRN , u = 1. Output (N, u) as params.
For i = 1 to N : (ci , skci ) ← Mint(params)                                                                                                   •   Accumulate(params, C)                                         →  A.  On  input  params
Output: (c′                                                                                                                                    (N, u)   and   a   set   of   prime   numbers   C                                                                                 =
                                                                               1 , . . . , c′m , S1 , . . . , Sm , Sm+1 )
← AOspend(·,·,·) (params, c1 , . . . , cN )                                                                                                    {c1 , . . . , ci  | c ∈ [A , B ]},10  compute the accumulator A
                                                                                                                                               as uc1 c2 ···cn   mod N .
9 We provide this functionality as an oracle to capture the possibility that
the attacker can specify arbitrary input for the value C.                                                                                      10 See Appendix A for a more precise description.




                                                               •   GenWitness(params, v, C)  → w. On input params                                                                                                                                   A ← Accumulate((N, u), C). Next verify that π is the
                                                               (N, u), a set of prime numbers C as described above,                                                                                                                                 aforementioned signature of knowledge on R using the
                                                               and a value v                                                     ∈  C, the witness w  is the accumu-                                                                                known public values. If the proof verifies successfully,
                                                               lation of all the values in C  besides v, i.e., w                                                       =                                                                            output 1, otherwise output 0.
                                                               Accumulate(params, C \ {v}).
                                                                                                                                                                                                                                                    Our protocol assumes a trusted setup process for generating
                                                               •   AccVerify(params, A, v, ω)                                    →    {0, 1}.  On  input
                                                                                                                                                                                                                                                    the parameters. We stress that the accumulator trapdoor
                                                               params (N, u), an element v, and witness ω, compute                                                                                                                                  (p, q) is not used subsequent to the Setup procedure and
                                                               A′  ≡ ωv   mod N and output 1 if and only if A′  = A,                                                                                                                                can therefore be destroyed immediately after the parameters
                                                               v is prime, and v ∈ [A , B ] as defined previously.                                                                                                                                  are  generated.  Alternatively,  implementers  can  use  the
                                                               For simplicity, the description above uses the full calculation                                                                                                                      technique of Sander for generating so-called RSA UFOs
                                                               of A. Camenisch and Lysyanskaya  [12] observe that the                                                                                                                               for accumulator parameters without a trapdoor [26].
                                                               accumulator may also be incrementally updated, i.e., given
                                                                                                                                                                                                                                                    C.  Security Analysis
                                                               an existing accumulator An  it is possible to add an element
                                                               x and produce a new accumulator value An+1  by computing                                                                                                                             We now consider the security of our construction.
An+1                                                           =  An   mod N .  We  make  extensive  use  of  this                                                                                                                                  Theorem 4.1:  If the zero-knowledge signature of knowl-
optimization in our practical implementation.                                                                                                                                                                                                       edge is computationally zero-knowledge in the random oracle
                                                               Camenisch and Lysyanskaya [12] show that the accumu-                                                                                                                                 model, then Π = (Setup, Mint, Spend, Verify) satisfies the
                                                               lator satisfies a strong collision-resistance property if the                                                                                                                        Anonymity property.
                                                               Strong RSA assumption is hard. Informally, this ensures                                                                                                                              We provide a proof sketch for Theorem 4.1 in Appendix A.
                                                               that no p.p.t. adversary can produce a pair (v, ω) such that                                                                                                                         Intuitively, the security of our construction stems from the fact
v                                                              ∈  C and yet AccVerify is satisfied. Additionally, they                                                                                                                              that the coin commitment C is a perfectly-hiding commitment
                                                               describe an efficient zero-knowledge proof of knowledge that                                                                                                                         and the signature proof π is at least computationally zero-
                                                               a committed value is in an accumulator. We convert this into                                                                                                                         knowledge. These two facts ensure that the adversary has at
                                                               a non-interactive proof using the Fiat-Shamir transform and                                                                                                                          most negligible advantage in guessing which coin was spent.
                                                               refer to the resulting proof using the following notation:
                                                                                                                                                                                                                                                    Theorem 4.2:  If the signature proof π  is sound in the
                                                               NIZKPoK{(v, ω) : AccVerify((N, u), A, v, ω) = 1}.                                                                                                                                    random oracle model, the Strong RSA problem is hard, and
                                                                                                                                                                                                                                                    the Discrete Logarithm problem is hard in G, then Π  =
B.  Our Construction
(Setup, Mint, Spend, Verify) satisfies the Balance property.
We now describe a concrete decentralized e-cash scheme.
A proof of Theorem  4.1  is included in Appendix A.
Our scheme is secure assuming the hardness of the Strong
                                                                                                                                                                       Briefly, this proof relies on the binding properties of the coin
RSA and Discrete Logarithm assumptions, and the existence
                                                                                                                                                                       commitment, as well as the soundness and unforgeability
of a zero-knowledge proof system.
                                                                                                                                                                       of the ZKSoK and collision-resistance of the accumulator.
We now describe the algorithms:
                                                                                                                                                                       We show that an adversary who wins the Balance game
•   Setup(1λ ) → params. On input a security parameter,
                                                                                                                                                                       with non-negligible advantage can be used to either find a
run AccumSetup(1λ ) to obtain the values (N, u). Next
                                                                                                                                                                       collision in the commitment scheme (allowing us to solve
generate primes p, q such that p = 2wq + 1 for w ≥ 1.
                                                                                                                                                                       the Discrete Logarithm problem) or find a collision in the
Select random generators g, h such that G  =  〈g〉  =
                                                                                                                                                                       accumulator (which leads to a solution for Strong RSA).
〈h〉 and G is a subgroup of Zq . Output params  =
(N, u, p, q, g, h).                                                                                                                                                    V.  INTEGRATING WITH BITCOIN
•   Mint(params)                                               →  (c, skc).  Select  S, r                                        ←  Zq and
                                                                                                                                                                       While the construction of the previous section gives an
compute c  ← gS hr  mod p such that {c prime | c  ∈
                                                                                                                                                                       overview of our approach, we have yet to describe how our
[A , B ]}.11  Set skc = (S, r) and output (c, skc).                                                                                                                    techniques integrate with Bitcoin. In this section we address
•   Spend(params, c, skc, R, C)                                →  (π, S).  If  c                                                 ∈  C
                                                                                                                                                                       the specific challenges that come up when we combine a
output ⊥. Compute A ← Accumulate((N, u), C) and
                                                                                                                                                                       decentralized e-cash scheme with the Bitcoin protocol.
ω ← GenWitness((N, u), c, C). Output (π, S) where π
                                                                                                                                                                       The  general  overview  of  our  approach  is  straightfor-
comprises the following signature of knowledge:12
                                                                                                                                                                       ward. To mint a zerocoin c of denomination d, Alice runs
π = ZKSoK[R]{(c, w, r) :                                                                                                                                               Mint(params)  →  (c, skc) and stores skc securely.13  She
                                                                                                                                                                       then embeds c in the output of a Bitcoin transaction that
AccVerify((N, u), A, c, w) = 1  ∧  c = gS hr }
                                                                                                                                                                       spends d + fees classical bitcoins. Once a mint transaction
•   Verify(params, π, S, R, C) → {0, 1}. Given a proof π,                                                                                                              has been accepted into the block chain, c is included in the
a serial number S, and a set of coins C, first compute
                                                                                                                                                                       13 In our implementation all bitcoins have a single fixed value. However,
11 See Appendix A for a more precise description.                                                                                                                      we can support multiple values by running distinct Zerocoin instantiations
12 See Appendix B for the construction of the ZKSoK.                                                                                                                   simultaneously, all sharing the same set of public parameters.




global accumulator A, and the currency cannot be accessed                                                                                                         script functionality have been disabled in the Bitcoin produc-
except through a Zerocoin spend, i.e., it is essentially placed                                                                                                   tion network due to security concerns. Hence, the existing
into escrow.                                                                                                                                                      script language cannot be used for sophisticated calculations
To spend c  with Bob, Alice first constructs a partial                                                                                                            such as verifying zero-knowledge proofs. Fortunately for
transaction ptx that references an unclaimed mint transaction                                                                                                     our purposes, the Bitcoin designers chose to reserve several
as  input  and  includes  Bob’s  public  key  as  output.  She                                                                                                    script operations for future expansion.
then  traverses  all  valid  mint  transactions  in  the  block                                                                                                   We extend Bitcoin by adding a new instruction: ZERO-
chain,  assembles  the  set  of  minted  coins  C,  and  runs                                                                                                     COIN  MINT. Minting a zerocoin constructs a transaction
Spend(params, c, skc, hash(ptx), C)                                      →  (π, S).  Finally,                                                                     with an output whose scriptPubKey contains this instruction
she completes the transaction by embedding (π, S) in the                                                                                                          and a coin c. Nodes who receive this transaction should
scriptSig of the input of ptx. The output of this transaction                                                                                                     validate that c is a well-formed coin. To spend a zerocoin,
could also be a further Zerocoin mint transaction                                                                                                          —  a   Alice  constructs  a  new  transaction  that  claims  as  input
feature that may be useful to transfer value between multiple                                                                                                     some Zerocoin mint transaction and has a scriptSig field
Zerocoin instances (i.e., of different denomination) running                                                                                                      containing (π, S) and a reference to the block containing the
in the same block chain.                                                                                                                                          accumulator used in π. A verifier extracts the accumulator
When this transaction appears on the network, nodes check                                                                                                         from the referenced block and, using it, validates the spend
that Verify(params, π, S, hash(ptx), C) = 1 and check that                                                                                                        as described earlier.
S  does not appear in any previous transaction. If these                                                                                                          Finally, we note that transactions must be signed to prevent
condition hold and the referenced mint transaction is not                                                                                                         an attacker from simply changing who the transaction is
claimed as an input into a different transaction, the network                                                                                                     payed to. Normal Bitcoin transactions include an ECDSA
accepts the spend as valid and allows Alice to redeem d                                                                                                           signature by the key specified in the scriptPubKey of the
bitcoins.                                                                                                                                                         referenced input. However, for a spend transaction on an
                                                                                                                                                                  arbitrary zerocoin, there is no ECDSA public key. Instead, we
Computing the accumulator. A naive implementation of                                                                                                              use the ZKSoK π to sign the transaction hash that normally
the construction in Section IV requires that the verifier re-                                                                                                     would be signed using ECDSA.15
compute the accumulator A with each call to Verify(. . .). In
                                                                                                                                                                  Statekeeping and side effects. Validating a zerocoin changes
practice, the cost can be substantially reduced.
Bitcoin’s  semantics:  currently,  Bitcoin’s  persistent  state
First, recall that the accumulator in our construction can
is defined solely in terms of transactions and blocks of
be computed incrementally, hence nodes can add new coins
transactions. Furthermore, access to this state is done via
to the accumulation when they arrive. To exploit this, we
explicit reference by hash. Zerocoin, on the other hand,
require any node mining a new block to add the zerocoins in
because of its strong anonymity requirement, deals with
that block to the previous block’s accumulator and store the
existentials: the coin is in the set of thus-far-minted coins
resulting new accumulator value in the coinbase transaction
and its serial number is not yet in the set of spent serial
at the start of the new block.14  We call this an accumulator
numbers. To enable these type of qualifiers, we introduce
checkpoint. Peer nodes validate this computation before
side effects into Bitcoin transaction handling. Processing a
accepting the new block into the blockchain. Provided that
mint transaction causes a coin to be accumulated as a side
this verification occurs routinely when blocks are added to
effect. Processing a spend transaction causes the coin serial
the chain, some clients may choose to trust the accumulator
number to be added to a list of spent serial numbers held by
in older (confirmed) blocks rather than re-compute it from
the client.
scratch.
For coin serial numbers, we have little choice but to keep
With this optimization, Alice need no longer compute the
                                                                         a full list of them per client and incur the (small) overhead
accumulator A and the full witness w for c. Instead she can
                                                                         of storing that list and the larger engineering overhead of
merely reference the current block’s accumulator checkpoint
                                                                         handling all possible ways a transaction can enter a client.
and  compute  the  witness  starting  from  the  checkpoint
                                                                         The accumulator state is maintained within the accumulator
preceding her mint (instead of starting at T0 ), since computing
                                                                         checkpoints, which the client verifies for each received block.
the witness is equivalent to accumulating C \ {c}.
                                                                         Proof optimizations. For reasonable parameter sizes, the
New transaction types. Bitcoin transactions use a flexible
                                                                         proofs  produced  by  Spend(. . .)  exceed  Bitcoin’s                             10KB
scripting language to determine the validity of each transac-
transaction size limits. Although we can simply increase this
tion. Unfortunately, Bitcoin script is (by design) not Turing-
limit, doing so has two drawbacks: (1) it drastically increases
complete. Moreover, large segments of the already-limited
the storage requirements for Bitcoin since current transactions
14 The coinbase transaction format already allows for the inclusion of   15 In practice, this modification simply requires us to include the transaction
arbitrary data, so this requires no fundamental changes to the Bitcoin   digest in the hash computation of the challenge for the Fiat-Shamir proofs.
protocol.                                                                See Appendix A for details.




are between 1 and 2 KB and (2) it may increase memory                           obvious solution is to securely delete skc immediately after
pressure on clients that store transactions in memory.16                        a coin is spent. Unfortunately, this provides no protection if
In our prototype implementation we store our proofs in                          skc is stolen at some earlier point.
a separate, well-known location (a simple server). A full                       One solution is to generate the spend transaction imme-
implementation could use a Distributed Hash Table or non                        diately (or shortly after) the coin is minted, possibly using
block-chain backed storage in Bitcoin. While we recommend                       an earlier checkpoint for calculating C. This greatly reduces
storing proofs in the block chain, these alternatives do not                    the user’s anonymity by decreasing the number of coins in
increase the storage required for the block chain.17                            C and leaking some information about when the coin was
                                                                                minted. However, no attacker who compromises the wallet
A.  Suggestions for Optimizing Proof Verification
                                                                                can link any zerocoins in it to their mint transactions.
The complexity of the proofs will also lead to longer
verification times than expected with a standard Bitcoin                        C.  Code Changes
transaction. This is magnified by the fact that a Bitcoin                       For our implementation, we chose to modify bitcoind,
transaction is verified once when it is included by a block                     the original open-source Bitcoin C++ client. This required
and again by every node when that block is accepted into                        several modifications. First, we added instructions to the
the block chain. Although the former cost can be accounted                      Bitcoin script for minting and spending zerocoins. Next,
for by charging transaction fees, it would obviously be ideal                   we added transaction types and code for handling these
for these costs to be as low as possible.                                       new instructions, as well as maintaining the list of spent
One approach is to distribute the cost of verification over                     serial numbers and the accumulator. We used the Charm
the entire network and not make each node verify the entire                     cryptographic framework [27] to implement the cryptographic
proof. Because the ZKSoK we use utilizes cut-and-choose                         constructions in Python, and we used Boost’s Python utilities
techniques, it essentially consists of n repeated iterations                    to call that code from within bitcoind. This introduces
of the same proof (reducing the probability of forgery to                       some performance overhead, but it allowed us to rapidly pro-
roughly 2−n ). We can simply have nodes randomly select                         totype and leave room for implementing future constructions
which iterations of the proofs they verify. By distributing this                as well.
process across the network, we should achieve approximately
                                                                                D.  Incremental Deployment
the same security with less duplication of effort.
This optimization involves a time-space tradeoff, since                         As described above, Zerocoin requires changes to the
the existing proof is verified by computing a series of (at a                   Bitcoin protocol that must happen globally: while transactions
minimum) 1024 bit values T1 , . . . , Tn  and hashing the result.               containing the new instructions will be validated by updated
A naive implementation would require us to send T1 , . . . , Tn                 servers, they will fail validation on older nodes, potentially
fully computed — greatly increasing the size of the proof -                     causing the network to split when a block is produced that
since the client will only compute some of them but needs                       validates for some, but not all, nodes. Although this is not
all of them to verify the hash. We can avoid this issue by                      the first time Bitcoin has faced this problem, and there is
replacing the standard hash with a Merkel tree where the                        precedent for a flag day type upgrade strategy [28], it is
leaves are the hashed Ti  values and the root is the challenge                  not clear how willing the Bitcoin community is to repeat
hash used in the proof. We can then send the 160  bit or                        it. As such, we consider the possibility of an incremental
256 bit intermediate nodes instead of the 1024 bit Ti  values,                  deployment.
allowing the verifier to compute only a subset of the Ti                        One way to accomplish this is to embed the above protocol
values and yet still validate the proof against the challenge                   as comments in standard Bitcoin scripts. For non Zerocoin
without drastically increasing the proof size.                                  aware nodes, this data is effectively inert, and we can use
                                                                                Bitcoin’s n  of k  signature support to specify that such
B.  Limited Anonymity and Forward Security
                                                                                comment embedded zerocoins are valid only if signed by
A serious concern in the Bitcoin community is the loss
some subset of the Zerocoin processing nodes. Such Zerocoin
of  wallets  due  to  poor  endpoint  security.  In  traditional
aware nodes can parse the comments and charge transaction
Bitcoin, this results in the theft of coins [4]. However, in
fees for validation according to the proofs embedded in the
the Zerocoin setting it may also allow an attacker to de-
                                                                                comments, thus providing an incentive for more nodes to
anonymize Zerocoin transactions using the stored skc. The
                                                                                provide such services. Since this only changes the validation
                                                                                mechanism for Zerocoin, the Anonymity property holds as
16 The reference bitcoind client stores transactions as STL Vectors,
which require contiguous segments of memory. As such, storing Zerocoin          does the Balance property if no more than n − 1 Zerocoin
proofs in the transaction might cause memory issues far faster than expected.   nodes are malicious.
17 Furthermore, this solution allows for the intriguing possibility that
                                                                                Some care must be taken when electing these nodes to
proofs be allowed to vanish after they have been sufficiently verified by the
                                                                                prevent a Sybil attack. Thankfully, if we require that such a
network and entombed in the block chain. However, it is not clear how this
interacts with Bitcoin in theory or practice.                                   node also produce blocks in the Bitcoin block chain, we have




a decent deterrent. Furthermore, because any malfeasance           the group used does not affect the long term anonymity
of these nodes is readily detectable (since they signed an         of Zerocoin. The security of the commitment scheme does,
invalid Zerocoin transaction), third parties can audit these       however, affect counterfeiting: an attacker who can break
nodes and potentially hold funds in escrow to deter fraud.         the binding property of the commitment scheme can mint a
                                                                   zerocoin that opens to at least two different serial numbers,
VI.  REAL WORLD SECURITY AND PARAMETER CHOICE
                                                                   resulting in a double spend. As a result, the Schnorr group
A.  Anonymity of Zerocoin                                          must be large enough that such an attack cannot be feasibly
                                                                   mounted in the lifetime of a coin. On the other hand, the
Definition 3.2 states that given two Zerocoin mints and one
                                                                   size of the signature of knowledge π used in coin spends
spend, one cannot do much better than guess which minted
                                                                   increases linearly with the size of the Schnorr group.
coin was spent. Put differently, an attacker learns no more
from our scheme than they would from observing the mints           One solution is to minimize the group size by announcing
and spends of some ideal scheme. However, even an ideal            fresh parameters for the commitment scheme periodically
scheme imposes limitations. For example, consider a case           and forcing old zerocoins to expire unless exchanged for
where N coins are minted, then all N coins are subsequently        new zerocoins minted under the fresh parameters.18  Since
spent. If another coin is minted after this point, the size of     all coins being spent on the network at time t are spent
the anonymity set for the next spend is k = 1, not k = 11,         with the current parameters and all previous coins can be
since it is clear to all observers that the previous coins have    converted to fresh ones, this does not decrease the anonymity
been used. We also stress that — as in many anonymity              of the system. It does, however, require users to convert old
systems — privacy may be compromised by an attacker who            zerocoins to fresh ones before the old parameters expire.
mints a large fraction of the active coins. Hence, a lower         For our prototype implementation, we chose to use 1024 bit
bound on the anonymity provided is the number of coins             parameters on the assumption that commitment parameters
minted by honest parties between a coin’s mint and its spend.      could be regenerated periodically. We explore the possibility
                                                                   of extensions to Zerocoin that might enable smaller groups
An upper bound is the total set of minted coins.
                                                                   in Section IX.
We also note that Zerocoin reveals the number of minted
and spent coins to all users of the system, which provides
                                                                   Accumulator RSA key. Because generating a new accumulator
a potential source of information to attackers. This is in
                                                                   requires either a new trusted setup phase or generating a
contrast to many previous e-cash schemes which reveal this
new RSA UFO [26], we cannot re-key very frequently. As a
information primarily to merchants and the bank. However,
result, the accumulator is long lived, and thus we truly need
we believe this may be an advantage rather than a loss,
long term security. Therefore we currently propose an RSA
since the bank is generally considered an adversarial party in
key of at least 3072 bits. We note that this does not greatly
most e-cash security models. The public model of Zerocoin
affect the size of the coins themselves, and, because the proof
actually removes an information asymmetry by allowing users
of accumulator membership is efficient, this does not have
to determine when such conditions might pose a problem.
a large adverse effect on the overall coin spend proof size.
Lastly, Zerocoin does not hide the denominations used in
Moreover, although re-keying the accumulator is expensive,
a transaction. In practice, this problem can be avoided by
it need not reduce the anonymity of the system since the new
simply fixing one or a small set of coin denominations and
parameters can be used to re-accumulate the existing coin
exchanging coins until one has those denominations, or by
                                                                   set and hence anonymize spends over that whole history.
simply using Zerocoin to anonymize bitcoins.
                                                                   Zero-knowledge proof security λzkp . This parameter affects
B.  Parameters                                                     the anonymity and security of the zero-knowledge proof. It
Generally, cryptographers specify security in terms of a           also greatly affects the size of the spend proof. Thankfully,
single, adjustable security parameter λ. Indeed, we have           since each proof is independent, it applies per proof and
used this notation throughout the previous sections. In reality,   therefore per spend. As such, a dishonest party would have
however, there are three distinct security choices for Zerocoin    to expend roughly 2λzkp   effort to forge a single coin or could
which affect either the system’s anonymity, its resilience to      link a single coin mint to a spend with probability roughly
1
counterfeiting, or both. These are:                                As such we pick λzkp  = 80 bits.
                                                                   2λzkp  .
1)  The  size  of  the  Schnorr  group  used  in  the  coin
                                                                   VII.  PERFORMANCE
commitments.
                                                                   To validate our results, we conducted several experiments
2)  The size of the RSA modulus used in the accumulator.
                                                                   using the modified bitcoind implementation described
3)  λzkp , the security of the zero-knowledge proofs.
                                                                   in Section V. We ran our experiments with three different
Commitments. Because Pedersen commitments are informa-
                                                                   18 Note that this conversion need not involve a full spend of the coins.
tion theoretically hiding for any Schnorr group whose order
                                                                   The user may simply reveal the trapdoor for the old coin, since the new
is large enough to fit the committed values, the size of           zerocoin will still be unlinkable when properly spent.




Performance of Zerocoin Algorithms                                               Zerocoin Spend Proof Size
0.8                                                                              50000
Mint
Spend                                                                            45000
0.7
                                                                                                                                                                                              Verify
                                                                                                                                                                                                       40000
0.6
                                                                                                                                                                                                       35000
0.5                                                                                                                                                                                                    30000
0.4                                                                                                                                                                                                    25000
0.3                                                                                                                                                                                                    20000
                                                                                                                                                                                                       15000
0.2
                                                                                                                                                                                                       10000
0.1                                                                                                                                                                                                    5000
0                                                                                                                                                                                                      0
                                                                                 1024                                                                        2048                             3072             1024    2048                  3072
                                                                                                                                                             Modulus Size (bits)                                       Modulus Size (bits)
(a) Times for a single Zerocoin operation measured in seconds. These             (b) Zerocoin proof sizes measured in bytes as a function of RSA
operations do not include the time required to compute the accumulator.          modulus size.
                                                                                                                                                             Accumulation Time                                                                          Zerocoin Block Verification Performance
900                                                                                                                                                                                                                    1400
                                                                                 N=1024                                                                                                                                                      N = 1024
800                                                                              N=2048                                                                                                                                                      N = 2048
                                                                                 N=3072                                                                                                                                1200                  N = 3072
700
                                                                                                                                                                                                                       1000
600
500                                                                                                                                                                                                                    800
400                                                                                                                                                                                                                    600
300
                                                                                                                                                                                                                       400
200
                                                                                                                                                                                                                       200
100
0                                                                                                                                                                                                                      0
0                                                                                10000                                                                       20000                            30000    40000   50000   0                     20         40                                        60   80   100
                                                                                                                                                             Number of Elements Accumulated                                                             Percentage of Zerocoins
(c) Time required to accumulate x elements. Note, this cost is amortized         (d) Transaction verifications per minute as a function of the percentage
when computing the global accumulator.                                           of Zerocoin transactions in the network (where half are mints and half
                                                                                 are spends). Note, since we plot the reciprocal of transaction time, this
                                                                                 graph appears logarithmic even though Zerocoin scales linearly.
Figure 3: Zerocoin performance as a function of parameter size.
parameter sizes, where each corresponds to a length of the                       A.  Microbenchmarks
RSA modulus N : 1024 bits, 2048 bits, and 3072 bits.19
                                                                                 To evaluate the performance of our Mint, Spend, and
We conducted two types of experiments: (1) microbench-                           Verify  algorithms in isolation, we conducted a series of
marks that measure the performance of our cryptographic                          microbenchmarks using the Charm (Python) implementation.
constructions and (2) tests of our whole modified Bitcoin                        Our goal in these experiments was to provide a direct estimate
client measuring the time to verify Zerocoin carrying blocks.                    of the performance of our cryptographic primitives.
The former gives us a reasonable estimate of the cost of
                                                                                 Experimental setup. One challenge in conducting our mi-
minting a single zerocoin, spending it, and verifying the
                                                                                 crobenchmarks is the accumulation of coins in C for the
resulting transaction. The latter gives us an estimate of
                                                                                 witness in Spend(. . .) or for the global accumulator in both
Zerocoin’s impact on the existing Bitcoin network and the
                                                                                 Spend(. . .)  and Verify(. . .). This is problematic for two
computational cost that will be born by each node that verifies
                                                                                 reasons. First, we do not know how large C will be in
Zerocoin transactions.
                                                                                 practice. Second, in our implementation accumulations are
All of our experiments were conducted on an Intel Xeon
                                                                                 incremental. To address these issues we chose to break our
E3-1270  V2  (3.50GHz  quad-core  processor  with  hyper-
                                                                                 microbenchmarks into two separate experiments. The first
threading) with 16GB of RAM, running 64-bit Ubuntu Server
                                                                                 experiment simply computes the accumulator for a number of
11.04 with Linux kernel 2.6.38.
possible sizes of C, ranging from 1 to 50,000 elements. The
second experiment measures the runtime of the Spend(. . .)
and Verify(. . .) routines with a precomputed accumulator
19 These sizes can be viewed as roughly corresponding to a discrete
                                                                                 and witness (A, ω).
logarithm/factorization security level of 280 , 2112 , and 2128  respectively.
                                                                                 We conducted our experiments on a single thread of the
Note that the choice of N determines the size of the parameter p. We select
|q| to be roughly twice the estimated security level.                            processor, using all three parameter sizes. All experiments




were performed 500 times, and the results given represent                                                                        transactions. For accuracy, we repeat these measurements
the average of these times. Figure 3a shows the measured                                                                         100 times and average the results. The results are presented
times for computing the coin operations, Figure 3b shows                                                                         in Figure 3d.
the resulting proof sizes for each security parameter, and
                                                                                                                                 C.  Discussion
Figure                                                                   3c  shows  the  resulting  times  for  computing  the
accumulator. We stress that accumulation in our system is                                                                        Our results show that Zerocoin scales beyond current
incremental, typically over at most the 200 − 500 transactions                                                                   Bitcoin transaction volumes. Though we require significant
in a block (which takes at worst eight seconds), and hence                                                                       computational effort, verification does not fundamentally
the cost of computing the global accumulator is therefore                                                                        threaten the operation of the network: even with a block
amortized. The only time one might accumulate 50,000 coins                                                                       containing 800 Zerocoin transactions — roughly double the
at one time would be when generating the witness for a very                                                                      average size of a Bitcoin block currently  — verification
old zerocoin.                                                                                                                    takes less than five minutes. This is under the unreasonable
                                                                                                                                 assumption that all Bitcoin transactions are supplanted by
B.  Block Verification
                                                                                                                                 Zerocoin transactions.22  In fact, we can scale well beyond
How Zerocoin affects network transaction processing de-                                                                          Bitcoin’s current average of between 200 and 400 transactions
termines its practicality and scalability. Like all transactions,                                                                per block [29] if Zerocoin transactions are not the majority
Zerocoin spends must be verified first by the miner to make                                                                      of transactions on the network. If, as the graph suggests, we
sure he is not including invalid transactions in a block and                                                                     assume that verification scales linearly, then we can support
then again by the network to make sure it is not including an                                                                    a 50% transaction mix out to 350 transactions per minute
invalid block in the block chain. In both cases, this entails                                                                    (3,500 transactions per block) and a 10% mixture out to 800
checking that Verify(. . .) = 1 for each Zerocoin transaction                                                                    transactions per minute (8,000 per block).
and computing the accumulator checkpoint.                                                                                        One remaining question is at what point we start running a
We need to know the impact of this for two reasons. First,                                                                       risk of coin serial number collisions causing erroneous double
the Bitcoin protocol specifies that a new block should be                                                                        spends. Even for our smallest serial numbers — 160 bits —
created on average once every 10 minutes.20  If verification                                                                     the collision probability is small, and for the 256 bit serial
takes longer than 10 minutes for blocks with a reasonable                                                                        numbers used with the 3072 bit accumulator, our collision
number of zerocoins, then the network cannot function.21                                                                         probability is at worst equal to the odds of a collision on a
Second,  while  the  cost  of  generating  these  blocks  and                                                                    normal Bitcoin transaction which uses SHA-256 hashes.
verifying  their  transactions  can  be  offset  by  transaction                                                                 We stress several caveats about the above data. First, our
fees and coin mining, the cost of verifying blocks prior to                                                                      prototype system does not exploit any parallelism either for
appending them to the block chain is only offset for mining                                                                      verifying multiple Zerocoin transactions or in validating an
nodes (who can view it as part of the cost of mining a new                                                                       individual proof. Since the only serial dependency for either
block). This leaves anyone else verifying the block chain                                                                        of these tasks is the (fast) duplicate serial number check, this
with an uncompensated computational cost.                                                                                        offers the opportunity for substantial improvement.
                                                                                                                                 Second, the above data is not an accurate estimate of
Experimental setup. To measure the effect of Zerocoin on
                                                                                                                                 the financial cost of Zerocoin for the network: (a) it is an
block verification time, we measure how long it takes our
                                                                                                                                 overestimate of a mining node’s extra effort when verifying
modified bitcoind client to verify externally loaded test
                                                                                                                                 proposed blocks since in practice many transactions in a
blocks containing 200, 400, and 800 transactions where 0,
                                                                                                                                 received block will already have been received and validated
10,25,75, or 100 percent of the transactions are Zerocoin
                                                                                                                                 by the node as it attempts to construct its own contribution
transactions (half of which are mints and half are spends).
                                                                                                                                 to the block chain; (b) execution time is a poor metric in
We repeat this experiment for all three security parameters.
                                                                                                                                 the context of Bitcoin, since miners are concerned with
Our test data consists of two blocks. The first contains z
                                                                                                                                 actual monetary operating cost; (c) since mining is typically
Zerocoin mints that must exist for any spends to occur. The
                                                                                                                                 performed using GPUs and to a lesser extent FPGAs and
second block is our actual test vector. It contains, in a random
                                                                                                                                 ASICs, which are far more efficient at computing hash
order, z Zerocoin spends of the coins in the previous block,
                                                                                                                                 collisions, the CPU cost measured here is likely insignificant.
z Zerocoin mints, and s standard Bitcoin sendToAddress
                                                                                                                                 Finally, our experiment neglects the load on a node both
transactions. We measure how long the processblock
                                                                                                                                 from processing incoming transactions and from solving
call of the bitcoind client takes to verify the second
                                                                                                                                 the proof of work. Again, we contend that most nodes will
block containing the mix of Zerocoin and classical Bitcoin
                                                                                                                                 probably use GPUs for mining, and as such the latter is
20 This rate is maintained by a periodic network vote that adjusts the                                                           not an issue. The former, however, remains an unknown. At
difficulty of the Bitcoin proof of work.
21 For blocks with unreasonable numbers of Zerocoin transaction we can                                                           22 In practice we believe Zerocoin will be used to anonymize bitcoins that
simply extend bitcoind’s existing anti-DoS mechanisms to reject the                                                              will then be spent in actual transactions, resulting in far lower transaction
block and blacklist its origin.                                                                                                  volumes.




                                       the very least it seems unlikely to disproportionately affect                                                                                                                                            Ron and Shamir examined the general structure of the Bitcoin
Zerocoin performance.                                                                                                                                                                                                                           network graph [1] after its nearly 3-fold expansion. Finally,
                                                                                                                                                                                                                                                we have been made privately aware of two other early-stage
                                                                                                                                                             VIII.  PREVIOUS WORK
                                                                                                                                                                                    efforts to examine Bitcoin anonymity.
A.  E-Cash and Bitcoin
                                                                                                                                                                                                                                                                                                                   IX.  CONCLUSION AND FUTURE WORK
                                       Electronic cash has long been a research topic for cryp-
                                       tographers. Many cryptographic e-cash systems focus on                                                                                                                                                   Zerocoin is a distributed e-cash scheme that provides
                                       user privacy and typically assume the existence of a semi-                                                                                                                                               strong user anonymity and coin security under the assumption
                                       trusted coin issuer or bank. E-cash schemes largely break                                                                                                                                                that there is a distributed, online, append-only transaction
                                       down into online schemes where users have contact with                                                                                                                                                   store.  We  use  Bitcoin  to  provide  such  a  store  and  the
                                       a bank or registry and offline schemes where spending can                                                                                                                                                backing currency for our scheme. After providing general
                                       occur even without a network connection. Chaum introduced                                                                                                                                                definitions, we proposed a concrete realization based on RSA
                                                                                                                                                                                                                                                accumulators and non-interactive zero-knowledge signatures
                                       the first online cryptographic e-cash system [30] based on
                                                                                                                                                                                                                                                of knowledge. Finally, we integrated our construction into
                                       RSA signatures, later extending this work to the offline
setting                                                                                                     [31] by de-anonymizing users who double-spent.                          Bitcoin and measured its performance.
                                       Many subsequent works improved upon these techniques                                                                                                                                                     Our work leaves several open problems. First, although our
                                       while maintaining the requirement of a trusted bank: for                                                                                                                                                 scheme is workable, the need for a double-discrete logarithm
                                       example, by making coins divisible [32, 33] and reducing                                                                                                                                                 proof leads to large proof sizes and verification times. We
                                       wallet size  [34]. One exception to the rule above comes                                                                                                                                                 would prefer a scheme with both smaller proofs and greater
                                       from Sander and Ta-Shma [35] who presciently developed                                                                                                                                                   speed.  This  is  particularly  important  when  it  comes  to
                                       an alternative model that is reminiscent of our proposal: the                                                                                                                                            reducing the cost of third-party verification of Zerocoin
                                       central bank is replaced with a hash chain and signatures                                                                                                                                                transactions. There are several promising constructions in the
                                       with accumulators. Unfortunately the accumulator was not                                                                                                                                                 cryptographic literature, e.g., bilinear accumulators, mercurial
                                       practical, a central party was still required, and no real-world                                                                                                                                         commitments [13, 39]. While we were not able to find an
system existed to compute the chain.                                                                                                                                                                                                            analogue of our scheme using alternative components, it is
                                       Bitcoin’s primary goal, on the other hand, is not anonymity.                                                                                                                                             possible that further research will lead to other solutions.
                                       It has its roots in a non-academic proposal by Wei Dai                                                                                                                                                   Ideally  such  an  improvement  could  produce  a  drop-in
                                       for a distributed currency based on solving computational                                                                                    replacement for our existing implementation.
                                       problems [36]. In Dai’s original proposal anyone could create                                                                                                                                            Second, Zerocoin currently derives both its anonymity
                                       currency, but all transactions had to be broadcast to all clients.                                                                                                                                       and security against counterfeiting from strong cryptographic
                                       A second variant limited currency generation and transaction                                                                                                                                             assumptions at the cost of substantially increased computa-
                                       broadcast to a set of servers, which is effectively the approach                                                                                                                                         tional complexity and size. As discussed in section VI-B,
                                       Bitcoin takes. This is a marked distinction from most, if not                                                                                                                                            anonymity is relatively cheap, and this cost is principally
                                       all, other e-cash systems since there is no need to select one                                                                                                                                           driven by the anti-counterfeiting requirement, manifesting
                                       or more trusted parties. There is a general assumption that                                                                                  itself through the size of the coins and the proofs used.
                                       a majority of the Bitcoin nodes are honest, but anyone can                                                                                                                                               In Bitcoin, counterfeiting a coin is not computationally
                                       join a node to the Bitcoin network, and anyone can get the                                                                                                                                               prohibitive, it is merely computationally costly, requiring the
                                       entire transaction graph. An overview of Bitcoin and some                                                                                                                                                user to obtain control of at least 51% of the network. This
                                       of its shortcomings was presented by Barber et. al. in [2].                                                                                                                                              provides a possible alternative to our standard cryptographic
                                                                                                                                                                                                                                                assumptions: rather than the strong assumption that com-
B.  Anonymity
                                                                                                                                                                                                                                                puting discrete logs is infeasible, we might construct our
                                       Numerous works have shown that “pseudonymized” graphs                                                                                                                                                    scheme on the weak assumption that there is no financial
                                       can be re-identified even under passive analysis. Narayanan                                                                                                                                              incentive to break our construction as the cost of computing
                                       and Shmatikov [5] showed that real world social networks                                                                                                                                                 a discrete log exceeds the value of the resulting counterfeit
                                       can be passively de-anonymized. Similarly, Backstrom et                                                                                      coins.
al.                                    [37] constructed targeted attacks against anonymized                                                                                                                                                     For example, if we require spends to prove that fresh
                                       social networks to test for relationships between vertices.                                                                                                                                              and random bases were used in the commitments for the
                                       Previously, Narayanan and Shmatikov de-anonymized users                                                                                                                                                  corresponding mint transaction (e.g., by selecting the bases
                                       in  the  Netflix  prize  data  set  by  correlating  data  from                                                                                                                                          for the commitment from the hash of the coin serial number
IMDB [38].                                                                                                                                                                                                                                      and proving that the serial number is fresh), then it appears
                                       Bitcoin itself came into existence in  2009  and is now                                                                                                                                                  that an attacker can only forge a single zerocoin per discrete
                                       beginning to receive scrutiny from privacy researchers. De-                                                                                                                                              log computation. Provided the cost of computing such a
                                       anonymization techniques were applied effectively to Bitcoin                                                                                                                                             discrete log is greater than the value of a zerocoin, forging a
                                       even at its relatively small 2011 size by Reid and Harrigan [3].                                                                                                                                         coin is not profitable. How small this allows us to make




                                                                 the  coins  is  an  open  question.  There  is  relatively  little   [12]                                                                   J. Camenisch and A. Lysyanskaya, “Dynamic accumulators
                                                                 work comparing the asymptotic difficulty of solving multiple                                                                                and application to efficient revocation of anonymous creden-
                                                                                                                                      tials,” in CRYPTO ’02, 2002, pp. 61-76.
                                                                 distinct discrete logs in a fixed group,23  and it is not clear
                                                                 how theory translates into practice. We leave these questions,       [13]                                                                   L. Nguyen, “Accumulators from bilinear pairings and appli-
                                                                 along with the security of the above proposed construction,                                                                                 cations,” in Topics in Cryptology - CT-RSA 2005, 2005, vol.
as issues for future work.                                                                                                            3376 LNCS, pp. 275-292.
                                                                 Finally, we believe that further research could lead to
                                                                                                                                      [14]                                                                   J. Camenisch, M. Kohlweiss, and C. Soriente, “An accumulator
                                                                 different  tradeoffs  between  security,  accountability,  and                                                                              based on bilinear maps and efficient revocation for anonymous
                                                                 anonymity. A common objection to Bitcoin is that it can                                                                                     credentials,” in PKC ’09, vol. 5443 of LNCS, 2009, pp. 481-
                                                                 facilitate money laundering by circumventing legally binding         500.
                                                                 financial reporting requirements. We propose that additional
                                                                                                                                      [15]                                                                   S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,
                                                                 protocol modifications (e.g., the use of anonymous creden-           2009,”                                                                 2012.                                                           [Online].  Available:  http://www.bitcoin.org/
tials                                                            [40]) might allow users to maintain their anonymity                  bitcoin.pdf
                                                                 while demonstrating compliance with reporting requirements.
                                                                                                                                      [16]                                                                   G. O. Karame, E. Androulaki, and S. Capkun, “Two bitcoins
                                                                                                                                                                                                             at the price of one? double-spending attacks on fast payments
Acknowledgements. We thank Stephen Checkoway, George
in bitcoin,” Cryptology ePrint Archive, Report 2012/248, 2012,
Danezis, and the anonymous reviewers for their helpful
http://eprint.iacr.org/.
comments. The research in this paper was supported in part
                                                                                                                                      by the Office of Naval Research under contract N00014-11-                                                                              [17]                                             European   Central   Bank,                                                                                                                                         “Virtual   currency   schemes,”
                                                                                                                                      1-0470, and DARPA and the Air Force Research Laboratory                                                                                                                                 Available                                             at                                                                 http://www.ecb.europa.eu/pub/pdf/other/
                                                                                                                                                                                                                                                                                                                                                                                    virtualcurrencyschemes201210en.pdf, October 2012.
(AFRL) under contract FA8750-11-2-0211.
                                                                                                                                                                                                                                                                             [18]                                                                                                   C.-P. Schnorr, “Efficient signature generation for smart cards,”
                                                                                                                                                                                                             REFERENCES
                                                                                                                                                                                                                                                                                                                                                                                    Journal of Cryptology, vol. 4, no. 3, pp. 239-252, 1991.
[1]                                                                                                                                   D. Ron and A. Shamir, “Quantitative Analysis of the Full
                                                                                                                                                                                                                                                                             [19]                                                                                                   R. Cramer, I. Damgård, and B. Schoenmakers, “Proofs of
                                                                                                                                      Bitcoin Transaction Graph,” Cryptology ePrint Archive, Report
                                                                                                                                                                                                                                                                                                                                                                                    partial knowledge and simplified design of witness hiding
2012/584, 2012, http://eprint.iacr.org/.
                                                                                                                                                                                                                                                                                                                                                                                    protocols,” in CRYPTO  ’94, vol.  839  of LNCS,  1994, pp.
[2]                                                                                                                                   S. Barber, X. Boyen, E. Shi, and E. Uzun, “Bitter to better                                                                                                                             174-187.
                                                                                                                                      -  how  to  make  bitcoin  a  better  currency,”  in  Financial
                                                                                                                                                                                                                                                                             [20]                                                                                                   J. Camenisch and M. Michels, “Proving in zero-knowledge that
                                                                                                                                      Cryptography 2012, vol. 7397 of LNCS, 2012, pp. 399-414.
                                                                                                                                                                                                                                                                                                                                                                                    a number n is the product of two safe primes,” in EUROCRYPT
[3]                                                                                                                                   F. Reid and M. Harrigan, “An analysis of anonymity in the                                                                                                                               ’99, vol. 1592 of LNCS, 1999, pp. 107-122.
                                                                                                                                      Bitcoin system,” in Privacy, security, risk and trust (PASSAT),
                                                                                                                                                                                                                                                                             [21]                                                                                                   J. L. Camenisch,  “Group signature schemes and payment
                                                                                                                                      2011 IEEE Third Internatiojn Conference on Social Computing
                                                                                                                                                                                                                                                                                                                                                                                    systems based on the discrete logarithm  problem,” Ph.D.
                                                                 (SOCIALCOM).   IEEE, 2011, pp. 1318-1326.
                                                                                                                                                                                                                                                                                                                              dissertation, ETH Z ürich, 1998.
[4]                                                                                                                                   T. B. Lee, “A risky currency? Alleged $500,000 Bitcoin heist
                                                                                                                                                                                                                                                                             [22]                                                                                                   S. Brands, “Rapid demonstration of linear relations connected
                                                                                                                                      raises questions,” Available at http://arstechnica.com/, June
                                                                                                                                                                                                                                                                                                                                                                                    by boolean operators,” in EUROCRYPT  ’97, vol.  1233  of
2011.
                                                                                                                                                                                                                                                                                                                              LNCS, 1997, pp. 318-333.
[5]                                                                                                                                   A. Narayanan and V. Shmatikov, “De-anonymizing social net-
                                                                                                                                                                                                                                                                             [23]                                                                                                   A. Fiat and A. Shamir, “How to prove yourself: Practical
                                                                                                                                      works,” in Security and Privacy, 2009 30th IEEE Symposium
                                                                                                                                                                                                                                                                                                                                                                                    solutions to identification and signature problems,” in CRYPTO
on.   IEEE, 2009, pp. 173-187.
                                                                                                                                                                                                                                                                                                                              ’86, vol. 263 of LNCS, 1986, pp. 186-194.
[6]                                                              “Bitcoin fog company,” http://www.bitcoinfog.com/.
                                                                                                                                                                                                                                                                             [24]                                                                                                   M. Chase and A. Lysyanskaya, “On signatures of knowledge,”
[7]                                                                                                                                   “The Bitcoin Laundry,” http://www.bitcoinlaundry.com/.                                                                                                                                                                                        in CRYPTO’06, vol. 4117 of LNCS, 2006, pp. 78-96.
[8]                                                                                                                                   “Blind Bitcoin,” Information at https://en.bitcoin.it/wiki/Blind                                                                       [25]                                             J.  Camenisch  and  M.  Stadler,                                                                                                                                   “Efficient  group  signature
Bitcoin  Transfers.                                                                                                                                                                                                                                                                                                                                                                 schemes for large groups,” in CRYPTO  ’97, vol.  1296  of
                                                                                                                                                                                                                                                                                                                              LNCS, 1997, pp. 410-424.
[9]                                                              [Online]. Available: https://www.torproject.org/
                                                                                                                                                                                                                                                                             [26]                                                                                                   T. Sander, “Efficient accumulators without trapdoor extended
[10]                                                                                                                                  J.  Benaloh  and  M.  de  Mare,  “One-way  accumulators:  a                                                                                                                                                                                   abstract,” in Information and Communication Security, vol.
                                                                                                                                      decentralized alternative to digital signatures,” in EUROCRYPT                                                                                                                          1726 of LNCS, 1999, pp. 252-262.
                                                                 ’93, vol. 765 of LNCS, 1994, pp. 274-285.
                                                                                                                                                                                                                                                                             [27]                                                                                                   J.  A.  Akinyele,  C.  Garman,  I.  Miers,  M.  W.  Pagano,
[11]                                                                                                                                  N. Barić and B. Pfitzmann, “Collision-free accumulators and                                                                                                                                                                                   M.  Rushanan,  M.  Green,  and  A.  D.  Rubin,                                                                                                 “Charm:
                                                                                                                                      fail-stop signature schemes without trees,” in EUROCRYPT                                                                                                                                                                                      A  framework  for  rapidly  prototyping  cryptosystems,”  To
                                                                 ’97, vol. 1233 of LNCS, 1997, pp. 480-494.                                                                                                                                                                                                                                                                         appear, Journal of Cryptographic Engineering, 2013. [Online].
                                                                                                                                                                                                                                                                                                                                                                                    Available: http://dx.doi.org/10.1007/s13389-013-0057-3
                                                                                                                                      23 We note that both SSH and the Internet Key Exchange protocol used
in IPv6 use fixed Diffie-Hellman parameters.                                                                                                                                                                                                                                 [28]                                             [Online]. Available: https://en.bitcoin.it/wiki/BIP                                                                                                                                                  0016




[29]                                    [Online].                                                                                                                                                                                 Available:                      http://blockchain.info/charts/n-                                                                                                                                                                                         any strategy it wishes. Next the simulation runs A2  with a
                                        transactions-per-block                                                                                                                                                                                                                                                                                                                                                                                                                             simulated25  zero-knowledge signature of knowledge π and a
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           random coin serial number S sampled from Zq . Note that if
[30]                                                                                                                                                       D. Chaum, “Blind signatures for untraceable payments,” in
                                                                              CRYPTO ’82.   Plenum Press, 1982, pp. 199-203.                                                                                                                                                                                                                                                                                                                                                               π is at least computationally zero-knowledge then with all but
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           negligible probability, all values provided to A are distributed
[31]                                                                                                                                                       D. Chaum, A. Fiat, and M. Naor, “Untraceable electronic
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           as in the real protocol. Moreover, all are independent of the
                                                                                                                                                           cash,” in CRYPTO 88, 1990, vol. 403 of LNCS, pp. 319-327.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           bit b. By implication, Pr [ b = b′ ] = 1/2 + ν(λ) and A’s
[32]                                                                                                                                                       T. Okamoto and K. Ohta,  “Universal electronic cash,” in                                                                                                                 advantage is negligible.                                                                                                                                                                                                                                                                                                                                                                                   ✷
                                                                              CRYPTO 91, 1992, vol. 576 of LNCS, pp. 324-337.
                                                                                                                                                                                                                                                                                                                                    B.  Proof of Theorem 4.2
[33]                                                                                                                                                       T. Okamoto, “An efficient divisible electronic cash scheme,”
                                                                              in Crypt ’95, 1995, vol. 963 of LNCS, pp. 438-451.                                                                                                                                                                                                                                                                                                                                                           Proof: Let A be an adversary that wins the Balance game
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           with non-negligible advantage ϵ. We construct an algorithm
[34]                                                                                                                                                       J. Camenisch, S. Hohenberger, and A. Lysyanskaya, “Compact
                                                                                                                                                           e-cash,” in EUROCRYPT ’05, 2005, vol. 3494 of LNCS, pp.                                                                                                                                                                                                                                                                         B that takes input (p, q, g, h), where G = 〈g〉 = 〈h〉 is a
                                        566-566.                                                                                                                                                                                                                                                                                                                                                                                                                                           subgroup of Zp  of order q, and outputs x ∈ Zq  such that
                                                                                                                                                                                                                                                                                                                                    gx  ≡ h  (mod p). B works as follows:
[35]                                                                                                                                                       T. Sander and A. Ta-Shma, “Auditable, anonymous electronic
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           On input  (p, q, g, h), first generate accumulator param-
                                                                                                                                                           cash (extended abstract),” in CRYPTO ’99, vol. 1666 of LNCS,
                                        1999, pp. 555-572.                                                                                                                                                                                                                                                                                                                                                                       eters N, u  as in the Setup  routine and set params                                                                                                                                                                                                                                                           ←
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           (N, u, p, q, g, h). For i  =  1  to K , compute  (ci , skci )  ←
[36]                                    W.  Dai.  B-money  proposal.                                                                                                                                                                                                                                 [Online].  Available:  http:
                                                                                                                                                                                                                                                                                                                                    Mint(params),   where   skci                                                                                                                                                                                                                                                                                                                =   (Si , ri ),   and   run
                                        //www.weidai.com/bmoney.txt
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           A(params, c1 , . . . , cK ).  Answer  each  of  A’s  queries  to
[37]                                                                                                                                                       L. Backstrom, C. Dwork, and J. Kleinberg, “Wherefore art
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Ospend   using  the  appropriate  trapdoor  information.  Let
                                                                                                                                                           thou r3579x?: Anonymized social networks, hidden patterns,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           (S1 , R1 ), . . . , (Sl , Rl ) be the set of values recorded by the
                                                                                                                                                           and structural steganography,” in Proceedings of the  16th
                                                                                                                                                                                                                                                                                                                                    oracle.
                                                                                                                                                           international conference on World Wide Web, ser. WWW ’07.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           At the conclusion of the game, A outputs a set of M
                                                                              New York, NY, USA: ACM, 2007, pp. 181-190.
                                                                                                                                                                                                                                                                                                                                    coins (c′
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        1 , . . . , c′M ) and a corresponding set of M + 1 valid
[38]                                                                                                                                                       A. Narayanan and V. Shmatikov, “Robust de-anonymization
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           tuples (πi , S′i , Ri , Ci ). For j = 1 to M +1, apply the ZKSoK
                                                                                                                                                           of large sparse datasets,” in IEEE Symposium on Security and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           extractor to the jth  zero-knowledge proof πj  to extract the
                                        Privacy.   IEEE, 2008, pp. 111-125.
                                                                                                                                                                                                                                                                                                                                                                            values (cj , rj ) and perform the following steps:
[39]                                                                                                                                                       M. Chase, A. Healy, A. Lysyanskaya, T. Malkin, and L. Reyzin,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           1)  If the extractor fails, abort and signal EVENTEXT .
                                                                                                                                                           “Mercurial commitments with applications to zero-knowledge
                                                                                                                                                                                                                                                                                                                                                                            2)  If cj  ∈ C′                                                                                                                                                                             j , abort and signal EVENTACC .
                                                                                                                                                           sets,” in EUROCRYPT ’05, vol. 3494, 2005, pp. 422-439.
                                                                                                                                                                                                                                                                                                                                                                            3)  If cj  ∈ {c1 , . . . , cK }:
[40]                                                                                                                                                       J.  Camenisch  and  A.  Lysyanskaya,  “An  efficient  system
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           a)  If for some i, (Sj , rj ) = (Si , ri ) and R′                                                                                                                                                                                          = Ri ,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      j
                                                                                                                                                           for  non-transferable  anonymous  credentials  with  optional
                                                                                                                                                           anonymity revocation,” in EUROCRYPT ’01, vol. 2045 of                                                                                                                                                                                                                                                                           abort and signal EVENTFORGE .
                                        LCNS, 2001, pp. 93-118.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         b)  Otherwise if for some i, (Sj , rj ) = (Si , ri ), abort
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           and signal EVENTCOL .
[41]                                                                                                                                                       ——,  “Dynamic accumulators and application to efficient
                                                                                                                                                                                                                                                                                                                                                                                                                                 c)  Otherwise set (a, b) = (Si , ri ).
                                                                                                                                                           revocation of anonymous credentials,” in CRYPTO ’02, 2002,
                                                                                                                                                           extended Abstract. [Online]. Available: http://cs.brown.edu/                                                                                                                                                                                                          4)  If for some i, cj  = ci , set (a, b) = (S′i , ri ).
                                        ∼anna/papers/camlys02.pdf                                                                                                                                                                                                                                                                                                                                                                                                                          If  the  simulation  did  not  abort,  we  now  have
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           (cj , rj , Sj , a, b) where  (by the soundness of π) we know
[42]                                                                                                                                                       D. Pointcheval and J. Stern, “Provably secure blind signature
                                                                                                                                                           schemes,” in ASIACRYPT ’96, vol. 1163 of LNCS, 1996, pp.                                                                                                                 that cj                                                                                                                                                                                                                             ≡  gSj hrj  ≡  gahb  (mod p). To solve for logg h,
                                        252-265.                                                                                                                                                                                                                                                                                    output (Sj  − a) · (b − r′
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      j )−1  mod q.
                                                                                                                                                                                                                                                    APPENDIX A.                                                                                                                                                                                                                            Analysis. Let us briefly explain the conditions behind this
                                                                                                                                                                                                                                  SECURITY PROOFS                                                                                                                                                                                                                                          proof. When the simulation does not abort, we are able to
A.  Proof Sketch of Theorem 4.1                                                                                                                                                                                                                                                                                                                                                                                                                                                            extract (c1 , . . . , cM  +1 ) where the win conditions enforce that
                                                                                                                                                                                                                                                                                                                                    ∀j  ∈ [1, M + 1], cj  ∈ C′                                                                                                                                                                                                                                                                        j               ∈ {c1 , . . . , cK , c′                                 1 , . . . , c′M } and
                                                                              Proof sketch. Consider the following simulation. First, the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           each Sj  is distinct (and does not match any serial number
                                                                              simulation generates params ← Setup(1λ ) and two primes
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           output by Ospend ). Since A has produced M coins and yet
                                                                              C0 , C1  that are uniformly sampled from the set of prime
                                                                                                                                                                                                                                                                                                                                                                            spent M + 1, there are only two possibilities:
                                                                              numbers in the range  [A , B ].24   A1   takes these values as
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           1)  A has spent one of the challenger’s coins but has
                                                                              input and outputs a set C and transaction string R using
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        provided a new serial number for it. For some (i, j),
                                                                                                                                                           24 “Where A and B can be chosen with arbitrary polynomial dependence
                                                                              on the security parameter, as long as 2 < A and B < A 2 .” [41] For a full                                                                                                                                                                                                                                                                                                                                   25 Our proofs assume the existence of an efficient simulator and extractor
description, see [41, §3.2 and §3.3].                                                                                                                                                                                                                                                                                               for the ZKSoK. See Appendix B.




cj  = ci  ∈ {c1 , . . . , cK }. Observe that in cases where                                                                                             e.g., [25]. Let A′  be an adversary that induces EVENTFORGE
the simulation does not abort, the logic of the simu-                                                                                                   with non-negligible probability ϵ′  in the simulation above.
lation always results in a pair (a, b) = (Si , ri ) where                                                                                               On input a discrete logarithm instance, we run A′  as in
gahb                                                                     ≡  gSj hrj ≡  cj  (mod p) and (a, b) = (Sj , rj ).                             the main simulation except that we do not use the trapdoor
2)  A has spent the same coin twice. For some  (i, j),                                                                                                  information to answer A′ ’s oracle queries. Instead we select
                                                                                                                                                        random serial numbers and simulate the ZKSoK responses
cj  = ci  and yet (Sj  = S′i ). Thus again we identify
a pair  (a, b)                                                                                                                ≡   cj                    to A′  by programming the random oracle. When A′  outputs
                                                                         =  (S′i , ri ) that satisfies gahb
(mod p) where (a, b) = (Sj , rj ).                                                                                                                      a forgery on a repeated serial number but a different string
                                                                                                                                                        R′  than used in any previous proof, we rewind A′  to extract
Finally, we observe that given any such pair (a, b) we can
                                                                                                                                                        the pair (Sj , rj ) and solve for the discrete logarithm as in
solve for x = logg h using the equation above.
                                                                                                                                                        the main simulation.                                                                                         ✷
Abort probability. It remains only to consider the probability
that the simulation aborts. Let ν1 (λ)  be the  (negligible)
probability that the extractor fails on input π. By sum-
                                                                                                                                                                                                                         APPENDIX B.
mation, Pr [ EVENTEXT  ]  ≤  (M + 1)ν1 (λ). Next consider                                                                                               ZERO-KNOWLEDGE PROOF CONSTRUCTION
the probability of EVENTCOL . This implies that for some
                                                                                                                                                        The signature of knowledge
i, A  has produced a pair  (Sj , rj )                                                                                         =  (Si , ri )  where Sj
has not been produced by Ospend . Observe that there are                                                                                                π = ZKSoK[R]{(c, w, r) :
l  distinct pairs                                                        (S, r) that satisfy cj                               =  gS hr  mod p and       AccVerify((N, u), A, c, w) = 1  ∧  c = gS hr }
A’s view is independent of the specific pair chosen. Thus
                                                                                                                                                        is composed of two proofs that (1) a committed value c
Pr [ EVENTCOL  ] ≤ 1/l.
                                                                                                                                                        is accumulated and (2) that c is a commitment to S. The
Next,  we  argue  that  under  the  Strong  RSA  and  Dis-
                                                                                                                                                        former proof is detailed in [41, §3.3 and Appendix A]. The
crete  Log  assumptions,  Pr [ EVENTACC  ]                                                                                    ≤  ν2 (λ)  and
                                                                                                                                                        latter is a double discrete log signature of knowledge that,
Pr [ EVENTFORGE  ] ≤ ν3 (λ). We show this in Lemmas A.1
                                                                                                                                                        although related to previous work [21, §5.3.3], is new (at
and A.2 below. If A succeeds with advantage ϵ, then by
                                                                                                                                                        least to us). A proof of its security can be found in the full
summing the above probabilities we show that B succeeds
                                                                                                                                                        version of this paper. It is constructed as follows:
with probability ≥ ϵ − ((M + 1)ν1 (λ) +ν2 (λ) +ν3 (λ) + 1/l).
                                                                                                                                                        Given y1  = gaxbz hw .
We conclude with the remaining Lemmas.
                                                                                                                                                        Let l  ≤ k  be two security parameters and H  :
Lemma A.1:  Under   the   Strong   RSA   assumption,
                                                                                                                                                        {0, 1}∗  → {0, 1}k  be a cryptographic hash func-
Pr [ EVENTACC  ] ≤ ν2 (λ).                                                                                                                              tion. Generate 2l random numbers r1 , . . . , rl  and
Proof sketch. The basic idea of this proof is that an A′  who                                                                                           v1 , . . . , vl . Compute, for 1 ≤ i ≤ l, ti  = gaxbri hvi .
                                                                                                                                                        The signature of knowledge on the message m is
induces EVENTACC  with non-negligible probability can be
used to find a witness ω to the presence of a non-member in a                                                                                           (c, s1 , s2 , . . . , sl , s′                                    1 , s′2 , . . . , sl ), where:
given accumulator. Given this value, we apply the technique
                                                                                                                                                        c = H (m∥y1 ∥a∥b∥g∥h∥x∥t1 ∥ . . . ∥tl )
of [12, §3] to solve the Strong RSA problem. For the complete
details we refer the reader to [12, §3] and simply outline the                                                                                          and
remaining details of the simulation.
                                                                                                                                                        if c[i] = 0 then si  = ri , si  = vi ;
Let A′  be an adversary that induces EVENTACC  with non-
                                                                                                                                                                                                                         else si  = ri  − z, si  = vi  − wbri −z ;
negligible probability ϵ′  in the simulation above. We use
A′  to construct a Strong RSA solver B′  that succeeds with                                                                                             To verify the signature it is sufficient to compute:
non-negligible probability. On input a Strong RSA instance
                                                                                                                                                                                                                                                                     tl )
(N, u), B′  selects (p, q, g, h) as in Setup and sets params =
(N, u, p, q, g, h). It generates (c1 , . . . , cK ) as in the previous                                                                                  with
simulation and runs A′ . To induce EVENTACC , A′  produces
valid output (π′ , C′ ) and (by extraction from π′ ) a c∗  ∈ C′ .                                                                                                                                                        ti  = gaxbsi hsi ;
B′  now extracts ω∗  from π′  using the technique described                                                                                                                                                              ti  = y1si hsi ;
in [12, §3] and uses the resulting value to compute a solution
                                                                                                                                                        and check whether c = c′ .
to the Strong RSA instance.                                                                                                                             ✷
                                                                                                                                                        Simulating and extracting. Our proofs in Appendix A assume
Lemma A.2:  Under the Discrete Logarithm assumption,
                                                                                                                                                        the existence of an efficient simulator and extractor for the
Pr [ EVENTFORGE  ] ≤ ν3 (λ).                                                                                                                            signature of knowledge. These may be constructed using well-
Proof sketch. We leave a proof for the full version of this                                                                                             understood results in the random oracle model, e.g., [25, 42].
paper, but it is similar to those used by earlier schemes,                                                                                              We provide further details in the full version of this work.





