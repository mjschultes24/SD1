Zcash Protocol Speci  cation
Version 2019.0-beta-36 [Overwinter+Sapling]
Daira Hopwood †
Sean Bowe † — Taylor Hornby † — Nathan Wilcox †
February 10, 2019
1
Abstract. Zcash is an implementation of the Decentralized Anonymous Payment scheme Zerocash,
with security   xes and improvements to performance and functionality. It bridges the existing trans-
parent payment scheme used by Bitcoin with a shielded payment scheme secured by zero-knowledge
succinct non-interactive arguments of knowledge (zk-SNARKs ). It attempted to address the problem
of mining centralization by use of the Equihash memory-hard proof-of-work algorithm.
This speci  cation de  nes the Zcash consensus protocol at launch; after the upgrade codenamed Over-
winter; and after the subsequent upgrade codenamed Sapling. It is a work in progress. Protocol dif-
ferences from Zerocash and Bitcoin are also explained.
Keywords:  anonymity,  applications,  cryptographic protocols,  electronic commerce and payment,
nancial privacy, proof of work, zero knowledge.
Contents                                                                                                                      1
1                                                                                                       Introduction          7
1.1                                                                                                     Caution               7
1.2                                                                                                     High-level Overview   7
† Zerocoin Electric Coin Company
1
Jubjub bird image credit: Peter Newell 1902; Daira Hopwood 2018.
1




2     Notation                                                                                                                                9
3     Concepts                                                                                                                                11
3.1                       Payment Addresses and Keys  .  .  .                                                                                 11
3.2   Notes .  .  .                                                                                                                           12
      3.2.1               Note Plaintexts and Memo Fields                                                                                     13
3.3                       The Block Chain  .  .  .                                                                                            14
3.4                       Transactions and Treestates  .  .  .                                                                                14
3.5                       JoinSplit Transfers and Descriptions  .  .  .                                                                       15
3.6                       Spend Transfers, Output Transfers, and their Descriptions                                                           15
3.7                       Note Commitment Trees .  .  .                                                                                       16
3.8                       Nulli  er Sets                                                                                                      17
3.9                       Block Subsidy and Founders’ Reward  .  .  .                                                                         17
                          3.10  Coinbase Transactions                                                                                         17
4     Abstract Protocol                                                                                                                       17
4.1                       Abstract Cryptographic Schemes .  .  .                                                                              17
      4.1.1               Hash Functions  .  .  .                                                                                             17
      4.1.2               Pseudo Random Functions  .  .  .                                                                                    18
      4.1.3                                                                           Authenticated One-Time Symmetric Encryption .  .  .     19
      4.1.4               Key Agreement  .  .  .                                                                                              19
      4.1.5               Key Derivation                                                                                                      19
      4.1.6               Signature  .  .  .                                                                                                  20
                          4.1.6.1                                                     Signature with Re-Randomizable Keys  .  .  .            21
                          4.1.6.2                                                     Signature with Private Key to Public Key Homomorphism   22
      4.1.7               Commitment                                                                                                          23
      4.1.8               Represented Group                                                                                                   24
      4.1.9               Hash Extractor                                                                                                      24
      4.1.10              Group Hash                                                                                                          25
      4.1.11              Represented Pairing                                                                                                 25
      4.1.12              Zero-Knowledge Proving System                                                                                       26
4.2                       Key Components                                                                                                      27
      4.2.1               Sprout Key Components                                                                                               27
      4.2.2               Sapling Key Components  .  .  .                                                                                     27
4.3                       JoinSplit Descriptions .  .  .                                                                                      29
4.4                       Spend Descriptions  .  .  .                                                                                         30
4.5                       Output Descriptions                                                                                                 31
4.6                       Sending Notes                                                                                                       32
      4.6.1               Sending Notes (Sprout)                                                                                              32
      4.6.2               Sending Notes (Sapling)  .  .  .                                                                                    32
4.7                       Dummy Notes  .  .  .                                                                                                33
      4.7.1               Dummy Notes (Sprout)                                                                                                33
      4.7.2               Dummy Notes (Sapling)  .  .  .                                                                                      34
4.8                       Merkle path validity  .  .  .                                                                                       34
4.9                       SIGHASH Transaction Hashing  .  .  .                                                                                35
2




4.10     Non-malleability (Sprout)                                                                                36
4.11     Balance (Sprout)  .  .  .                                                                                36
4.12     Balance and Binding Signature (Sapling)                                                                  37
4.13     Spend Authorization Signature  .  .  .                                                                   39
4.14     Note Commitments and Nulli  ers  .  .  .                                                                 40
4.15     Zk-SNARK Statements  .  .  .                                                                             41
4.15.1   JoinSplit Statement (Sprout)                                                                             41
4.15.2   Spend Statement (Sapling)                                                                                42
4.15.3   Output Statement (Sapling) .  .  .                                                                       43
4.16     In-band secret distribution (Sprout) .  .  .                                                             44
4.16.1   Encryption (Sprout)                                                                                      44
4.16.2   Decryption (Sprout)                                                                                      45
4.17     In-band secret distribution (Sapling)                                                                    45
4.17.1   Encryption (Sapling)  .  .  .                                                                            46
4.17.2                                                  Decryption using an Incoming Viewing Key (Sapling) .  .   46
4.17.3                                                  Decryption using a Full Viewing Key (Sapling)             47
4.18     Block Chain Scanning (Sprout)                                                                            48
4.19     Block Chain Scanning (Sapling)  .  .  .                                                                  48
5        Concrete Protocol                                                                                        49
5.1      Caution                                                                                                  49
5.2      Integers, Bit Sequences, and Endianness                                                                  49
5.3      Constants  .  .  .                                                                                       50
5.4      Concrete Cryptographic Schemes                                                                           51
5.4.1    Hash Functions  .  .  .                                                                                  51
         5.4.1.1                                        SHA-256 and SHA256Compress Hash Functions  .  .  .        51
         5.4.1.2                                        BLAKE2 Hash Function .  .  .                              52
         5.4.1.3                                        Merkle Tree Hash Function                                 52
         5.4.1.4                                                                                                  53
                                                        hSig Hash Function
         5.4.1.5                                        CRHivk Hash Function                                      53
         5.4.1.6                                        DiversifyHash Hash Function .  .  .                       53
         5.4.1.7                                        Pedersen Hash Function  .  .  .                           54
         5.4.1.8                                        Mixing Pedersen Hash Function                             56
         5.4.1.9                                        Equihash Generator                                        57
5.4.2    Pseudo Random Functions  .  .  .                                                                         57
5.4.3                                                   Authenticated One-Time Symmetric Encryption .  .  .       58
5.4.4    Key Agreement and Derivation                                                                             59
         5.4.4.1                                        Sprout Key Agreement .  .  .                              59
         5.4.4.2                                        Sprout Key Derivation                                     59
         5.4.4.3                                        Sapling Key Agreement                                     59
         5.4.4.4                                        Sapling Key Derivation .  .  .                            60
5.4.5    JoinSplit Signature                                                                                      60
5.4.6    RedDSA and RedJubjub .  .  .                                                                             60
         5.4.6.1                                        Spend Authorization Signature .  .  .                     63
         5.4.6.2                                        Binding Signature  .  .  .                                63
3




      5.4.7                   Commitment schemes                                                                                63
                              5.4.7.1                                       Sprout Note Commitments  .  .  .                    63
                              5.4.7.2                                       Windowed Pedersen commitments .  .  .               64
                              5.4.7.3                                       Homomorphic Pedersen commitments                    64
      5.4.8                                                                 Represented Groups and Pairings  .  .  .            65
                              5.4.8.1                                       BN-254                                              65
                              5.4.8.2                                       BLS12-381  .  .  .                                  67
                              5.4.8.3                                       Jubjub  .  .  .                                     68
                              5.4.8.4                                       Hash Extractor for Jubjub                           69
                              5.4.8.5                                       Group Hash into Jubjub                              70
      5.4.9                                                                 Zero-Knowledge Proving Systems                      70
                              5.4.9.1                                       BCTV14                                              70
                              5.4.9.2                                       Groth16                                             71
5.5                                                                         Encodings of Note Plaintexts and Memo Fields        72
5.6                           Encodings of Addresses and Keys                                                                   73
      5.6.1                   Transparent Addresses                                                                             73
      5.6.2                   Transparent Private Keys                                                                          74
      5.6.3                                                                 Sprout Shielded Payment Addresses                   74
      5.6.4                                                                 Sapling Shielded Payment Addresses .  .             74
      5.6.5                                                                 Sprout Incoming Viewing Keys                        75
      5.6.6                                                                 Sapling Incoming Viewing Keys  .  .  .              75
      5.6.7                                                                 Sapling Full Viewing Keys .  .  .                   76
      5.6.8                                                                 Sprout Spending Keys  .  .  .                       76
      5.6.9                   Sapling Spending Keys                                                                             77
5.7                           BCTV14 zk-SNARK Parameters                                                                        77
5.8                           Groth16 zk-SNARK Parameters  .  .  .                                                              77
5.9                           Randomness Beacon  .  .  .                                                                        78
6     Network Upgrades                                                                                                          78
7                             Consensus Changes from Bitcoin                                                                    79
7.1                           Encoding of Transactions                                                                          79
7.2                           Encoding of JoinSplit Descriptions  .  .  .                                                       82
7.3                           Encoding of Spend Descriptions  .  .  .                                                           83
7.4                           Encoding of Output Descriptions .  .  .                                                           83
7.5   Block Header  .  .  .                                                                                                     84
7.6   Proof of Work                                                                                                             86
      7.6.1                   Equihash  .  .  .                                                                                 86
      7.6.2                   Dif  culty   lter .  .  .                                                                         87
      7.6.3                   Dif  culty adjustment                                                                             87
      7.6.4                   nBits conversion                                                                                  88
      7.6.5                   De  nition of Work  .  .  .                                                                       88
7.7                                                                         Calculation of Block Subsidy and Founders’ Reward   89
7.8                           Payment of Founders’ Reward                                                                       89
7.9                           Changes to the Script System  .  .  .                                                             91
4




7.10                                   Bitcoin Improvement Proposals                               91
8                                      Differences from the Zerocash paper                         91
8.1    Transaction Structure .  .  .                                                               91
8.2    Memo Fields  .  .  .                                                                        91
8.3                                    Uni  cation of Mints and Pours                              92
8.4    Faerie Gold attack and   x                                                                  92
8.5                                    Internal hash collision attack and   x .                    93
8.6                                    Changes to PRF inputs and truncation .  .                   94
8.7                                    In-band secret distribution                                 95
8.8                                    Omission in Zerocash security proof                         96
8.9    Miscellaneous                                                                               97
9      Acknowledgements                                                                            97
       10  Change History                                                                          98
11     References                                                                                  113
       Appendices                                                                                  121
A      Circuit Design                                                                              121
A.1                                    Quadratic Constraint Programs  .  .  .                      121
A.2    Elliptic curve background                                                                   121
A.3    Circuit Components                                                                          122
       A.3.1                           Operations on individual bits                               123
       A.3.1.1                         Boolean constraints .                                       123
       A.3.1.2                         Conditional equality                                        123
       A.3.1.3                         Selection constraints                                       123
       A.3.1.4                         Nonzero constraints                                         123
       A.3.1.5                         Exclusive-or constraints                                    123
       A.3.2                           Operations on multiple bits .  .  .                         124
       A.3.2.1                         [Un]packing modulo rS  .  .                                 124
       A.3.2.2                         Range check  .  .  .                                        124
       A.3.3                           Elliptic curve operations                                   126
       A.3.3.1                         Checking that af  ne Edwards coordinates are on the curve   126
       A.3.3.2                         Edwards [de]compression and validation                      126
       A.3.3.3                         Edwards ↔ Montgomery conversion  .  .  .                    127
       A.3.3.4                         Af  ne-Montgomery arithmetic .  .  .                        128
       A.3.3.5                         Af  ne-Edwards arithmetic                                   128
       A.3.3.6                         Af  ne-Edwards nonsmall-order check .  .  .                 129
       A.3.3.7                         Fixed-base af  ne-Edwards scalar multiplication             130
       A.3.3.8                         Variable-base af  ne-Edwards scalar multiplication          131
       A.3.3.9                         Pedersen hash  .  .  .                                      131
       A.3.3.10                        Mixing Pedersen hash                                        134
       A.3.4                           Merkle path check                                           134
       A.3.5                           Windowed Pedersen Commitment .  .  .                        134
5




A.3.6                        Homomorphic Pedersen Commitment      135
A.3.7                        BLAKE2s hashes .  .  .               135
A.4                          The Sapling Spend circuit            138
A.5                          The Sapling Output circuit .  .  .   140
B   Batching Optimizations                                        141
B.1                          RedDSA batch veri  cation  .  .  .   141
B.2                          Groth16 batch veri  cation           142
6




1                                                                                                                      Introduction
Zcash is an implementation of the Decentralized Anonymous Payment scheme Zerocash [BCGGMTV2014], with
security   xes and improvements to performance and functionality. It bridges the existing transparent payment
scheme used by Bitcoin [Nakamoto2008] with a shielded payment scheme secured by zero-knowledge succinct
non-interactive arguments of knowledge (zk-SNARKs ).
Changes from the original Zerocash are explained in § 8 ‘Differences from the Zerocash paper’ on p. 91, and high-
lighted in magenta throughout the document. Changes speci  c to the Overwinter upgrade (which are also changes
from Zerocash) are highlighted in blue. Changes speci  c to the Sapling upgrade following Overwinter (which are
also changes from Zerocash) are highlighted in green. The name Sprout is used for the Zcash protocol prior to
Sapling (both before and after Overwinter).
Technical terms for concepts that play an important rôle in Zcash are written in slanted text . Italics are used for
emphasis and for references between sections of the document.
The key words MUST, MUST NOT, SHOULD, SHOULD NOT, MAY, and RECOMMENDED in this document are to
be interpreted as described in [RFC-2119] when they appear in ALL CAPS. These words may also appear in this
document in lower case as plain English words, absent their normative meanings.
This speci  cation is structured as follows:
•  Notation — de  nitions of notation used throughout the document;
•  Concepts — the principal abstractions needed to understand the protocol;
•  Abstract Protocol — a high-level description of the protocol in terms of ideal cryptographic components;
•  Concrete Protocol — how the functions and encodings of the abstract protocol are instantiated;
•  Network Upgrades — the strategy for upgrading to Overwinter and then Sapling;
•  Consensus Changes from Bitcoin — how Zcash differs from Bitcoin at the consensus layer, including the
Proof of Work;
•  Differences from the Zerocash protocol — a summary of changes from the protocol in [BCGGMTV2014].
•  Appendix: Circuit Design — details of how the Sapling circuit is de  ned as a quadratic constraint program.
•  Appendix: Batching Optimizations — improvements to the ef  ciency of verifying multiple signatures and
proofs.
1.1                                                                                                                    Caution
Zcash security depends on consensus. Should a program interacting with the Zcash network diverge from con-
sensus, its security will be weakened or destroyed. The cause of the divergence doesn’t matter: it could be a bug
in your program, it could be an error in this documentation which you implemented as described, or it could be
that you do everything right but other software on the network behaves unexpectedly. The speci  c cause will not
matter to the users of your software whose wealth is lost.
Having said that, a speci  cation of  intended behaviour is essential for security analysis, understanding of the
protocol, and maintenance of Zcash and related software. If you   nd any mistake in this speci  cation, please   le
an issue at https://github.com/zcash/zips/issues or contact <security@z.cash>.
1.2                                                                                                                    High-level Overview
The following overview is intended to give a concise summary of the ideas behind the protocol, for an audience
already familiar with block chain-based cryptocurrencies such as Bitcoin. It is imprecise in some aspects and is
not part of the normative protocol speci  cation. This overview applies to both Sprout and Sapling, differences in
the cryptographic constructions used notwithstanding.
7




Value in Zcash is either transparent or shielded . Transfers of transparent value work essentially as in Bitcoin and
have the same privacy properties. Shielded value is carried by notes 2, which specify an amount and  (indirectly) a
shielded payment address , which is a destination to which notes can be sent. As in Bitcoin, this is associated with
a private key that can be used to spend notes sent to the address; in Zcash this is called a spending key .
To each note there is cryptographically associated a note commitment . Once the transaction creating the note has
been mined, it is associated with a  xed note position in a tree of note commitments , and with a nulli  er 2 unique
to that note . Computing the nulli  er requires the associated private spending key (or the nulli  er deriving key for
Sapling notes ). It is infeasible to correlate the note commitment or note position with the corresponding nulli  er
without knowledge of at least this key. An unspent valid note , at a given point on the block chain, is one for which
the note commitment has been publically revealed on the block chain prior to that point, but the nulli  er has not.
A transaction can contain transparent inputs, outputs, and scripts, which all work as in Bitcoin [Bitcoin-Protocol].
It also includes JoinSplit descriptions , Spend descriptions , and Output descriptions .  Together these describe
shielded transfers which take in shielded input notes , and/or produce shielded output notes . (For Sprout, each
JoinSplit description handles up to two shielded inputs and up to two shielded outputs . For Sapling, each shielded
input or shielded output has its own description.) It is also possible for value to be transferred between the trans-
parent and shielded domains.
The nulli  ers of the input notes are revealed (preventing them from being spent again) and the commitments of the
output notes are revealed (allowing them to be spent in future). A transaction also includes computationally sound
zk-SNARK proofs and signatures, which prove that all of the following hold except with insigni  cant probability:
For each shielded input ,
•                                                                                                                         [Sapling onward] there is a revealed value commitment to the same value as the input note ;
•  if the value is nonzero, some revealed note commitment exists for this note ;
•  the prover knew the proof authorizing key of the note ;
•  the nulli  er and note commitment are computed correctly.
and for each shielded output ,
•                                                                                                                         [Sapling onward] there is a revealed value commitment to the same value as the output note ;
•  the note commitment is computed correctly;
•  it is infeasible to cause the nulli  er of the output note to collide with the nulli  er of any other note .
For Sprout, the JoinSplit statement also includes an explicit balance check. For Sapling, the value commitments
corresponding to the inputs and outputs are checked to balance (together with any net transparent input or output)
outside the zk-SNARK .
In addition, various measures (differing between Sprout and Sapling) are used to ensure that the transaction can-
not be modi  ed by a party not authorized to do so.
Outside the zk-SNARK , it is checked that the nulli  ers for the input notes had not already been revealed (i.e. they
had not already been spent).
A shielded payment address includes a transmission key  for a “key-private ” asymmetric encryption scheme.
Key-private means that ciphertexts do not reveal information about which key they were encrypted to, except
to a holder of the corresponding private key, which in this context is called the receiving key . This facility is used
to communicate encrypted output notes on the block chain to their intended recipient, who can use the receiving
key to scan the block chain for notes addressed to them and then decrypt those notes .
In Sapling, for each spending key there is a full viewing key that allows recognizing both incoming and outgoing
notes without having spend authority. This is implemented by an additional ciphertext in each Output description.
2 In Zerocash [BCGGMTV2014], notes were called “coins ”, and nulli  ers were called “serial numbers ”.
8




The basis of the privacy properties of Zcash is that when a note is spent, the spender only proves that some
commitment for it had been revealed, without revealing which one.  This implies that a spent note cannot be
linked to the transaction in which it was created. That is, from an adversary’s point of view the set of possibilities
for a given note input to a transaction—its note traceability set — includes all previous notes that the adversary
does not control or know to have been spent. 3  This contrasts with other proposals for private payment systems,
such as CoinJoin [Bitcoin-CoinJoin] or CryptoNote [vanSaberh2014], that are based on mixing of a limited number
of transactions and that therefore have smaller note traceability sets .
The nulli  ers are necessary to prevent double-spending: each note on the block chain only has one valid nul-
li  er , and so attempting to spend a note twice would reveal the nulli  er twice, which would cause the second
transaction to be rejected.
2                                                                                                                                              Notation
B means the type of bit values, i.e. {0, 1}. BY means the type of byte values, i.e. {0 .. 255}.
N means the type of nonnegative integers. N+ means the type of positive integers. Z means the type of integers.
Q means the type of rationals.
x  ◦ T is used to specify that x has type T . A cartesian product type is denoted by S × T , and a function type by
S → T . An argument to a function can determine other argument or result types.
R   T .  The domain of a randomized algorithm may be (),
R   T and s ◦ S, sampling a variable x ◦ T from the output of
f applied to s is denoted by x ←R  f (s).
Initial arguments to a function or randomized algorithm may be written as subscripts, e.g. if x  ◦ X , y  ◦ Y , and
f  ◦ X × Y  → Z , then an invocation of f (x, y) can also be written fx (y).
{x ◦ T | px} means the subset of x from T for which px (a boolean expression depending on x) holds.
T  ⊆ U indicates that T is an inclusive subset or subtype of U . S ∪ T means the set union of S and T .
S ∩ T means the set intersection of S and T , i.e. {x ◦ S | x ∈ T }.
S \ T means the set difference obtained by removing elements in T from S, i.e. {x ◦ S | x < T }.
x ◦ T  → ex  ◦ U means the function of type T  → U mapping formal parameter x to ex  (an expression depending
on x). The types T and U are always explicit.
x ◦ T  →,y ex  ◦ U means x ◦ T  → ex  ◦ U ∪ {y} restricted to the domain {x ◦ T | ex  , y} and range U .
P(T ) means the powerset of T .
T [ℓ], where T is a type and ℓ is an integer, means the type of sequences of length ℓ with elements in T . For example,
B[ℓ] means the set of sequences of ℓ bits, and BY[k] means the set of sequences of k bytes.
BY[N] means the type of byte sequences of arbitrary length.
length(S ) means the length of (number of elements in) S.
truncatek (S ) means the sequence formed from the   rst k elements of S.
0x followed by a string of monospace hexadecimal digits means the corresponding integer converted from hex-
adecimal. [0x00]ℓ means the sequence of ℓ zero bytes.
“...” means the given string represented as a sequence of bytes in US-ASCII. For example, “abc” represents the
byte sequence [0x61, 0x62, 0x63].
3 We make this claim only for fully shielded transactions .  It does not exclude the possibility that an adversary may use data present in
the cleartext of a transaction such as the number of inputs and outputs, or metadata-based heuristics such as timing, to make proba-
bilistic inferences about transaction linkage. For consequences of this in the case of partially shielded transactions , see [Peterson2017],
[Quesnelle2017], and [KYMM2018].
9




[0]ℓ means the sequence of ℓ zero bits. [1]ℓ means the sequence of ℓ one bits.
a..b, used as a subscript, means the sequence of values with indices a through b inclusive. For example, apk,
1..Nnew
means the sequence [apk,
1, apk,2, ... apk,Nnew ]. (For consistency with the notation in [BCGGMTV2014] and in [BK2016],
this speci  cation uses 1-based indexing and inclusive ranges, notwithstanding the compelling arguments to the
contrary made in [EWD-831].)
{a .. b} means the set or type of integers from a through b inclusive.
[[ f (x) for x from a up to b ]] means the sequence formed by evaluating f on each integer from a to b inclusive, in
ascending order. Similarly, [[ f (x) for x from a down to b ]] means the sequence formed by evaluating f on each
integer from a to b inclusive, in descending order.
a || b means the concatenation of sequences a then b.
concatB (S ) means the sequence of bits obtained by concatenating the elements of S viewed as bit sequences. If
the elements of S are byte sequences, they are converted to bit sequences with the most significant bit of each
byte   rst.
sorted(S ) means the sequence formed by sorting the elements of S.
Fn means the   nite   eld with n elements, and Fn means its group under multiplication (which excludes 0).
Where there is a need to make the distinction, we denote the unique representative of a ◦ Fn in the range {0 .. n − 1}
(or the unique representative of a ◦ Fn in the range {1 .. n − 1}) as a mod n. Conversely, we denote the element of Fn
corresponding to an integer k ◦ Z as k  (mod n). We also use the latter notation in the context of an equality k = k′
(mod n) as shorthand for k mod n = k′ mod n, and similarly k , k′  (mod n) as shorthand for k mod n , k′ mod n.
(When referring to constants such as 0 and 1 it is usually not necessary to make the distinction between   eld
elements and their representatives, since the meaning is normally clear from context.)
Fn[z] means the ring of polynomials over z with coef  cients in Fn.
a + b means the sum of a and b. This may refer to addition of integers, rationals,   nite   eld elements, or group
elements (see § 4.1.8 ‘Represented Group’ on p. 24) according to context.
−a means the value of the appropriate integer, rational,   nite   eld, or group type such that (−a) + a = 0 (or when
a is an element of a group G, (−a) + a = OG ), and a − b means a + (−b).
a · b means the product of multiplying a and b. This may refer to multiplication of integers, rationals, or  nite  eld
elements according to context (this notation is not used for group elements).
a/b, also written a
b , means the value of the appropriate integer, rational, or   nite   eld type such that (a/b) · b = a.
a mod q, for a  ◦  N and q  ◦ N+, means the remainder on dividing a by q.  (This usage does not con  ict with the
notation above for the unique representative of a   eld element.)
a ⊕ b means the bitwise-exclusive-or of a and b, and a î b means the bitwise-and of a and b. These are de  ned on
integers or (equal-length) bit sequences according to context.
∑                                                                                                                        ∏                                                                                                ⊕
ai means the sum of a1..N .                                                                                                                                                             ai means the product of a1..N .              ai means the bitwise exclusive-or of a1..N .
i=1                                                                                                                      i=1                                                                                              i=1
                                                                                                                                                                                                                          ∑          ∏                                              ⊕
                                                                                                                         When N = 0 these yield the appropriate neutral element, i.e.                                     ai  = 0,   ai  = 1, and                                   ai  = 0 or the all-zero bit
                                                                                                                         sequence of the appropriate length given by the type of a.                                       i=1        i=1                                            i=1
√a, where a ◦ F                                                                                                          }) square root of a in Fq . It is only used in cases where
2
the square root must exist.
b ? x : y means x when b = 1, or y when b = 0.
ab, for a an integer or   nite   eld element and b ◦ Z, means the result of raising a to the exponent b, i.e.

∏b

                                                                                                                         a,  if b ≥ 0
                                                                                                                         i=1
ab  :=
∏−                                                                                                                       b
                                                                                                                        1
otherwise.
i=1                                                                                                                      a ,
10




The [k] P notation for scalar multiplication in a group is de  ned in § 4.1.8 ‘Represented Group’ on p. 24.
The convention of af  xing ⋆ to a variable name is used for variables that denote bit-sequence representations of
group elements.
The binary relations <, ≤, =, ≥, and > have their conventional meanings on integers and rationals, and are de  ned
lexicographically on sequences of integers.
floor(x) means the largest integer ≤ x. ceiling (x) means the smallest integer ≥ x.
bitlength(x), for x ◦ N, means the smallest integer ℓ such that 2ℓ  > x.
The symbol ⊥ is used to indicate unavailable information, or a failed decryption or validity check.
The following integer constants will be instantiated in § 5.3 ‘Constants’ on p. 50:
MerkleDepthSprout, MerkleDepthSapling , Nold, Nnew , ℓvalue, ℓMerkleSprout, ℓMerkleSapling , ℓhSig , ℓPRFSprout, ℓPRFexpand,
, ℓϕ, ℓsk , ℓd, ℓivk , ℓovk , ℓscalar , MAX_MONEY, SlowStartInterval, HalvingInterval,
ℓPRFnfSapling , ℓrcm, ℓSeed, ℓa                                                                                                     sk
MaxBlockSubsidy, NumFounderAddresses, PoWLimit, PoWAveragingWindow, PoWMedianBlockSpan,
PoWDampingFactor, and PoWTargetSpacing.
The bit sequence constants UncommittedSprout  ◦ B[ℓMerkleSprout ] and UncommittedSapling  ◦ B[ℓMerkleSapling ], and rational con-
stants FoundersFraction, PoWMaxAdjustDown, and PoWMaxAdjustUp will also be de  ned in that section.
3                                                                                                                                   Concepts
3.1                                                                                                                                 Payment Addresses and Keys
Users who wish to receive payments under this scheme   rst generate a random spending key . In Sprout this is
called ask and in Sapling it is called sk.
The following diagram depicts the relations between key components in Sprout and Sapling. Arrows point from a
component to any other component(s) that can be derived from it. Double lines indicate that the same component
is used in multiple abstractions.
11




[Sprout ]  The receiving key skenc, the incoming viewing key ivk = (apk , skenc ), and the shielded payment address
addrpk  = (apk , pkenc ) are derived from ask , as described in § 4.2.1 ‘Sprout Key Components’ on p. 27.
[Sapling onward]  The spend authorizing key ask, proof authorizing key  (ak, nsk), full viewing key  (ak, nk, ovk),
incoming viewing key ivk, and each diversi  ed payment address addrd  = (d, pkd ) are derived from sk, as described
in § 4.2.2 ‘Sapling Key Components’ on p. 27.
The composition of shielded payment addresses , incoming viewing keys , full viewing keys , and spending keys is
a cryptographic protocol detail that should not normally be exposed to users. However, user-visible operations
should be provided to obtain a shielded payment address or incoming viewing key or full viewing key from a
spending key .
Users can accept payment from multiple parties with a single shielded payment address and the fact that these
payments are destined to the same payee is not revealed on the block chain, even to the paying parties. However
if two parties collude to compare a shielded payment address they can trivially determine they are the same. In
the case that a payee wishes to prevent this they should create a distinct shielded payment address for each payer.
[Sapling onward]  Sapling provides a mechanism to allow the ef  cient creation of diversi  ed payment addresses
with the same spending authority.  A group of such addresses shares the same full viewing key  and incoming
viewing key , and so creating as many unlinkable addresses as needed does not increase the cost of scanning the
block chain for relevant transactions .
Note:   It is conventional in cryptography to refer to the key used to encrypt a message in an asymmetric encryp-
tion scheme as the “public key ”. However, the public key used as the transmission key component of an address
(pkenc or pkd) need not be publically distributed; it has the same distribution as the shielded payment address itself.
As mentioned above, limiting the distribution of the shielded payment address is important for some use cases.
This also helps to reduce reliance of the overall protocol on the security of the cryptosystem used for note encryp-
tion (see § 4.16 ‘In-band secret distribution (Sprout)’ on p. 44 and § 4.17 ‘In-band secret distribution (Sapling)’
on p. 45), since an adversary would have to know pkenc or some pkd in order to exploit a hypothetical weakness in
that cryptosystem.
3.2                                                                                                                       Notes
A note (denoted n) can be a Sprout note or a Sapling note . In either case it represents that a value v is spendable
by the recipient who holds the spending key corresponding to a given shielded payment address .
Let MAX_MONEY, ℓPRFSprout, ℓPRFnfSapling , and ℓd be as de  ned in § 5.3 ‘Constants’ on p. 50.
Let NoteCommitSprout be as de  ned in § 5.4.7.1 ‘Sprout Note Commitments’ on p. 63.
Let NoteCommitSapling be as de  ned in § 5.4.7.2 ‘Windowed Pedersen commitments’ on p. 64.
Let KASapling be as de  ned in § 5.4.4.3 ‘Sapling Key Agreement’ on p. 59.
A Sprout note is a tuple (apk , v, ρ, rcm), where:
•  apk  ◦   B[ℓPRFSprout ] is the paying key of the recipient’s shielded payment address ;
•  v ◦   {0 .. MAX_MONEY} is an integer representing the value of the note in zatoshi (1 ZEC = 108 zatoshi );
•  ρ ◦   B[ℓPRFSprout ] is used as input to PRFaf                                                                         to derive the nulli  er of the note ;
sk
•  rcm  ◦  NoteCommitSprout.Trapdoor is a random commitment trapdoor as de  ned in § 4.1.7 ‘Commitment’ on
p. 23.
Let NoteSprout be the type of a Sprout note , i.e.
NoteSprout  := B[ℓPRFSprout ] × {0 .. MAX_MONEY} × B[ℓPRFSprout ] × NoteCommitSprout.Trapdoor.
12




A Sapling note is a tuple (d, pkd, v, rcm), where:
•  d ◦   B[ℓd ] is the diversi  er of the recipient’s shielded payment address ;
•  pkd  ◦  KASapling .PublicPrimeOrder is the diversi  ed transmission key of the recipient’s shielded payment ad-
dress ;
•  v ◦   {0 .. MAX_MONEY} is an integer representing the value of the note in zatoshi ;
•  rcm  ◦  NoteCommitSapling .Trapdoor is a random commitment trapdoor as de  ned in § 4.1.7 ‘Commitment’ on
p. 23.
Let NoteSapling be the type of a Sapling note , i.e.
NoteSapling  := B[ℓd ] × KASapling .PublicPrimeOrder × {0 .. MAX_MONEY} × NoteCommitSapling .Trapdoor.
Creation of new notes is described in § 4.6 ‘Sending Notes’ on p. 32. When notes are sent, only a commitment
(see § 4.1.7 ‘Commitment’ on p. 23) to the above values is disclosed publically, and added to a data structure called
the note commitment tree . This allows the value and recipient to be kept private, while the commitment is used
by the zero-knowledge proof  when the note is spent, to check that it exists on the block chain.
A Sprout note commitment on a note n = (apk , v, ρ, rcm) is computed as
cm                                                                                                                           (apk , v, ρ),
where NoteCommitSprout is instantiated in § 5.4.7.1 ‘Sprout Note Commitments’ on p. 63.
Let DiversifyHash be as de  ned in § 5.4.1.6 ‘DiversifyHash Hash Function’ on p. 53.
A Sapling note commitment on a note n = (d, pkd, v, rcm) is computed as
gd  := DiversifyHash(d)
{
⊥,                                                                                                                           if gd  = ⊥
NoteCommitmentSapling (n ) :=
cm                                                                                                                           (reprJ (gd ), reprJ (pkd ), v),  otherwise.
where NoteCommitSapling is instantiated in § 5.4.7.2 ‘Windowed Pedersen commitments’ on p. 64.
Notice that the above de  nition of a Sapling note does not have a ρ  eld. There is in fact a ρ value associated with
each Sapling note , but this only be computed once its position in the note commitment tree is known (see § 3.4
‘Transactions and Treestates’ on p. 14 and § 3.7 ‘Note Commitment Trees’ on p. 16). We refer to the combination
of a note and its note position pos, as a positioned note .
For a positioned note , we can compute the value ρ as described in § 4.14 ‘Note Commitments and Nullifiers’ on
p. 40.
A nulli  er (denoted nf ) is derived from the ρ value of a note and the recipient’s spending key ask or nulli  er deriving
key nk.  This computation uses a Pseudo Random Function (see § 4.1.2 ‘Pseudo Random Functions’ on p. 18), as
described in § 4.14 ‘Note Commitments and Nullifiers’ on p. 40.
A note is spent by proving knowledge of (ρ, ask ) or (ρ, ak, nsk) in zero knowledge while publically disclosing its
nulli  er nf , allowing nf to be used to prevent double-spending.  In the case of Sapling, a spend authorization
signature is also required, in order to demonstrate knowledge of ask.
3.2.1                                                                                                                        Note Plaintexts and Memo Fields
Transmitted notes are stored on the block chain in encrypted form, together with a representation of the note
commitment cm.
The note plaintexts in each JoinSplit description are encrypted to the respective transmission keys pkenc
,1..Nnew .
13




Each Sprout note plaintext (denoted np) consists of
(v ◦   {0 .. 2ℓvalue −1}, ρ ◦   B[ℓPRFSprout ], rcm ◦   NoteCommitSprout.Trapdoor, memo ◦ BY[512] ).
[Sapling onward]  The note plaintext in each Output description is encrypted to the diversi  ed payment address
(d, pkd ).
Each Sapling note plaintext (denoted np) consists of
(d ◦   B[ℓd ], v ◦   {0 .. 2ℓvalue −1}, rcm ◦   BY[32], memo ◦ BY[512] ).
memo represents a 512-byte memo   eld associated with this note . The usage of the memo   eld is by agreement
between the sender and recipient of the note .
Other   elds are as de  ned in § 3.2 ‘Notes’ on p. 12.
Encodings are given in § 5.5 ‘Encodings of Note Plaintexts and Memo Fields’ on p. 72. The result of encryption
forms part of a transmitted note(s) ciphertext . For further details, see § 4.16 ‘In-band secret distribution (Sprout)’
on p. 44 and § 4.17 ‘In-band secret distribution (Sapling)’ on p. 45.
3.3                                                                                                                       The Block Chain
At a given point in time, each full validator is aware of a set of candidate blocks . These form a tree rooted at the
genesis block , where each node in the tree refers to its parent via the hashPrevBlock block header   eld (see § 7.5
‘Block Header’ on p. 84).
A path from the root toward the leaves of the tree consisting of a sequence of one or more valid blocks consistent
with consensus rules, is called a valid block chain.
Each block in a block chain has a block height . The block height of the genesis block is 0, and the block height of
each subsequent block in the block chain increments by 1.
In order to choose the best valid block chain in its view of the overall block tree, a node sums the work, as de  ned
in § 7.6.5 ‘Definition of Work’ on p. 88, of all blocks in each valid block chain, and considers the valid block chain
with greatest total work to be best. To break ties between leaf blocks , a node will prefer the block that it received
rst.
The consensus protocol is designed to ensure that for any given block height , the vast majority of nodes should
eventually agree on their best valid block chain up to that height.
3.4                                                                                                                       Transactions and Treestates
Each block contains one or more transactions .
Transparent inputs to a transaction insert value into a transparent value pool associated with the transaction, and
transparent outputs remove value from this pool.  As in Bitcoin, the remaining value in the pool is available to
miners as a fee.
Consensus rule:   The remaining value in the transparent value pool MUST be nonnegative.
To each transaction there are associated initial treestates for Sprout and for Sapling. Each treestate consists of:
•  a note commitment tree (§ 3.7 ‘Note Commitment Trees’ on p. 16);
•  a nulli  er set (§ 3.8 ‘Nullifier Sets’ on p. 17).
Validation state associated with transparent transfers , such as the UTXO (Unspent Transaction Output) set, is not
described in this document; it is used in essentially the same way as in Bitcoin.
An anchor is a Merkle tree root of a note commitment tree (either the Sprout tree or the Sapling tree). It uniquely
identi  es a note commitment tree state given the assumed security properties of the Merkle tree’s hash function.
Since the nulli  er set is always updated together with the note commitment tree , this also identi  es a particular
state of the associated nulli  er set .
14




In a given block chain, for each of Sprout and Sapling, treestates are chained as follows:
•  The input treestate of the   rst block is the empty treestate .
•  The input treestate of the  rst transaction of a block is the  nal treestate of the immediately preceding block .
•  The input treestate of each subsequent transaction in a block is the output treestate of the immediately
preceding transaction.
•  The   nal treestate of a block is the output treestate of its last transaction.
JoinSplit descriptions also have interstitial input and output treestates for Sprout, explained in the following sec-
tion. There is no equivalent of interstitial treestates for Sapling.
3.5                                                                                                                      JoinSplit Transfers and Descriptions
A JoinSplit description is data included in a transaction that describes a JoinSplit transfer , i.e. a shielded value
transfer.  In Sprout, this kind of value transfer was the primary Zcash-speci  c operation performed by transac-
tions .
A JoinSplit transfer spends Nold notes nold
1..Nold  and transparent input vpudb, and creates Nnew notes n1.w.Nnew  and trans-
parent output vpub . It is associated with a JoinSplit statement instance (§ 4.15.1 ‘JoinSplit Statement (Sprout)’ on
p. 41), for which it provides a zk-SNARK proof .
Each transaction has a sequence of JoinSplit descriptions .
The total vpub value adds to, and the total vpudb value subtracts from the transparent value pool of the containing
transaction.
The anchor of each JoinSplit description in a transaction refers to a Sprout treestate .
For each of the Nold shielded inputs , a nulli  er is revealed. This allows detection of double-spends as described
in § 3.8 ‘Nullifier Sets’ on p. 17.
For each JoinSplit description in a transaction, an interstitial output treestate is constructed which adds the note
commitments and nulli  ers speci  ed in that JoinSplit description to the input treestate referred to by its anchor .
This interstitial output treestate is available for use as the anchor of subsequent JoinSplit descriptions in the same
transaction.  In general, therefore, the set of interstitial treestates associated with a transaction forms a tree in
which the parent of each node is determined by its anchor .
Interstitial treestates are necessary because when a transaction is constructed, it is not known where it will even-
tually appear in a mined block . Therefore the anchors that it uses must be independent of its eventual position.
Consensus rules:
•  The input and output values of each JoinSplit transfer MUST balance exactly.
•  For the   rst JoinSplit description of a transaction, the anchor MUST be the output Sprout treestate of a
previous block .
•  The anchor of each JoinSplit description in a transaction MUST refer to either some earlier block ’s   nal
Sprout treestate , or to the interstitial output treestate of any prior JoinSplit description in the same transac-
tion.
3.6                                                                                                                      Spend Transfers, Output Transfers, and their Descriptions
JoinSplit transfers are not used for Sapling notes . Instead, there is a separate Spend transfer for each shielded
input , and a separate Output transfer for each shielded output .
Spend descriptions and Output descriptions are data included in a transaction that describe Spend transfers and
Output transfers , respectively.
15




A Spend transfer spends a note nold. Its Spend description includes a Pedersen value commitment to the value
of the note . It is associated with an instance of a Spend statement (§ 4.15.2 ‘Spend Statement (Sapling)’ on p. 42)
for which it provides a zk-SNARK proof .
An Output transfer creates a note nnew . Similarly, its Output description includes a Pedersen value commitment
to the note value. It is associated with an instance of an Output statement (§ 4.15.3 ‘Output Statement (Sapling)’
on p. 43) for which it provides a zk-SNARK proof .
Each transaction has a sequence of Spend descriptions and a sequence of Output descriptions .
To ensure balance, we use a homomorphic property of Pedersen commitments that allows them to be added and
subtracted, as elliptic curve points (§ 5.4.7.3 ‘Homomorphic Pedersen commitments’ on p. 64). The result of adding
two Pedersen value commitments , committing to values v1  and v2, is a new Pedersen value commitment that
commits to v1 + v2. Subtraction works similarly.
Therefore, balance can be enforced by adding all of the value commitments for shielded inputs , subtracting all
of the value commitments for shielded outputs , and proving by use of a binding signature (as described in § 4.12
‘Balance and Binding Signature (Sapling)’ on p. 37) that the result commits to a value consistent with the net
transparent value change. This approach allows all of the zk-SNARK statements to be independent of each other,
potentially increasing opportunities for precomputation.
A Spend description includes an anchor , which refers to the output Sapling treestate of a previous block . It also
reveals a nulli  er , which allows detection of double-spends as described in § 3.8 ‘Nullifier Sets’ on p. 17.
Non-normative note:   Interstitial treestates are not necessary for Sapling, because a Spend transfer in a given
transaction cannot spend any of the shielded outputs of the same transaction. This is not an onerous restriction
because, unlike Sprout where each JoinSplit transfer must balance individually, in Sapling it is only necessary for
the whole transaction to balance.
Consensus rules:
•  The transaction MUST balance as speci  ed in § 4.12 ‘Balance and Binding Signature (Sapling)’ on p. 37.
•  The anchor of each Spend description MUST refer to some earlier block ’s   nal Sapling treestate .
3.7                                                                                                                       Note Commitment Trees
A note commitment tree is an incremental Merkle tree of  xed depth used to store note commitments that Join-
Split transfers or Spend transfers produce. Just as the unspent transaction output set (UTXO set) used in Bitcoin,
it is used to express the existence of value and the capability to spend it. However, unlike the UTXO set, it is not
the job of this tree to protect against double-spending, as it is append-only.
A root of a note commitment tree is associated with each treestate (§ 3.4 ‘Transactions and Treestates’ on p. 14).
Each node in the incremental Merkle tree is associated with a hash value of size ℓMerkleSprout  or ℓMerkleSapling bits.
The layer numbered h, counting from layer 0 at the root , has 2h nodes with indices 0 to 2h − 1 inclusive. The hash
value associated with the node at index i in layer h is denoted Mi.
The index of a note ’s commitment at the leafmost layer (MerkleDepthSprout,Sapling ) is called its note position.
16




3.8                                                                                                                                           Nulli  er Sets
Each full validator maintains a nulli  er set logically associated with each treestate . As valid transactions containing
JoinSplit transfers or Spend transfers are processed, the nulli  ers revealed in JoinSplit descriptions and Spend
descriptions are inserted into the nulli  er set associated with the new treestate .  Nulli  ers are enforced to be
unique within a valid block chain, in order to prevent double-spends.
Consensus rule:   A nulli  er MUST NOT repeat either within a transaction, or across transactions in a valid block
chain. Sprout and Sapling nulli  ers are considered disjoint, even if they have the same bit pattern.
3.9                                                                                                                                           Block Subsidy and Founders’ Reward
Like Bitcoin, Zcash creates currency when blocks are mined. The value created on mining a block is called the
block subsidy . It is composed of a miner subsidy and a Founders’ Reward . As in Bitcoin, the miner of a block also
receives transaction fees .
The calculations of the block subsidy , miner subsidy , and Founders’ Reward depend on the block height , as
de  ned in § 3.3 ‘The Block Chain’ on p. 14.
These calculations are described in § 7.7 ‘Calculation of Block Subsidy and Founders’ Reward’ on p. 89.
3.10                                                                                                                                          Coinbase Transactions
                                                                                                                                              The   rst (and only the   rst) transaction in a block is a coinbase transaction, which collects and spends any miner
                                                                                                                                              subsidy and transaction fees paid by transactions included in this block . The coinbase transaction MUST also pay
                                                                                                                                              the Founders’ Reward as described in § 7.8 ‘Payment of Founders’ Reward’ on p. 89.
4                                                                                                                                             Abstract Protocol
4.1                                                                                                                                           Abstract Cryptographic Schemes
4.1.1                                                                                                                                         Hash Functions
Let MerkleDepthSprout, ℓMerkleSprout, MerkleDepthSapling , ℓMerkleSapling , ℓivk , ℓd, ℓSeed, ℓPRFSprout, ℓhSig , and Nold be as de  ned
in § 5.3 ‘Constants’ on p. 50.
Let J, J(r) , J(r)∗, rJ, and ℓJ be as de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68.
◦
The functions MerkleCRHSprout                                                                                                                 ◦                                                                                                                      {0 .. MerkleDepthSprout − 1} × B[ℓMerkleSprout ]  × B[ℓMerkleSprout ]   →  B[ℓMerkleSprout ]  and (for
Sapling), MerkleCRHSapling  ◦ {0 .. MerkleDepthSapling − 1} × B[ℓMerkleSapling ] × B[ℓMerkleSapling ]  → B[ℓMerkleSapling ]  are hash func-
tions used in § 4.8 ‘Merkle path validity’ on p. 34. MerkleCRHSapling is collision-resistant on all its arguments, and
MerkleCRHSprout is collision-resistant except on its  rst argument. Both of these functions are instantiated in § 5.4.1.3
‘Merkle Tree Hash Function’ on p. 52.
hSigCRH ◦ B[ℓSeed ] × B[ℓPRFSprout ][Nold ] × JoinSplitSig.Public → B[ℓhSig ] is a collision-resistant hash function used in § 4.3
‘JoinSplit Descriptions’ on p. 29. It is instantiated in § 5.4.1.4 ‘hSig Hash Function’ on p. 53.
EquihashGen  ◦  (n  ◦ N+ ) × N+  × BY[N]  × N+  → B[n] is another hash function, used in § 7.6.1 ‘Equihash’ on p. 86 to
generate input to the Equihash solver. The  rst two arguments, representing the Equihash parameters n and k, are
written subscripted. It is instantiated in § 5.4.1.9 ‘Equihash Generator’ on p. 57.
CRHivk  ◦ B[ℓJ ] ×B[ℓJ ]  → {0 .. 2ℓivk −1} is a collision-resistant hash function used in § 4.2.2 ‘Sapling Key Components’
on p. 27 to derive an incoming viewing key for a Sapling shielded payment address . It is also used in the Spend
statement  (§ 4.15.2 ‘Spend Statement (Sapling)’ on p. 42) to con  rm use of the correct keys for the note being
spent. It is instantiated in § 5.4.1.5 ‘CRHivk Hash Function’ on p. 53.
17




MixingPedersenHash ◦ J × {0 .. rJ − 1} → J is a hash function used in § 4.14 ‘Note Commitments and Nullifiers’ on
p. 40 to derive the unique ρ value for a Sapling note . It is also used in the Spend statement to con  rm use of the
correct ρ value as an input to nulli  er derivation. It is instantiated in § 5.4.1.8 ‘Mixing Pedersen Hash Function’ on
p. 56.
DiversifyHash  ◦ B[ℓd ]  → J(r)∗ is a hash function instantiated in § 5.4.1.6 ‘DiversifyHash Hash Function’ on p. 53, and
satisfying the Unlinkability security property described in that section. It is used to derive a diversi  ed base from
a diversi  er in § 4.2.2 ‘Sapling Key Components’ on p. 27.
4.1.2                                                                                                                                     Pseudo Random Functions
PRFx is a Pseudo Random Function keyed by x.
Let ℓask , ℓϕ, ℓhSig , ℓPRFSprout, ℓsk , ℓovk , ℓPRFexpand, ℓPRFnfSapling , Nold, and Nnew be as de  ned in § 5.3 ‘Constants’ on p. 50.
Let ℓJ and J(r) be as de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68.
Let Sym be as de  ned in § 5.4.3 ‘Authenticated One-Time Symmetric Encryption’ on p. 58.
For Sprout, four independent PRFx are needed:
                                                                                                                                          ◦                                                [ℓa      ]
PRFaddr                                                                                                                                   ◦     B                                          sk       × BY                                                                                                                                                                                                                                                                                                         → B[ℓPRFSprout ]
                                                                                                                                          ◦                                                [ℓa      ]
PRFnf                                                                                                                                     ◦     B                                          sk       × B[ℓPRFSprout ]                                                                                                                                                                                                                                                                                             → B[ℓPRFSprout ]
                                                                                                                                          ◦                                                [ℓa      ]
PRFpk                                                                                                                                     ◦     B                                          sk       × {1..Nold}                                                                                                               × B[ℓhSig ]                                                                                                                                                                        → B[ℓPRFSprout ]
                                                                                                                                          ◦                                                [ℓϕ ]
PRFρ                                                                                                                                      ◦     B                                                                      × {1..Nnew }  × B[ℓhSig ]                                                                                                                                                                                                                                                                 → B[ℓPRFSprout ]
                                                                                                                                                                                                                                                                                                                                                                                         These are used in § 4.15.1 ‘JoinSplit Statement (Sprout)’ on p. 41; PRFaddr is also used to derive a shielded payment
                                                                                                                                                                                                                                                   address from a spending key in § 4.2.1 ‘Sprout Key Components’ on p. 27.
                                                                                                                                          For Sapling, three additional PRFx are needed:
                                                                                                                                          ◦                                                [ℓsk ]
PRFexpand                                                                                                                                 ◦     B                                                   × BY[N]                                                                                                                                                                                                                                                                                                      → BY[ℓPRFexpand /8]
                                                                                                                                          ◦
PRFock                                                                                                                                    ◦     B                                                                                                                                                                             Y[ℓovk /8]  × BY[ℓJ /8] × BY[ℓJ /8] × BY[ℓJ /8]  → Sym.K
                                                                                                                                          ◦                                                (r)
PRFnfSapling                                                                                                                              ◦     J ⋆                                                 × B[ℓJ ]                                                                                                                                                                                                                                                                                                     → B[ℓPRFnfSapling ]
PRFexpand is used in § 4.2.2 ‘Sapling Key Components’ on p. 27.
PRFock is used in § 4.17 ‘In-band secret distribution (Sapling)’ on p. 45.
PRFnfSapling is used in § 4.15.2 ‘Spend Statement (Sapling)’ on p. 42.
All of these Pseudo Random Functions are instantiated in § 5.4.2 ‘Pseudo Random Functions’ on p. 57.
Security requirements:
•  Security de  nitions for Pseudo Random Functions are given in [BDJR2000, section 4].
•  In addition to being Pseudo Random Functions , it is required that PRFxf , PRFxddr , PRFx , and PRFxfSapling be
collision-resistant across all x — i.e.   nding (x, y)  ,  (x′, y′ ) such that PRFxf (y)  = PRFn′
x  (y′ ) should not be
feasible, and similarly for PRFaddr and PRFρ and PRFnfSapling .
Non-normative note:   PRFnf was called PRFsn in Zerocash [BCGGMTV2014].
18




4.1.3                                                                                                                         Authenticated One-Time Symmetric Encryption
Let Sym be an authenticated one-time symmetric encryption scheme with keyspace Sym.K, encrypting plaintexts
in Sym.P to produce ciphertexts in Sym.C.
Sym.Encrypt ◦ Sym.K × Sym.P → Sym.C is the encryption algorithm.
Sym.Decrypt  ◦  Sym.K × Sym.C  → Sym.P ∪ {⊥} is the decryption algorithm, such that for any K  ∈ Sym.K and
P ∈ Sym.P, Sym.DecryptK (Sym.EncryptK (P)) = P. ⊥ is used to represent the decryption of an invalid ciphertext.
Security requirement:   Sym must be one-time (INT-CTXT ∧ IND-CPA)-secure [BN2007]. “One-time ” here means
that an honest protocol participant will almost surely encrypt only one message with a given key; however, the ad-
versary may make many adaptive chosen ciphertext queries for a given key.
4.1.4                                                                                                                         Key Agreement
A key agreement scheme is a cryptographic protocol in which two parties agree a shared secret, each using their
private key and the other party’s public key.
A key agreement scheme KA de  nes a type of public keys KA.Public, a type of private keys KA.Private, and a type
of shared secrets KA.SharedSecret. Optionally, it also de  nes a type KA.PublicPrimeOrder ⊆ KA.Public.
Optional: Let KA.FormatPrivate ◦ B[ℓPRFSprout ]  → KA.Private be a function to convert a bit string of length ℓPRFSprout to
a KA private key.
Let KA.DerivePublic ◦ KA.Private × KA.Public → KA.Public be a function that derives the KA public key correspond-
ing to a given KA private key and base point.
Let KA.Agree ◦ KA.Private × KA.Public → KA.SharedSecret be the agreement function.
Optional: Let KA.Base ◦ KA.Public be a public base point.
Note:   The range of KA.DerivePublic may be a strict subset of KA.Public.
Security requirements:
•  KA.FormatPrivate must preserve suf  cient entropy from its input to be used as a secure KA private key.
•  The key agreement and the KDF de  ned in the next section must together satisfy a suitable adaptive security
assumption along the lines of [Bernstein2006, section 3] or [ABR1999, De  nition 3].
More precise formalization of these requirements is beyond the scope of this speci  cation.
4.1.5                                                                                                                         Key Derivation
A Key Derivation Function is de  ned for a particular key agreement scheme and authenticated one-time sym-
metric encryption scheme ; it takes the shared secret produced by the key agreement and additional arguments,
and derives a key suitable for the encryption scheme.
The inputs to the Key Derivation Function differ between the Sprout and Sapling KDFs:
KDFSprout takes as input an output index in {1..Nnew }, the value hSig , the shared Dif  e-Hellman secret sharedSecret,
the ephemeral public key epk, and the recipient’s public transmission key pkenc. It is suitable for use with KASprout
and derives keys for Sym.Encrypt.
KDFSprout  ◦ {1..Nnew } × B[ℓhSig ] × KASprout.SharedSecret × KASprout.Public × KASprout.Public → Sym.K
KDFSapling takes as input the shared Dif  e-Hellman secret sharedSecret and the ephemeral public key epk. (It does
not have inputs taking the place of the output index, hSig , or pkenc.) It is suitable for use with KASapling and derives
keys for Sym.Encrypt.
KDFSapling  ◦ KASapling .SharedSecret × KASapling .Public → Sym.K
19




Security requirements:
•  The asymmetric encryption scheme in § 4.16 ‘In-band secret distribution (Sprout)’ on p. 44, constructed
from KASprout, KDFSprout and Sym, is required to be IND-CCA2-secure and key-private .
•  The asymmetric encryption scheme in § 4.17 ‘In-band secret distribution (Sapling)’ on p. 45, constructed
from KASapling , KDFSapling and Sym, is required to be IND-CCA2-secure and key-private .
Key privacy is de  ned in [BBDP2001].
4.1.6                                                                                                                         Signature
A signature scheme Sig de  nes:
                                                                                                                              •  a type of signing keys Sig.Private;
                                                                                                                              •  a type of verifying keys Sig.Public;
                                                                                                                              •  a type of messages Sig.Message;
                                                                                                                              •  a type of signatures Sig.Signature;
                                                                                                                                                                                                                                               R   Sig.Private;
•  an injective verifying key derivation algorithm Sig.DerivePublic ◦ Sig.Private → Sig.Public;
R   Sig.Signature;
•  a verifying algorithm Sig.Verify ◦ Sig.Public × Sig.Message × Sig.Signature → B;
such that for any signing key sk ←R  Sig.GenPrivate() and corresponding verifying key vk = Sig.DerivePublic(sk), and
any m ◦ Sig.Message and s ◦ Sig.Signature ←R  Sig.Signsk (m), Sig.Verifyvk (m, s) = 1.
Zcash uses four signature schemes:
•  one used for signatures that can be veri  ed by script operations such as OP_CHECKSIG and OP_CHECKMULTISIG
as in Bitcoin;
•  one called JoinSplitSig (instantiated in § 5.4.5 ‘JoinSplit Signature’ on p. 60), which is used to sign transac-
tions that contain at least one JoinSplit description;
•                                                                                                                             [Sapling onward] one called SpendAuthSig (instantiated in § 5.4.6.1 ‘Spend Authorization Signature’ on p. 63)
which is used to sign authorizations of Spend transfers ;
•                                                                                                                             [Sapling onward] one called BindingSig (instantiated in § 5.4.6.2 ‘Binding Signature’ on p. 63), which is used
to enforce balance of Spend transfers and Output transfers , and to prevent their replay across transactions .
The following security property is needed for JoinSplitSig and BindingSig. Security requirements for SpendAuthSig
are de  ned in the next section, § 4.1.6.1 ‘Signature with Re-Randomizable Keys’ on p. 21. An additional require-
ment for BindingSig is de  ned in § 4.1.6.2 ‘Signature with Private Key to Public Key Homomorphism’ on p. 22.
Security requirement:   JoinSplitSig and BindingSig must be Strongly Unforgeable under (non-adaptive) Chosen
Message Attack (SU-CMA), as de  ned for example in [BDEHR2011, De  nition 6].4 This allows an adversary to obtain
signatures on chosen messages, and then requires it to be infeasible for the adversary to forge a previously unseen
valid (message, signature) pair without access to the signing key.
4 The scheme de  ned in that paper was attacked in [LM2017], but this has no impact on the applicability of the de  nition.
20




Non-normative notes:
•  We need separate signing key generation and verifying key derivation algorithms, rather than the more con-
R   Sig.Private × Sig.Public, to support the key
derivation in § 4.2.2 ‘Sapling Key Components’ on p. 27. This also simpli  es some aspects of the de  nitions
of signature schemes with additional features in § 4.1.6.1 ‘Signature with Re-Randomizable Keys’ on p. 21
and § 4.1.6.2 ‘Signature with Private Key to Public Key Homomorphism’ on p. 22.
•  A fresh signature key pair is generated for each transaction containing a JoinSplit description. Since each
key pair is only used for one signature (see § 4.10 ‘Non-malleability (Sprout)’ on p. 36), a one-time signature
scheme would suf  ce for JoinSplitSig. This is also the reason why only security against non-adaptive chosen
message attack is needed. In fact the instantiation of JoinSplitSig uses a scheme designed for security under
adaptive attack even when multiple signatures are signed under the same key.
•                                                                                                                     [Sapling onward] The same remarks as above apply to BindingSig, except that the key is derived from the
randomness of value commitments . This results in the same distribution as of freshly generated key pairs,
for each transaction containing Spend descriptions or Output descriptions .
•  SU-CMA security requires it to be infeasible for the adversary, not knowing the private key, to forge a distinct
signature on a previously seen message. That is, JoinSplit signatures and binding signatures are intended to
be nonmalleable in the sense of [BIP-62].
4.1.6.1                                                                                                               Signature with Re-Randomizable Keys
A signature scheme with re-randomizable keys Sig is a signature scheme that additionally de  nes:
•  a type of randomizers Sig.Random;
R   Sig.Random;
•  a private key randomization algorithm Sig.RandomizePrivate ◦ Sig.Random × Sig.Private → Sig.Private;
•  a public key randomization algorithm Sig.RandomizePublic ◦ Sig.Random × Sig.Public → Sig.Public;
•  a distinguished “identity” randomizer OSig.Random  ◦ Sig.Random
such that:
•  for any α ◦ Sig.Random, Sig.RandomizePrivateα  ◦ Sig.Private → Sig.Private is injective and easily invertible;
•  Sig.RandomizePrivateOSig.Random  is the identity function on Sig.Private.
•  for any sk ◦ Sig.Private,
Sig.RandomizePrivate(α, sk) : α ←R  Sig.GenRandom()
is identically distributed to Sig.GenPrivate().
•  for any sk ◦ Sig.Private and α ◦ Sig.Random,
Sig.RandomizePublic(α, Sig.DerivePublic(sk)) = Sig.DerivePublic(Sig.RandomizePrivate(α, sk)).
The following security requirement for such signature schemes is based on that given in [FKMSSS2016, section 3].
Note that we require Strong Unforgeability with Re-randomized Keys, not Existential Unforgeability with Re-
randomized Keys (the latter is called “Unforgeability under Re-randomized Keys” in [FKMSSS2016, De  nition 8]).
Unlike the case for JoinSplitSig, we require security under adaptive chosen message attack with multiple messages
signed using a given key. (Although each note uses a different re-randomized key pair, the same original key pair
can be re-randomized for multiple notes , and also it can happen that multiple transactions spending the same
note are revealed to an adversary.)
21




Security requirement:   Strong Unforgeability with Re-randomized Keys under adaptive Chosen Message At-
tack (SURK-CMA)
For any sk ◦ Sig.Private, let
Osk  ◦ Sig.Message × Sig.Random → Sig.Signature
be a signing oracle with state Q  ◦ P(Sig.Message × Sig.Signature) initialized to {} that records queried messages
and corresponding signatures.
Osk  := var Q ← {} in (m ◦ Sig.Message, α ◦ Sig.Random) →
let σ = Sig.SignSig.RandomizePrivate(α,sk) (m)
Q ← Q ∪ {(m, σ)}
return σ ◦ Sig.Signature.
For random sk ←R  Sig.GenPrivate() and vk = Sig.DerivePublic(sk), it must be infeasible for an adversary given vk and
a new instance of Osk to   nd (m′, σ′, α′ ) such that Sig.VerifySig.RandomizePublic(α′ ,vk) (m′, σ′ ) = 1 and (m′, σ′ ) < Osk .Q.
Non-normative notes:
•  The randomizer and key arguments to Sig.RandomizePrivate and Sig.RandomizePublic are swapped relative to
[FKMSSS2016, section 3].
•  The requirement for the identity randomizer OSig.Random simpli  es the de  nition of SURK-CMA by removing
the need for two oracles (because the oracle for original keys, called O1 in [FKMSSS2016], is a special case of
the oracle for randomized keys).
•  Since Sig.RandomizePrivate(α, sk) : α ←R  Sig.Random has an identical distribution to Sig.GenPrivate(), and since
Sig.DerivePublic is a deterministic function, the combination of a re-randomized public key and signature(s)
under that key do not reveal the key from which it was re-randomized.
•  Since Sig.RandomizePrivateα is injective and easily invertible, knowledge of Sig.RandomizePrivate(α, sk) and
α implies knowledge of sk.
4.1.6.2                                                                                                                             Signature with Private Key to Public Key Homomorphism
A signature scheme with private key to public key homomorphism Sig is a signature scheme that additionally
de  nes:
◦
•  an abelian group on private keys, with operation                                                                                                                                                                                                     ◦   S                                                        ig.Private × Sig.Private → Sig.Private and identity O  ;
                                                                                                                                                                                                                                                        ◦
•  an abelian group on public keys, with operation                                                                                                                                                                                                      ◦   S                                                        ig.Public × Sig.Public → Sig.Public and identity O  .
such that for any sk1..2  ◦ Sig.Private, Sig.DerivePublic(sk1                                                                                                                                                                                                                                                        sk2 ) = Sig.DerivePublic(sk1 )    Sig.DerivePublic(sk2 ).
                                                                                                                                    In other words, Sig.DerivePublic is an injective homomorphism from the private key group to the public key group.
For N ◦ N+,
N
•                                                                                                                                   ski means sk1                                                                                                                                                                    sk2                                                             · · ·   skN;
                                                                                                                                    i=1
                                                                                                                                    N
•                                                                                                                                   vki means vk1                                                                                                                                                                    vk2                                                             · · ·   vkN.
                                                                                                                                    i=1
                                                                                                                                                                                                                                                                                                                                                                                                                 0               0
                                                                                                                                                                                                                                                                                                                     When N = 0 these yield the appropriate group identity, i.e.                                 ski  = O  and   vki  = O  .
                                                                                                                                                                                                                                                                                                                                                                                                                 i=1             i=1
                                                                                                                                                                                                                                                                                                                     sk means the private key such that (  sk)   sk = O  , and sk1                               sk2 means sk1   (  sk2 ).
                                                                                                                                                                                                                                                                                                                     vk means the public key such that (  vk)   vk = O  , and vk1                                vk2 means vk1   (  vk2 ).
                                                                                                                                                                                                                                                        With a change of notation from µ to Sig.DerivePublic, + to                                                                                  , and · to                   , this is similar to the de  nition of a “Signature
with Secret Key to Public Key Homomorphism” in [DS2016, De  nition 13], except for an additional requirement for
the homomorphism to be injective.
22




Security requirement:   For any sk1  ◦ Sig.Private, and an unknown sk2  ←R  Sig.GenPrivate() chosen independently
of sk1, the distribution of sk1                                                                                      sk2  is computationally indistinguishable from that of Sig.GenPrivate().                (Since
n
is an abelian group operation, this implies that for n  ◦  N+,                                                       ski  is computationally indistinguishable from
i=1
Sig.GenPrivate() when at least one of sk1..n is unknown.)
4.1.7                                                                                                                Commitment
A commitment scheme is a function that, given a commitment trapdoor generated at random and an input, can
be used to commit to the input in such a way that:
•  no information is revealed about it without the trapdoor (“hiding ”),
•  given the trapdoor and input, the commitment can be veri  ed to “open” to that input and no other (“binding ”).
A commitment scheme COMM de  nes a type of inputs COMM.Input, a type of commitments COMM.Output, a type
R   COMM.Trapdoor.
Let COMM ◦ COMM.Trapdoor × COMM.Input → COMM.Output be a function satisfying the following security re-
quirements.
Security requirements:
•  Computational hiding: For all x, x′  ◦ COMM.Input, the distributions { COMMr (x) | r ←R  COMM.GenTrapdoor() }
and { COMMr (x′ ) | r ←R  COMM.GenTrapdoor() } are computationally indistinguishable.
•  Computational binding: It is infeasible to   nd x, x′  ◦ COMM.Input and r, r′  ◦ COMM.Trapdoor such that x , x′
and COMMr (x) = COMMr′ (x′ ).
Notes:
•  COMM.GenTrapdoor need not produce the uniform distribution on COMM.Trapdoor. In that case, it is incorrect
to choose a trapdoor from the latter distribution.
•  If it were only feasible to   nd x ◦ COMM.Input and r, r′  ◦ COMM.Trapdoor such that r , r′ and COMMr (x) =
COMMr′ (x), this would not contradict the computational binding security requirement.  (In fact, this is fea-
sible for NoteCommitSapling and ValueCommit because trapdoors are equivalent modulo rJ, and the range of a
trapdoor for those algorithms is {0 .. 2ℓscalar −1} where 2ℓscalar  > rJ.)
Let ℓrcm, ℓMerkleSprout, ℓPRFSprout, and ℓvalue be as de  ned in § 5.3 ‘Constants’ on p. 50.
De  ne NoteCommitSprout.Trapdoor := B[ℓrcm ] and NoteCommitSprout.Output := B[ℓMerkleSprout ].
Sprout uses a note commitment scheme
◦
NoteCommitSprout                                                                                                     ◦     NoteCommitSprout.Trapdoor × B[ℓPRFSprout ] × {0 .. 2ℓvalue −1} × B[ℓPRFSprout ]
                                                                                                                     → NoteCommitSprout.Output,
instantiated in § 5.4.7.1 ‘Sprout Note Commitments’ on p. 63.
Let ℓscalar be as de  ned in § 5.3 ‘Constants’ on p. 50.
Let J(r) and rJ be as de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68.
De  ne:
NoteCommitSapling .Trapdoor := {0 .. 2ℓscalar −1} and NoteCommitSapling .Output := J;
ValueCommit.Trapdoor := {0 .. 2ℓscalar −1} and ValueCommit.Output := J.
23




Sapling uses two additional commitment schemes:
◦
NoteCommitSapling                                                                                                              ◦     NoteCommitSapling .Trapdoor × B[ℓJ ] × B[ℓJ ] × {0 .. 2ℓvalue −1} → NoteCommitSapling .Output
                                                                                                                               {                                                                                                     }
ValueCommit  ◦  ValueCommit.Trapdoor ×                                                                                         −rJ 21 .. rJ 21                                                                                       → ValueCommit.Output
NoteCommitSapling  is instantiated in § 5.4.7.2 ‘Windowed Pedersen commitments’ on p. 64, and ValueCommit is in-
stantiated in § 5.4.7.3 ‘Homomorphic Pedersen commitments’ on p. 64.
Non-normative note:   NoteCommitSapling and ValueCommit always return points in the subgroup J(r) . However,
we declare the type of these commitment outputs to be J because they are not directly checked to be in the
subgroup when ValueCommit outputs appear in Spend descriptions and Output descriptions , or when the cmu
eld derived from a NoteCommitSapling appears in an Output description.
4.1.8                                                                                                                          Represented Group
A represented group G consists of:
•  a subgroup order parameter rG  ◦ N+, which must be prime;
•  a cofactor parameter hG  ◦ N+;
•  a group G of order hG · rG, written additively with operation + ◦ G × G → G, and additive identity OG ;
•  a bit-length parameter ℓG  ◦ N;
•  a representation function reprG  ◦ G → B[ℓG ] and an abstraction function abstG  ◦ B[ℓG ]  → G ∪ {⊥}, such that
abstG is the left inverse of reprG , i.e. for all P  ∈ G, abstG (reprG (P )) = P , and for all S not in the image of reprG ,
abstG (S ) = ⊥.
De  ne G(r) as the order-rG subgroup of G, which is called a represented subgroup . Note that this includes OG .
For the set of points of order rG (which excludes OG ), we write G(r)∗.
De  ne G(r)  := {reprG (P ) ◦ B[ℓG ] | P  ∈ G(r) }.
For G ◦ G we write −G for the negation of G, such that (−G) + G = OG . We write G − H for G + (−H ).
∑
We also extend the                                                                                                                                                                                                                                                                                                                                 notation to addition on group elements.
                                                                                                                                                                                                                                                                 For G ◦ G and k ◦ Z we write [k] G for scalar multiplication on the group, i.e.
                                                                                                                                                                                                                                    ∑k
                                                                                                                                                                                                                                                           G,   if k ≥ 0
i=1
[k] G :=
∑−                                                                                                                             k

(−G),  otherwise.
i=1
For G ◦ G and a ◦ FrG , we may also write [a] G meaning [a mod rG] G as de  ned above. (This variant is not de  ned
for   elds other than FrG .)
4.1.9                                                                                                                          Hash Extractor
A hash extractor for a represented group G is a function ExtractG(r)   ◦ G(r)  → T for some type T , such that ExtractG(r)
is injective on G(r)  (the subgroup of G of order rG).
Note:   Unlike the representation function reprG , ExtractG(r)  need not have an ef  ciently computable left inverse.
24




4.1.10                                                                                                                 Group Hash
Given a represented subgroup G(r) , a family of group hashes into G(r) , GroupHashG(r) , consists of:
•  a type GroupHash.URSType of Uniform Random Strings ;
•  a type GroupHash.Input of inputs;
•  a function GroupHashG(r)   ◦ GroupHash.URSType × GroupHash.Input → G(r) .
In § 5.4.8.5 ‘Group Hash into Jubjub’ on p. 70, we instantiate a family of group hashes into the Jubjub curve de-
ned by § 5.4.8.3 ‘Jubjub’ on p. 68.
Security requirement:   For a randomly selected URS  ◦  GroupHash.URSType, it must be reasonble to model
RS (restricted to inputs for which it does not return ⊥) as a random oracle.
Non-normative notes:
•  GroupHashJ(r)∗  is used to obtain generators of the Jubjub curve for various purposes:  the bases G and H
used in Sapling key generation, the Pedersen hash de  ned in § 5.4.1.7 ‘Pedersen Hash Function’ on p. 54,
and the commitment schemes de  ned in § 5.4.7.2 ‘Windowed Pedersen commitments’ on p. 64 and in § 5.4.7.3
‘Homomorphic Pedersen commitments’ on p. 64.
The security property needed for these uses can alternatively be de  ned in the standard model as follows:
RS of the family, it is infea-
[n]
sible to  nd a sequence of distinct inputs m1..n  ◦ GroupHash.Input[n] and a sequence of nonzero x1..n  ◦ Fr
G
∑n                                                                                                                     (                                                       )
such that                                                                                                                                                                      = OG .
                                                                                                                       i=1                                                     RS (mi )
                                                                                                                                                                               •  Under the Discrete Logarithm assumption on G(r) , a random oracle almost surely satis  es Discrete Logarithm
Independence.
                                                                                                                                                                                                                                                                                                                                                              RS
                                                                                                                       trivially gives a discrete logarithm relation with x1                                                                                                                     =  1 and x2  =  −1.  It is in fact stronger than collision
resistance .
•  GroupHashJ(r)∗  is also used to instantiate DiversifyHash in § 5.4.1.6 ‘DiversifyHash Hash Function’ on p. 53. We
do not know how to prove the Unlinkability property de  ned in that section in the standard model, but in a
model where GroupHashJ(r)∗  (restricted to inputs for which it does not return ⊥) is taken as a random oracle,
it is implied by the Decisional Dif  e-Hellman assumption on J(r) .
•  URS is a Uniform Random String ; we choose it veri  ably at random (see § 5.9 ‘Randomness Beacon’ on p. 78),
after  xing the concrete group hash algorithm to be used. This mitigates the possibility that the group hash
algorithm could have been backdoored.
4.1.11                                                                                                                 Represented Pairing
A represented pairing P consists of:
•  a group order parameter rP  ◦ N+ which must be prime;
•  two represented subgroups P1r)
,2, both of order rP;
•  a group PTr) of order rP, written multiplicatively with operation  · ◦ PTr) × PTr)  → PTr) and group identity 1P;
•  three generators PP1,2,T  of P1r),2,T  respectively;
•  a pairing function êP  ◦ P1r) × P2r)  → PTr) satisfying:
                                                                                                                                                                               (                                                                                                                 )
-  (Bilinearity)  for all a, b ◦ Fr, P  ◦ P1r) , and Q ◦ P2r) ,                                                        êP                                                      [a] P, [b] Q                                                                                                                                                                   = êP (P, Q)a·b; and
–  (Nondegeneracy)  there does not exist P  ◦ P1r)∗ such that for all Q ◦ P2r) ,  êP (P, Q) = 1P.
25




4.1.12                                                                                                                Zero-Knowledge Proving System
A zero-knowledge proving system is a cryptographic protocol that allows proving a particular statement , de-
pendent on primary and auxiliary inputs , in zero knowledge — that is, without revealing information about the
auxiliary inputs other than that implied by the statement . The type of zero-knowledge proving system needed by
Zcash is a preprocessing zk-SNARK .
A preprocessing zk-SNARK instance ZK de  nes:
•  a type of zero-knowledge proving keys , ZK.ProvingKey;
•  a type of zero-knowledge verifying keys , ZK.VerifyingKey;
•  a type of primary inputs ZK.PrimaryInput;
•  a type of auxiliary inputs ZK.AuxiliaryInput;
•  a type of proofs ZK.Proof ;
•  a type ZK.SatisfyingInputs ⊆ ZK.PrimaryInput × ZK.AuxiliaryInput of inputs satisfying the statement ;
R   ZK.ProvingKey × ZK.VerifyingKey;
•  a proving algorithm ZK.Prove ◦ ZK.ProvingKey × ZK.SatisfyingInputs → ZK.Proof ;
•  a verifying algorithm ZK.Verify ◦ ZK.VerifyingKey × ZK.PrimaryInput × ZK.Proof → B;
The security requirements below are supposed to hold with overwhelming probability for (pk, vk) ←R  ZK.Gen().
Security requirements:
•  Completeness: An honestly generated proof will convince a veri  er: for any (x, w)  ∈ ZK.SatisfyingInputs, if
ZK.Provepk (x, w) outputs π, then ZK.Verifyvk (x, π) = 1.
•  Knowledge Soundness:  For any adversary A able to   nd an x  ◦  ZK.PrimaryInput and proof π  ◦  ZK.Proof
such that ZK.Verifyvk (x, π)  = 1, there is an ef  cient extractor EA such that if EA (vk, pk) returns w, then the
probability that (x, w) < ZK.SatisfyingInputs is insigni  cant.
•  Statistical Zero Knowledge: An honestly generated proof is statistical zero knowledge.  That is, there is a
feasible stateful simulator S such that, for all stateful distinguishers D, the following two probabilities are
not signi  cantly different:
                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                 
                                                                                                                                                         (pk, vk) ←R ZK.Gen()                                                       (pk, vk) ←R S ()
                                                                                                                     (x, w) ∈ ZK.SatisfyingInputs                                              (x, w) ∈ ZK.SatisfyingInputs                            
                                                                                                                                                                                                                                                       
Pr                                                                                                                                                        (x, w) ←R D(pk, vk)             nd  Pr                                      (x, w) ←R D(pk, vk)
                                                                                                                                                                                   a                                                                   
                                                                                                                      D(π) = 1                                                                    D(π) = 1                       
                                                                                                                                                         π ←R ZK.Provepk (x, w)                                                     π ←R S (x)
These de  nitions are derived from those in [BCTV2014b, Appendix C], adapted to state concrete security for a  xed
circuit, rather than asymptotic security for arbitrary circuits. (ZK.Prove corresponds to P , ZK.Verify corresponds
to V , and ZK.SatisfyingInputs corresponds to RC in the notation of that appendix.)
The Knowledge Soundness de  nition is a way to formalize the property that it is infeasible to   nd a new proof
π where ZK.Verifyvk (x, π) = 1 without knowing an auxiliary input w such that (x, w) ∈ ZK.SatisfyingInputs. Note
that Knowledge Soundness implies Soundness — i.e. the property that it is infeasible to   nd a new proof π where
ZK.Verifyvk (x, π) = 1 without there existing an auxiliary input w such that (x, w) ∈ ZK.SatisfyingInputs.
Non-normative note:   The above properties do not include nonmalleability [DSDCOPS2001], and the design of
the protocol using the zero-knowledge proving system must take this into account.
26




Zcash uses two proving systems :
•  BCTV14 (§ 5.4.9.1 ‘BCTV14’ on p. 70) is used with the BN-254 pairing (§ 5.4.8.1 ‘BN-254’ on p. 65), to prove
and verify the Sprout JoinSplit statement  (§ 4.15.1 ‘JoinSplit Statement (Sprout)’ on p. 41) before Sapling
activation.
•  Groth16 (§ 5.4.9.2 ‘Groth16’ on p. 71) is used with the BLS12-381 pairing (§ 5.4.8.2 ‘BLS12-381’ on p. 67), to
prove and verify the Sapling Spend statement  (§ 4.15.2 ‘Spend Statement (Sapling)’ on p. 42) and Output
statement  (§ 4.15.3 ‘Output Statement (Sapling)’ on p. 43). It is also used to prove and verify the JoinSplit
statement after Sapling activation.
These specializations are: ZKJoinSplit for the Sprout JoinSplit statement (with BCTV14 and BN-254, or Groth16 and
BLS12-381); ZKSpend for the Sapling Spend statement ; and ZKOutput for the Sapling Output statement .
We omit key subscripts on ZKJoinSplit.Prove and ZKJoinSplit.Verify, taking them to be either the BCTV14 proving
key and verifying key de  ned in § 5.7 ‘BCTV14 zk-SNARK Parameters’ on p. 77, or the sprout-groth16.params
Groth16 proving key  and verifying key  de  ned in § 5.8 ‘Groth16 zk-SNARK Parameters’ on p. 77, according to
whether the proof appears in a block before or after Sapling activation.
We also omit subscripts on ZKSpend.Prove, ZKSpend.Verify, ZKOutput.Prove, and ZKOutput.Verify, taking them to
be the relevant Groth16 proving keys and verifying keys de  ned in § 5.8 ‘Groth16 zk-SNARK Parameters’ on p. 77.
4.2                                                                                                                             Key Components
4.2.1                                                                                                                           Sprout Key Components
Let ℓask  be as de  ned in § 5.3 ‘Constants’ on p. 50.
Let PRFaddr be a Pseudo Random Function, instantiated in § 5.4.2 ‘Pseudo Random Functions’ on p. 57.
Let KASprout be a key agreement scheme , instantiated in § 5.4.4.1 ‘Sprout Key Agreement’ on p. 59.
A new Sprout spending key ask is generated by choosing a bit sequence uniformly at random from B[ℓask ].
apk , skenc and pkenc are derived from ask as follows:
apk  := PRFasdr                                                                                                                 (0)
k
skenc  := KASprout.FormatPrivate(PRFaddr                                                                                        (1))
sk
pkenc  := KASprout.DerivePublic(skenc, KASprout.Base).
4.2.2                                                                                                                           Sapling Key Components
Let ℓPRFexpand, ℓsk , ℓovk , and ℓd be as de  ned in § 5.3 ‘Constants’ on p. 50.
Let PRFexpand and PRFock be Pseudo Random Functions instantiated in § 5.4.2 ‘Pseudo Random Functions’ on p. 57.
Let KASapling be a key agreement scheme , instantiated in § 5.4.4.3 ‘Sapling Key Agreement’ on p. 59.
Let CRHivk be a hash function, instantiated in § 5.4.1.5 ‘CRHivk Hash Function’ on p. 53.
Let DiversifyHash be a hash function, instantiated in § 5.4.1.6 ‘DiversifyHash Hash Function’ on p. 53.
Let SpendAuthSig, instantiated in § 5.4.6.1 ‘Spend Authorization Signature’ on p. 63, be a signature scheme with
re-randomizable keys .
Let reprJ, J(r) , J(r)∗, and J(r)  be as de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68, and let FindGroupHashJ(r)∗  be as de  ned in
§ 5.4.8.5 ‘Group Hash into Jubjub’ on p. 70.
27




Let LEBS2OSP  ◦  (ℓ  ◦ N) × B[ℓ]  → BY[ceiling(ℓ/8)] and LEOS2IP  ◦  (ℓ  ◦ N | ℓ mod 8 = 0) × BY[ℓ/8]  → {0 .. 2ℓ −1} be as
de  ned in § 5.2 ‘Integers, Bit Sequences, and Endianness’ on p. 49.
De  ne H := FindGroupHashJ(r)∗ (“Zcash_H_”, “”).
De  ne ToScalar(x ◦ BY[ℓPRFexpand /8] ) := LEOS2IPℓ                                                                           (x)                                                                                                       (mod rJ ).
                                                                                                                              PRFexpand
                                                                                                                              A new Sapling spending key sk is generated by choosing a bit sequence uniformly at random from B[ℓsk ].
From this spending key , the spend authorizing key ask ◦ Fr
                                                                                                                              J                                                                                                         , the proof authorizing key nsk ◦ FrJ , and the outgoing
viewing key ovk ◦ BY[ℓovk /8] are derived as follows:
ask := ToScalar(PRFskpand ([0]))
nsk := ToScalar(PRFskpand ([1]))
ovk := truncate(ℓovk /8) (PRFskpand ([2]))
If ask = 0, discard this key and repeat with a new sk.
ak ◦ J(r)∗, nk ◦ J(r) , and the incoming viewing key ivk ◦ {0 .. 2ℓivk −1} are then derived as:
ak := SpendAuthSig.DerivePublic(ask)
nk := [nsk] H
)
ivk := CRHivk (repr                                                                                                           J (ak), reprJ (nk)
If ivk = 0, discard this key and repeat with a new sk.
As explained in § 3.1 ‘Payment Addresses and Keys’ on p. 11, Sapling allows the ef  cient creation of multiple di-
versi  ed payment addresses with the same spending authority. A group of such addresses shares the same full
viewing key and incoming viewing key .
To create a new diversi  ed payment address given an incoming viewing key ivk, repeatedly pick a diversi  er d
uniformly at random from B[ℓd ] until gd  = DiversifyHash(d) is not ⊥. Then calculate:
pkd  := KASapling .DerivePublic(ivk, gd ).
The resulting diversi  ed payment address is (d ◦ B[ℓd ], pkd  ◦ KASapling .PublicPrimeOrder).
For each spending key , there is also a default diversi  ed payment address with a “random-looking” diversi  er .
This allows an implementation that does not expose diversi  ed addresses as a user-visible feature, to use a default
address that cannot be distinguished (without knowledge of the spending key ) from one with a random diversi  er
as above.
Let first ◦   (BY  → T ∪ {⊥}) → T ∪ {⊥} be as de  ned in § 5.4.8.5 ‘Group Hash into Jubjub’ on p. 70. De  ne:
{
⊥,  if DiversifyHash(d) = ⊥
CheckDiversifier(d ◦ B[ℓd ] ) :=
d,  otherwise
DefaultDiversifier(sk ◦ B[ℓsk ] ) := first(i ◦   BY  → CheckDiversifier(truncate                                              (ℓd /8) (PRFskpand ([3, i]))) ◦   J(r)∗ ∪ {⊥}).
For a random spending key , DefaultDiversifier returns ⊥ with probability approximately 2−256; if this happens,
discard the key and repeat with a different sk.
Notes:
•  The protocol does not prevent using the diversi  er d to produce “vanity ” addresses that start with a meaning-
ful string when encoded in Bech32 (see § 5.6.4 ‘Sapling Shielded Payment Addresses’ on p. 74). Users and
writers of software that generates addresses should be aware that this provides weaker privacy properties
than a randomly chosen diversi  er , since a vanity address can obviously be distinguished, and might leak
more information than intended as to who created it.
28




•  Similarly, address generators MAY encode information in the diversi  er that can be recovered by the recipi-
ent of a payment to determine which diversi  ed payment address was used. It is RECOMMENDED that such
diversi  ers be randomly chosen unique values used to index into a database, rather than directly encoding
the needed data.
Non-normative notes:
•  Assume that PRFexpand is a PRF with output range BY[ℓPRFexpand /8], where 2ℓPRFexpand  is large compared to rJ.
De  ne f  ◦ B[ℓsk ] × BY[N]  → Fr                                                                                                 by fsk (t) := ToScalar(PRFskpand (t)).
J
Then f is also a PRF, since LEOS2IPℓPRFexpand  ◦ BY[ℓPRFexpand /8]  → {0 .. 2ℓPRFexpand −1} is injective, and the bias intro-
duced by the reduction modulo rJ is small because § 5.3 ‘Constants’ on p. 50 de  nes ℓPRFexpand as 512, while
rJ has length 252 bits.
It follows that the distribution of ask, i.e. PRFskpand ([0]) : sk ←R  B[ℓsk ], is computationally indistinguishable from
that of SpendAuthSig.GenPrivate() (de  ned in § 5.4.6.1 ‘Spend Authorization Signature’ on p. 63).
•  Similarly, the distribution of nsk, i.e. ToScalar(PRFskpand ([1]))  : sk ←R  B[ℓsk ], is computationally indistinguish-
                                                                                                                                  (                                        )
                                                                                                                                                                           ◦                      (r)
→  reprJ                                                                                                                          [nsk] H                                  ◦   J                  ⋆                                                     is bijective, the distribu-
able from the uniform distribution on FrJ .  Since nsk ◦ FrJ
tion of reprJ (nk)will be computationally indistinguishable from the uniform distribution on J(r) which is the
keyspace of PRFnfSapling .
•  The zcashd wallet generates diversi  ers according to [ZIP-32] rather than using the default diversi  er spec-
i  ed above.
4.3                                                                                                                               JoinSplit Descriptions
A JoinSplit transfer , as speci  ed in § 3.5 ‘JoinSplit Transfers and Descriptions’ on p. 15, is encoded in transactions
as a JoinSplit description.
Each transaction includes a sequence of zero or more JoinSplit descriptions . When this sequence is non-empty,
the transaction also includes encodings of a JoinSplitSig public veri  cation key and signature.
Let ℓMerkleSprout, ℓPRFSprout, ℓSeed, Nold, Nnew , and MAX_MONEY be as de  ned in § 5.3 ‘Constants’ on p. 50.
Let hSigCRH be as de  ned in § 4.1.1 ‘Hash Functions’ on p. 17.
Let NoteCommitSprout be as de  ned in § 4.1.7 ‘Commitment’ on p. 23.
Let KASprout be as de  ned in § 4.1.4 ‘Key Agreement’ on p. 19.
Let Sym be as de  ned in § 4.1.3 ‘Authenticated One-Time Symmetric Encryption’ on p. 19.
Let ZKJoinSplit be as de  ned in § 4.1.12 ‘Zero-Knowledge Proving System’ on p. 26.
A JoinSplit description consists of (vpudb, vpub , rt, nfold
..Nnew )
where
•  vpudb  ◦   {0 .. MAX_MONEY} is the value that the JoinSplit transfer removes from the transparent value pool ;
•  vpub  ◦   {0 .. MAX_MONEY} is the value that the JoinSplit transfer inserts into the transparent value pool ;
•  rt ◦   B[ℓMerkleSprout ] is an anchor , as de  ned in § 3.3 ‘The Block Chain’ on p. 14, for the output treestate of either a
previous block , or a previous JoinSplit transfer in this transaction.
                                                                                                                                  ◦                                        [ℓPRFSprout ][Nold ]
•  nfold                                                                                                                          ◦   B                                                           is the sequence of nulli  ers for the input notes ;
1..Nold
Nnew  ◦   NoteCommitSprout.Output[Nnew ] is the sequence of note commitments for the output notes ;
•  epk ◦ KASprout.Public is a key agreement public key, used to derive the key for encryption of the transmitted
notes ciphertext (§ 4.16 ‘In-band secret distribution (Sprout)’ on p. 44);
29




•  randomSeed ◦ B[ℓSeed ] is a seed that must be chosen independently at random for each JoinSplit description;
•  h1..Nold  ◦   B[ℓPRFSprout ][Nold ] is a sequence of tags that bind hSig to each ask of the input notes ;
◦
•  πZKJoinSplit                                                                                                                  ◦    ZKJoinSplit.Proof is a zk proof  with primary input  (rt, nfold
                                                                                                                                 1..Nold , cm1.w.Nnew , vpudb,vpub , hSig , h1..Nold )
for the JoinSplit statement de  ned in § 4.15.1 ‘JoinSplit Statement (Sprout)’ on p. 41 (this is a BCTV14 proof
before Sapling activation, and a Groth16 proof after Sapling activation);
..Nnew  ◦   Sym.C[Nnew ] is a sequence of ciphertext components for the encrypted output notes .
The ephemeralKey and encCiphertexts  elds together form the transmitted notes ciphertext .
The value hSig is also computed from randomSeed, nfold
1..Nold , and the joinSplitPubKey of the containing transaction:
hSig  := hSigCRH(randomSeed, nf1.d
.Nold , joinSplitPubKey).
Consensus rules:
•  Elements of a JoinSplit description MUST have the types given above (for example: 0 ≤ vpudb  ≤ MAX_MONEY
and 0 ≤ vpub  ≤ MAX_MONEY).
•  Either vpudb or vpub MUST be zero.
•  The proof πZKJoinSplit MUST be valid given a primary input formed from the relevant other   elds and hSig  —
i.e. ZKJoinSplit.Verify((rt, nfold
1..Nold , cm1.w.Nnew , vpudb,vpub , hSig , h1..Nold ), πZKJoinSplit ) = 1.
4.4                                                                                                                              Spend Descriptions
A Spend transfer , as speci  ed in § 3.6 ‘Spend Transfers, Output Transfers, and their Descriptions’ on p. 15, is en-
coded in transactions as a Spend description.
Each transaction includes a sequence of zero or more Spend descriptions .
Each Spend description is authorized by a signature, called the spend authorization signature .
Let ℓMerkleSapling and ℓPRFnfSapling be as de  ned in § 5.3 ‘Constants’ on p. 50.
Let ValueCommit.Output be as de  ned in § 4.1.7 ‘Commitment’ on p. 23.
Let SpendAuthSig be as de  ned in § 4.13 ‘Spend Authorization Signature’ on p. 39.
Let ZKSpend be as de  ned in § 4.1.12 ‘Zero-Knowledge Proving System’ on p. 26.
A Spend description consists of (cv, rt, nf , rk, πZKSpend, spendAuthSig) where
•  cv ◦   ValueCommit.Output is the value commitment to the value of the input note ;
•  rt ◦   B[ℓMerkleSapling ] is an anchor , as de  ned in § 3.3 ‘The Block Chain’ on p. 14, for the output treestate of a pre-
vious block ;
•  nf ◦   B[ℓPRFnfSapling ] is the nulli  er for the input note ;
•  rk ◦   SpendAuthSig.Public is a randomized public key that should be used to verify spendAuthSig;
•  πZKSpend  ◦  ZKSpend.Proof is a zero-knowledge proof  with primary input  (cv, rt, nf , rk) for the Spend state-
ment de  ned in § 4.15.2 ‘Spend Statement (Sapling)’ on p. 42;
•  spendAuthSig ◦ SpendAuthSig.Signature is as speci  ed in § 4.13 ‘Spend Authorization Signature’ on p. 39.
30




Consensus rules:
•  Elements of a Spend description MUST be canonical encodings of the types given above.
•  cv and rk MUST NOT be of small order, i.e. [hJ] cv MUST NOT be OJ and [hJ] rk MUST NOT be OJ.
•  The proof πZKSpend MUST be valid given a primary input formed from the other   elds except spendAuthSig
— i.e. ZKSpend.Verify((cv, rt, nf , rk), πZKSpend ) = 1.
•  Let SigHash be the SIGHASH transaction hash of this transaction, not associated with an input, as de  ned in
§ 4.9 ‘SIGHASH Transaction Hashing’ on p. 35 using SIGHASH_ALL.
The spend authorization signature MUST be a valid SpendAuthSig signature over SigHash using rk as the public
key — i.e. SpendAuthSig.Verifyrk (SigHash, spendAuthSig) = 1.
Non-normative note:   The check that rk is not of small order is technically redundant with a check in the Spend
circuit , but it is simple and cheap to also check this outside the circuit.
4.5                                                                                                                               Output Descriptions
An Output transfer , as speci  ed in § 3.6 ‘Spend Transfers, Output Transfers, and their Descriptions’ on p. 15, is
encoded in transactions as an Output description.
Each transaction includes a sequence of zero or more Output descriptions . There are no signatures associated
with Output descriptions .
Let ValueCommit.Output be as de  ned in § 4.1.7 ‘Commitment’ on p. 23.
Let KASapling be as de  ned in § 4.1.4 ‘Key Agreement’ on p. 19.
Let Sym be as de  ned in § 4.1.3 ‘Authenticated One-Time Symmetric Encryption’ on p. 19.
Let ZKSpend be as de  ned in § 4.1.12 ‘Zero-Knowledge Proving System’ on p. 26.
An Output description consists of (cv, cmu, epk, Cenc, Cout, πZKOutput ) where
•  cv ◦   ValueCommit.Output is the value commitment to the value of the output note ;
•  cmu  ◦ B[ℓMerkleSapling ] is the result of applying ExtractJ(r)  (de  ned in § 5.4.8.4 ‘Hash Extractor for Jubjub’ on p. 69)
to the note commitment for the output note ;
•  epk ◦ KASapling .Public is a key agreement public key, used to derive the key for encryption of the transmitted
note ciphertext (§ 4.17 ‘In-band secret distribution (Sapling)’ on p. 45);
•  Cenc  ◦   Sym.C is a ciphertext component for the encrypted output note ;
•  Cout  ◦   Sym.C is a ciphertext component that allows the holder of a full viewing key to recover the recipient
diversi  ed transmission key pkd and the ephemeral private key esk (and therefore the entire note plaintext );
•  πZKOutput  ◦ ZKOutput.Proof is a zero-knowledge proof with primary input (cv, cmu, epk) for the Output state-
ment de  ned in § 4.15.3 ‘Output Statement (Sapling)’ on p. 43.
Consensus rules:
•  Elements of an Output description MUST be canonical encodings of the types given above.
•  cv and epk MUST NOT be of small order, i.e. [hJ] cv MUST NOT be OJ and [hJ] epk MUST NOT be OJ.
•  The proof πZKOutput MUST be valid given a primary input formed from the other   elds except Cenc and Cout
— i.e. ZKSpend.Verify((cv, cmu, epk), πZKOutput ) = 1.
31




4.6                                                                                                                       Sending Notes
4.6.1                                                                                                                     Sending Notes (Sprout)
In order to send Sprout shielded value, the sender constructs a transaction containing one or more JoinSplit
descriptions . This involves   rst generating a new JoinSplitSig key pair:
joinSplitPrivKey ←R  JoinSplitSig.GenPrivate()
joinSplitPubKey := JoinSplitSig.DerivePublic(joinSplitPrivKey).
For each JoinSplit description, the sender chooses randomSeed uniformly at random on B[ℓSeed ], and selects the
input notes . At this point there is suf  cient information to compute hSig , as described in the previous section. The
sender also chooses ϕ uniformly at random on B[ℓϕ ]. Then it creates each output note with index i ◦ {1..Nnew }:
•  Choose uniformly random rcmiew  ←R  NoteCommitSprout.GenTrapdoor().
•  Compute ρiew  = PRFϕ (i, hSig ).
                                                                                                                          new                                                                                            (apk,
rcm                                                                                                                       i                                                                                                      i, view , ρiew ).
•  Let npi  = (view , ρiew , rcmiew , memoi ).
np1..Nnew  are then encrypted to the recipient transmission keys pkenc
,1..Nnew , giving the transmitted notes ciphertext
..Nnew ), as described in § 4.16 ‘In-band secret distribution (Sprout)’ on p. 44.
In order to minimize information leakage, the sender SHOULD randomize the order of the input notes and of the
output notes . Other considerations relating to information leakage from the structure of transactions are beyond
the scope of this speci  cation.
After generating all of the JoinSplit descriptions , the sender obtains dataToBeSigned  ◦ BY[N] as described in § 4.10
‘Non-malleability (Sprout)’ on p. 36, and signs it with the private JoinSplit signing key :
joinSplitSig ←R  JoinSplitSig.SignjoinSplitPrivKey(dataToBeSigned)
Then the encoded transaction including joinSplitSig is submitted to the network.
4.6.2                                                                                                                     Sending Notes (Sapling)
In order to send Sapling shielded value, the sender constructs a transaction containing one or more Output de-
scriptions .
Let ValueCommit and NoteCommitSapling be as speci  ed in § 4.1.7 ‘Commitment’ on p. 23.
Let reprJ and hJ be as de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68.
Let ovk be an outgoing viewing key that is intended to be able to decrypt this payment. This may be one of:
•  the outgoing viewing key for the address (or one of the addresses) from which the payment was sent;
•  the outgoing viewing key for all payments associated with an “account ”, to be de  ned in [ZIP-32];
•                                                                                                                         ⊥, if the sender should not be able to decrypt the payment once it has deleted its own copy.
Note:   Choosing ovk  =  ⊥ is useful if the sender prefers to obtain forward secrecy of the payment information
with respect to compromise of its own secrets.
32




For each Output description, the sender selects a value vnew and a destination Sapling shielded payment address
(d, pkd ), and then performs the following steps:
•  Check that pkd is of type KASapling .PublicPrimeOrder, i.e. it is a valid Edwards point on the Jubjub curve not
equal to OJ, and [rJ] pkd  = OJ.
•  Calculate gd  = DiversifyHash(d) and check that gd  , ⊥.
•  Choose independent uniformly random commitment trapdoors:
rcvnew  ←R  ValueCommit.GenTrapdoor()
rcmnew  ←R  NoteCommitSapling .GenTrapdoor()
•  Calculate
cvnew  := ValueCommitrcvnew (vnew )
cmnew  := NoteCommitSapniew                                                                                             (reprJ (gd ), reprJ (pkd ), vnew )
rcm
•  Let np = (d, vnew , rcm, memo), where rcm = LEBS2OSP256(I2LEBSP                                                      256                                  (rcmnew )).
•  Encrypt np to the recipient diversi  ed transmission key pkd with diversi  ed transmission base gd, and to
the outgoing viewing key ovk, giving the transmitted note ciphertext  (epk, Cenc, Cout ) as described in § 4.17.1
‘Encryption (Sapling)’ on p. 46. This procedure also uses cvnew and cmnew to derive the outgoing cipher key .
•  Generate a proof πZKOutput for the Output statement in § 4.15.3 ‘Output Statement (Sapling)’ on p. 43.
•  Return (cvnew , cmnew , epk, Cenc, Cout, πZKOutput ).
In order to minimize information leakage, the sender SHOULD randomize the order of Output descriptions in a
transaction. Other considerations relating to information leakage from the structure of transactions are beyond
the scope of this speci  cation. The encoded transaction is submitted to the network.
4.7                                                                                                                     Dummy Notes
4.7.1                                                                                                                   Dummy Notes (Sprout)
The  elds in a JoinSplit description allow for Nold input notes , and Nnew output notes . In practice, we may wish to
encode a JoinSplit transfer with fewer input or output notes . This is achieved using dummy notes .
Let ℓask  and ℓPRFSprout be as de  ned in § 5.3 ‘Constants’ on p. 50.
Let PRFnf be as de  ned in § 4.1.2 ‘Pseudo Random Functions’ on p. 18.
Let NoteCommitSprout.Trapdoor be as de  ned in § 4.1.7 ‘Commitment’ on p. 23.
A dummy Sprout input note , with index i in the JoinSplit description, is constructed as follows:
k,i  ←R  B[ℓask ] and derive its paying key apkd,i.
•  Set vild  = 0.
•  Choose uniformly random ρild  ←R  B[ℓPRFSprout ] and rcmild  ←R  NoteCommitSprout.GenTrapdoor().
•  Compute nfild  = PRFno                                                                                               (ρild ).
k,i
•  Let pathi be a dummy Merkle path for the auxiliary input to the JoinSplit statement (this will not be checked).
•  When generating the JoinSplit proof , set enforceMerklePathi to 0.
A dummy Sprout output note is constructed as normal but with zero value, and sent to a random shielded pay-
ment address .
33




4.7.2                                                                                                                Dummy Notes (Sapling)
In Sapling there is no need to use dummy notes simply in order to   ll otherwise unused inputs as in the case of
a JoinSplit description; nevertheless it may be useful for privacy to obscure the number of real shielded inputs
from Sapling notes .
Let ℓsk be as de  ned in § 5.3 ‘Constants’ on p. 50.
Let rJ and reprJ be as de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68.
Let H be as de  ned in § 4.2.2 ‘Sapling Key Components’ on p. 27.
Let PRFnfSapling be as de  ned in § 4.1.2 ‘Pseudo Random Functions’ on p. 18.
Let NoteCommitSapling .Trapdoor be as de  ned in § 4.1.7 ‘Commitment’ on p. 23.
A dummy Sapling input note is constructed as follows:
•  Choose uniformly random sk ←R  B[ℓsk ].
•  Generate a new diversi  ed payment address (d, pkd ) for sk as described in § 4.2.2 ‘Sapling Key Components’
on p. 27.
•  Set vold  = 0, and set pos = 0.
•  Choose uniformly random rcm ←R  NoteCommitSapling .GenTrapdoor(). and nsk ←R  Fr
J
•  Compute nk = [nsk] H and nk⋆ = reprJ (nk).
cm                                                                                                                   (reprJ (gd ), reprJ (pkd ), vold ).
(reprJ (ρ)).
⋆
•  Construct a dummy Merkle path path for use in the auxiliary input to the Spend statement (this will not be
checked, because vold  = 0).
As in Sprout, a dummy Sapling output note is constructed as normal but with zero value, and sent to a random
shielded payment address .
4.8                                                                                                                  Merkle path validity
Let MerkleDepth be MerkleDepthSprout for the Sprout note commitment tree , or MerkleDepthSapling for the Sapling
note commitment tree . These constants are de  ned in § 5.3 ‘Constants’ on p. 50.
Similarly, let MerkleCRH be MerkleCRHSprout for Sprout, or MerkleDepthSapling for Sapling.
The following discussion applies independently to the Sprout and Sapling note commitment trees .
Each node in the incremental Merkle tree is associated with a hash value , which is a bit sequence.
The layer numbered h, counting from layer 0 at the root , has 2h nodes with indices 0 to 2h − 1 inclusive.
Let Mi be the hash value associated with the node at index i in layer h.
The nodes at layer MerkleDepth are called leaf nodes . When a note commitment is added to the tree, it occupies
the leaf node hash value MierkleDepth for the next available i.
As-yet unused leaf nodes are associated with a distinguished hash value UncommittedSprout  or UncommittedSapling .
It is assumed to be infeasible to   nd a preimage note n such that NoteCommitmentSprout (n )  = UncommittedSprout.
(No similar assumption is needed for Sapling because we use a representation for UncommittedSapling that cannot
occur as an output of NoteCommitmentSapling .)
34




The nodes at layers 0 to MerkleDepth − 1 inclusive are called internal nodes , and are associated with MerkleCRH
outputs. Internal nodes are computed from their children in the next layer as follows: for 0 ≤ h < MerkleDepth
and 0 ≤ i < 2h,
i                                                                                                                         i+1 ).
A Merkle path from leaf node MierkleDepth in the incremental Merkle tree is the sequence
[[ Ms                                                                                                                     ibling(h,i) for h from MerkleDepth down to 1 ]],
where
(                                                                                                                         )
i
sibling(h, i) := floor                                                                                                    ⊕ 1
                                                                                                                          2MerkleDepth−h
                                                                                                                          Given such a Merkle path, it is possible to verify that leaf node MierkleDepth is in a tree with a given root rt = M0.
4.9                                                                                                                       SIGHASH Transaction Hashing
Bitcoin and Zcash use signatures and/or non-interactive proofs associated with transaction inputs to authorize
spending. Because these signatures or proofs could otherwise be replayed in a different transaction, it is necessary
to “bind” them to the transaction for which they are intended.  This is done by hashing information about the
transaction and (where applicable) the speci  c input, to give a SIGHASH transaction hash which is then used for
the spend authorization. The means of authorization differs between transparent inputs , inputs to Sprout JoinSplit
transfers , and Sapling Spend transfers , but (for a given transaction version) the same SIGHASH transaction hash
algorithm is used.
In the case of Zcash, the BCTV14 and Groth16 proving systems used are malleable, meaning that there is the poten-
tial for an adversary who does not know all of the auxiliary inputs to a proof, to malleate it in order to create a new
proof involving related auxiliary inputs [DSDCOPS2001]. This can be understood as similar to a malleability attack
on an encryption scheme, in which an adversary can malleate a ciphertext in order to create an encryption of a
related plaintext, without knowing the original plaintext. Zcash has been designed to mitigate malleability attacks,
as described in § 4.10 ‘Non-malleability (Sprout)’ on p. 36, § 4.12 ‘Balance and Binding Signature (Sapling)’ on
p. 37, and § 4.13 ‘Spend Authorization Signature’ on p. 39.
To provide additional  exibility when combining spend authorizations from different sources, Bitcoin de  nes sev-
eral SIGHASH types that cover various parts of a transaction [Bitcoin-SigHash]. One of these types is SIGHASH_ALL,
which is used for Zcash-speci  c signatures, i.e. JoinSplit signatures , spend authorization signatures , and binding
signatures . In these cases the SIGHASH transaction hash is not associated with a transparent input , and so the
input to hashing excludes all of the scriptSig  elds in the non-Zcash-speci  c parts of the transaction.
In Zcash, all SIGHASH types are extended to cover the Zcash-speci  c  elds nJoinSplit, vJoinSplit, and if present
joinSplitPubKey. These  elds are described in § 7.1 ‘Encoding of Transactions’ on p. 79. The hash does not cover
the   eld joinSplitSig.  After Overwinter activation, all SIGHASH types are also extended to cover transaction
elds introduced in that upgrade, and similarly after Sapling activation.
The original SIGHASH algorithm de  ned by Bitcoin suffered from some de  ciencies as described in [ZIP-143]; in
Zcash these are to be addressed by changing this algorithm as part of the Overwinter upgrade.
[Pre-Overwinter ] The SIGHASH algorithm used prior to Overwinter activation, i.e. for version 1 and 2 transac-
tions , will be de  ned in [ZIP-76] (to be written).
[Overwinter only, pre-Sapling ]  The SIGHASH  algorithm used after Overwinter activation and before Sapling
activation, i.e. for version 3 transactions , is de  ned in [ZIP-143].
[Sapling onward] The SIGHASH algorithm used after Sapling activation, i.e. for version 4 transactions , is de  ned
in [ZIP-243].
35




4.10                                                                                                                       Non-malleability (Sprout)
Let dataToBeSigned be the hash of the transaction, not associated with an input, using the SIGHASH_ALL SIGHASH
type .
In order to ensure that a JoinSplit description is cryptographically bound to the transparent inputs and outputs
corresponding to vpub  and vpudb, and to the other JoinSplit descriptions in the same transaction, an ephemeral
JoinSplitSig key pair is generated for each transaction, and the dataToBeSigned is signed with the private sign-
ing key of this key pair.  The corresponding public veri  cation key is included in the transaction encoding as
joinSplitPubKey.
JoinSplitSig is instantiated in § 5.4.5 ‘JoinSplit Signature’ on p. 60.
If nJoinSplit is zero, the joinSplitPubKey and joinSplitSig  elds are omitted. Otherwise, a transaction has a
correct JoinSplit signature if and only if JoinSplitSig.VerifyjoinSplitPubKey(dataToBeSigned, joinSplitSig) = 1.
Let hSig be computed as speci  ed in § 4.3 ‘JoinSplit Descriptions’ on p. 29.
Let PRFpk be as de  ned in § 4.1.2 ‘Pseudo Random Functions’ on p. 18.
For each i ∈ {1..Nold}, the creator of a JoinSplit description calculates hi  = PRFpo                                      (i, hSig ).
k,i
The correctness of h1..Nold  is enforced by the JoinSplit statement given in § 4.15.1 ‘Non-malleability’ on p. 41. This
ensures that a holder of all of the aold
sk,1..Nold  for every JoinSplit description in the transaction has authorized the use
of the private signing key corresponding to joinSplitPubKey to sign this transaction.
4.11                                                                                                                       Balance (Sprout)
In Bitcoin, all inputs to and outputs from a transaction are transparent. The total value of transparent outputs must
not exceed the total value of transparent inputs . The net value of transparent outputs minus transparent inputs is
transferred to the miner of the block containing the transaction; it is added to the miner subsidy in the coinbase
transaction of the block .
Zcash Sprout extends this by adding JoinSplit transfers . Each JoinSplit transfer can be seen, from the perspective
of the transparent value pool , as an input and an output simultaneously.
vpudb takes value from the transparent value pool and vpub adds value to the transparent value pool . As a result, vpudb
is treated like an output value, whereas vpub is treated like an input value.
Unlike original Zerocash [BCGGMTV2014], Zcash does not have a distinction between Mint and Pour operations.
The addition of vpudb to a JoinSplit description subsumes the functionality of both Mint and Pour.
Also, a difference in the number of real input notes does not by itself cause two JoinSplit descriptions to be dis-
tinguishable.
As stated in § 4.3 ‘JoinSplit Descriptions’ on p. 29, either vpudb or vpub MUST be zero. No generality is lost because,
if a transaction in which both vpudb and vpub  were nonzero were allowed, it could be replaced by an equivalent
one in which min(vpudb, vpub ) is subtracted from both of these values. This restriction helps to avoid unnecessary
distinctions between transactions according to client implementation.
36




4.12                                                                                                                       Balance and Binding Signature (Sapling)
Sapling adds Spend transfers and Output transfers to the transparent and JoinSplit transfers present in Sprout.
The net value of Spend transfers minus Output transfers in a transaction is called the balancing value , measured
in zatoshi as a signed integer vbalance.
vbalance is encoded explicitly in a transaction as the  eld valueBalance; see § 7.1 ‘Encoding of Transactions’ on p. 79.
A positive balancing value takes value from the Sapling value pool and adds it to the transparent value pool . A
negative balancing value does the reverse. As a result, positive vbalance is treated like an input to the transparent
value pool , whereas negative vbalance is treated like an output from that pool.
Consistency of vbalance with the value commitments in Spend descriptions and Output descriptions is enforced by
the binding signature . This signature has a dual rôle in the Sapling protocol:
•  To prove that the total value spent by Spend transfers , minus that produced by Output transfers , is consistent
with the vbalance   eld of the transaction;
•  To prove that the signer knew the randomness used for the spend and output value commitments , in order
to prevent Output descriptions from being replayed by an adversary in a different transaction.  (A Spend
description already cannot be replayed due to its spend authorization signature .)
Instead of generating a key pair at random, we generate it as a function of the value commitments in the Spend
descriptions and Output descriptions of the transaction, and the balancing value .
Let J(r) , J(r)∗, and rJ be as de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68.
Let ValueCommit, V , and R be as de  ned in § 5.4.7.3 ‘Homomorphic Pedersen commitments’ on p. 64:
{                                                                                                                          }
ValueCommit ◦ ValueCommit.Trapdoor ×                                                                                       −rJ 21 .. rJ 21                                       → ValueCommit.Output;
V ◦ J(r)∗ is the value base in ValueCommit;
R ◦ J(r)∗ is the randomness base in ValueCommit.
BindingSig,                                                                                                                                                                                                                                                                                                                                                                                                           , and    are instantiated in § 5.4.6.2 ‘Binding Signature’ on p. 63. These and the derived notation                                                                                                                        ,
N                                                                                                                                                                                N
,                                                                                                                          , and                                                                                                                                                                                                                                                                                      are speci  ed in § 4.1.6.2 ‘Signature with Private Key to Public Key Homomorphism’ on p. 22.
i=1                                                                                                                                                                              i=1
Suppose that the transaction has:
                                                                                                                                                                                 •  n Spend descriptions with value commitments cv1.d                                                                                                                                                                                                                                                                                             .n, committing to values v1.d.n with randomness rcv1.d.n;
                                                                                                                                                                                 •  m Output descriptions with value commitments cv1.w                                                                                                                                                                                                                                                                                            .m, committing to values v1.w.m with randomness rcv1.w.m;
•  balancing value vbalance.
                                                                                                                                                                                                                                                                                                                                                                                                                      ∑n                                                                                                    ∑m
                                                                                                                           In a correctly constructed transaction, vbalance  =                                                                                                                                                                                                                                        vild  −                                                                                                                                                                 vjew , but validators cannot check this directly
                                                                                                                                                                                                                                                                                                                                                                                                                      i=1                                                                                                   j=1
                                                                                                                                                                                 because the values are hidden by the commitments.
                                                                                                                                                                                                                                         Instead, validators calculate the transaction binding veri  cation key as:
                                                                                                                           ( n                                                   )                                                       (  m                                                                                )
                                                                                                                                                                                                                                                                                                                                                                                                                      (
bvk :=                                                                                                                     cvild                                                                                                         cvjew                                                                               ValueCommit0                                                                             vbalance).
                                                                                                                           i=1                                                                                                           j=1
                                                                                                                                                                                                                                         (This key is not encoded explicitly in the transaction and must be recalculated.)
The signer knows rcv1.d                                                                                                                                                                                                                                                                                                                     .n and rcv1.w.m, and so can calculate the corresponding signing key as:
                                                                                                                           ( n                                                   )                                                       ( m                                                                                 )
bsk :=                                                                                                                     rcvild                                                                                                        rcvjew
                                                                                                                           i=1                                                                                                           j=1
37




In order to check for implementation faults, the signer SHOULD also check that
bvk = BindingSig.DerivePublic(bsk).
Let SigHash be the SIGHASH transaction hash as de  ned in [ZIP-243], not associated with an input, using the
SIGHASH type SIGHASH_ALL.
A validator checks balance by verifying that BindingSig.Verifybvk (SigHash, bindingSig) = 1.
We now explain why this works.
A binding signature proves knowledge of the discrete logarithm bsk of bvk with respect to R. That is, bvk = [bsk] R.
So the value 0 and randomness bsk is an opening of the Pedersen commitment bvk = ValueCommitbsk (0). By the
binding property of the Pedersen commitment , it is infeasible to   nd another opening of this commitment to a
different value.
Similarly, the binding property of the value commitments in the Spend descriptions and Output descriptions
ensures that an adversary cannot  nd more than one opening for any of those commitments, i.e. we may assume
that v1.d                                                                                                                    .n and rcv1.d.n are determined by cv1.d.n, and that v1.w.m and rcv1.w.m are determined by cv1.w.m.
                                                                                                                                                                                                                                                                                              Using the fact that ValueCommitrcv (v) = [v] V                                                                                [rcv] R, the expression for bvk above is equivalent to:
                                                                                                                             [( n                                                                                                                                                             )                                                ( m                )                   ]                 [( n            )   ( m                                                       )]
bvk =                                                                                                                                                                                                                                                                                         vild                                                                vjew     vbalance   V                        rcvild       rcvjew                                                         R
                                                                                                                                                                                                                                                     i=1                                                                                       j=1                                                             i=1          j=1
                                                                                                                                                                                                                                                                                                                                                                                                               )
                                                                                                                                                                                                                                                                                                                                               ∑                           ∑
                                                                                                                                                                                                                                                     = ValueCommitbsk                                                                                             vild −              vjew − vbalance
                                                                                                                                                                                                                                                                                                                                               i=1                         j=1
                                                                                                                             ∑                                                                                                                                                                ∑
Let v∗  =                                                                                                                                                                                                                                            vild −                                                                                    vjew − vbalance.
                                                                                                                             i=1                                                                                                                                                              j=1
Suppose that v∗  = vbad  , 0  (mod rJ ). Then bvk = ValueCommitbsk (vbad ). If the adversary were able to   nd the dis-
crete logarithm of this bvk with respect to R, say bsk′ (as needed to create a valid binding signature ), then (vbad, bsk)
and (0, bsk′ ) would be distinct openings of bvk to different values, breaking the binding property of the value com-
mitment scheme .
                                                                                                                             The above argument{shows only th}t v∗  = 0  (mod rJ ); in order to show that v∗  = 0, we will also demonstrate that
it does not over  ow                                                                                                         −rJ 21 .. rJ 21
The Spend statements prove that all of v1.d                                                                                  .n are in {0 .. 2ℓvalue −1}. Similarly the Output statements prove that all of
                                                                                                                             m are in {0 .. 2ℓvalue −1}. vbalance is encoded in the transaction as a signed two’s complement 64-bit integer in the
                                                                                                                                                                                                                                                     )
                                                                                                                             maximum transaction size of 2 MB limits n to at most floor  2038400                                                     = 5208 and m to at most floo{  2094800   = 2}09,
                                                                                                                             ensuring v∗  ∈ {−38913406623490299131842 .. 96079866507916199586728} which is a subrange of                             −rJ 21 .. rJ 21
Thus checking the binding signature ensures that the transaction balances, without the individual values of the
Spend descriptions and Output descriptions being revealed.
In addition this proves that the signer, knowing the                                                                         -sum of the value commitment randomnesses, authorized
a transaction with the given SIGHASH transaction hash by signing SigHash.
Note:   The spender MAY reveal any strict subset of the value commitment randomnesses to other parties that
are cooperating to create the transaction. If all of the value commitment randomnesses are revealed, that could
allow replaying the Output descriptions of the transaction.
38




Non-normative note:   The technique of checking signatures using a public key derived from a sum of Pedersen
commitments is also used in the Mimblewimble protocol [Jedusor2016]. The private key bsk acts as a “synthetic
blinding factor ”, in the sense that it is synthesized from the other blinding factors (trapdoors) rcv1.d                  .n and rcv1.w.m;
this technique is also used in Bulletproofs [Dalek-notes].
4.13                                                                                                                       Spend Authorization Signature
SpendAuthSig is used in Sapling to prove knowledge of the spending key authorizing spending of an input note . It
is instantiated in § 5.4.6.1 ‘Spend Authorization Signature’ on p. 63.
Knowledge of the spending key could have been proven directly in the Spend statement , similar to the check in
§ 4.15.1 ‘Spend authority’ on p. 41 that is part of the JoinSplit statement . The motivation for a separate signature is
to allow devices that are limited in memory and computational capacity, such as hardware wallets, to authorize a
Sapling shielded spend. Typically such devices cannot create, and may not be able to verify, zk-SNARK proofs for
a statement of the size needed using the BCTV14 or Groth16 proving systems.
The verifying key of the signature must be revealed in the Spend description so that the signature can be checked
by validators. To ensure that the verifying key cannot be linked to the shielded payment address or spending key
from which the note was spent, we use a signature scheme with re-randomizable keys .  The Spend statement
proves that this verifying key is a re-randomization of the spend authorization address key ak with a randomizer
known to the signer. The spend authorization signature is over the SIGHASH transaction hash, so that it cannot
be replayed in other transactions .
Let SigHash be the SIGHASH transaction hash as de  ned in [ZIP-243], not associated with an input, using the
SIGHASH type SIGHASH_ALL.
Let ask be the spend authorization private key as de  ned in § 4.2.2 ‘Sapling Key Components’ on p. 27.
For each Spend description, the signer chooses a fresh spend authorization randomizer α:
1.  Choose α ←R  SpendAuthSig.GenRandom().
2.  Let rsk = SpendAuthSig.RandomizePrivate(α, ask).
3.  Let rk = SpendAuthSig.DerivePublic(rsk).
4.  Generate a proof πZKSpend of the Spend statement (§ 4.15.2 ‘Spend Statement (Sapling)’ on p. 42), with α in
the auxiliary input and rk in the primary input .
5.  Let spendAuthSig = SpendAuthSig.Signrsk (SigHash).
The resulting spendAuthSig and πZKSpend are included in the Spend description.
Note:   If the spender is computationally or memory-limited, step 4 (and only step 4) MAY be delegated to a differ-
ent party that is capable of performing the zk proof . In this case privacy will be lost to that party since it needs ak
and the proof authorizing key nsk; this allows also deriving the nk component of the full viewing key . Together ak
and nk are suf  cient to recognize spent notes and to recognize and decrypt incoming notes . However, the other
party will not obtain spending authority for other transactions , since it is not able to create a spend authorization
signature by itself.
39




4.14                                                                                                                           Note Commitments and Nulli  ers
A transaction that contains one or more JoinSplit descriptions or Spend descriptions , when entered into the block
chain, appends to the note commitment tree with all constituent note commitments .
All of the constituent nulli  ers are also entered into the nulli  er set of the associated treestate . A transaction is
not valid if it would have added a nulli  er to the nulli  er set that already exists in the set (see § 3.8 ‘Nullifier Sets’
on p. 17).
In Sprout, each note has a ρ component.
In Sapling, each positioned note has an associated ρ value which is computed from its note commitment cm and
note position pos as follows:
ρ := MixingPedersenHash(cm, pos).
MixingPedersenHash is de  ned in § 5.4.1.8 ‘Mixing Pedersen Hash Function’ on p. 56.
Let PRFnf and PRFnfSapling be as instantiated in § 5.4.2 ‘Pseudo Random Functions’ on p. 57.
For a Sprout note , the nulli  er is derived as PRFaf                                                                          (ρ), where ask is the spending key associated with the note .
sk
(ρ⋆), where nk⋆ is a representation of the nulli  er deriving
⋆
key associated with the note and ρ⋆ = reprJ (ρ).
40




4.15                                                                                                                  Zk-SNARK Statements
4.15.1                                                                                                                JoinSplit Statement (Sprout)
                                                                                                                      Let ℓMerkleSprout, ℓPRFSprout, MerkleDepthSprout, ℓvalue, ℓa   , ℓϕ, ℓhSig , Nold, Nnew be as de  ned in § 5.3 ‘Constants’ on p. 50.
sk
Let PRFaddr , PRFnf , PRFpk , and PRFρ be as de  ned in § 4.1.2                                                       ‘Pseudo Random Functions’ on p. 18.
Let NoteCommitSprout be as de  ned in § 4.1.7 ‘Commitment’ on p. 23, and let NoteSprout and NoteCommitmentSprout be
as de  ned in § 3.2 ‘Notes’ on p. 12.
A valid instance of πZKJoinSplit assures that given a primary input :
(
rt ◦   B[ℓMerkleSprout ],
                                                                                                                      ◦                                                              [ℓPRFSprout ][Nold ]
nfold                                                                                                                 ◦   B                                                                                                                                  ,
1..Nold
cm1.w
.Nnew  ◦   NoteCommitSprout.Output[Nnew ],
vpudb  ◦   {0 .. 2ℓvalue −1},
vpub  ◦ {0 .. 2ℓvalue −1},
hSig  ◦   B[ℓhSig ],
h1..Nold  ◦   B[ℓPRFSprout ][Nold ]),
the prover knows an auxiliary input :
(
path1..Nold  ◦   B[ℓMerkleSprout ][MerkleDepthSprout ][Nold ],
pos1..Nold  ◦   {0 .. 2MerkleDepthSprout −1}[Nold ],
◦
nold                                                                                                                                                                                 ◦   N                                                                                                oteSprout[Nold ],
                                                                                                                      1..Nold
                                                                                                                                                                                     ◦                                                                       [ℓa                          ][Nold ]
aold                                                                                                                                                                                 ◦   B                                                                                                sk                  ,
sk,1..Nold
n1.w
.Nnew  ◦   NoteSprout[Nnew ],
ϕ ◦ B[ℓϕ ],
enforceMerklePath1..Nold  ◦ B[Nold ]),
where:
for each i ∈ {1..Nold}: nild  = (apkd                                                                                 ,i, vild, ρild, rcmild );
for each i ∈ {1..Nnew }: niew  = (apk,
i, view , ρiew , rcmiew )
such that the following conditions hold:
Merkle path validity   for each i ∈ {1..Nold} | enforceMerklePathi  =                                                 1: (pathi, posi ) is a valid Merkle path (see § 4.8
‘Merkle path validity’ on p. 34) of depth MerkleDepthSprout from NoteCommitmentSprout (nild ) to the anchor rt.
Note: Merkle path validity covers conditions 1. (a) and 1. (d) of the NP statement in [BCGGMTV2014, section 4.2].
Merkle path enforcement   for each i ∈ {1..Nold}, if vild  , 0 then enforceMerklePathi  = 1.
                                                                                                                      ∑Nold                                                          ∑Nnew
Balance   vpudb  +                                                                                                    vild  = vpub +                                                                                                                         view  ∈ {0 .. 2ℓvalue −1}.
                                                                                                                      i=1                                                            i=1
Nulli  er integrity   for each i ∈ {1..Nold}: nfild  = PRFno                                                          (ρild ).
k,i
Spend authority   for each i ∈ {1..Nold}: apkd                                                                        ,i  = PRFaodrl                                                 (0).
sk,i
Non-malleability   for each i ∈ {1..Nold}: hi  = PRFpo                                                                (i, hSig ).
k,i
Uniqueness of ρiew    for each i ∈ {1..Nnew }: ρiew  = PRFϕ (i, hSig ).
Note commitment integrity   for each i ∈ {1..Nnew }: cmiew  = NoteCommitmentSprout (niew ).
For details of the form and encoding of proofs, see § 5.4.9.1 ‘BCTV14’ on p. 70.
41




4.15.2                                                                                                            Spend Statement (Sapling)
Let ℓMerkleSapling , ℓPRFnfSapling , and ℓscalar be as de  ned in § 5.3 ‘Constants’ on p. 50.
Let ValueCommit and NoteCommitSapling be as speci  ed in § 4.1.7 ‘Commitment’ on p. 23.
Let SpendAuthSig be as de  ned in § 5.4.6.1 ‘Spend Authorization Signature’ on p. 63.
Let J, J(r) , reprJ, qJ, rJ, and hJ be as de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68.
Let ExtractJ(r)   ◦ J(r)  → B[ℓMerkleSapling ] be as de  ned in § 5.4.8.4 ‘Hash Extractor for Jubjub’ on p. 69.
Let H be as de  ned in § 4.2.2 ‘Sapling Key Components’ on p. 27.
A valid instance of πZKSpend assures that given a primary input :
(
rt ◦   B[ℓMerkleSapling ],
cvold  ◦   ValueCommit.Output,
nfold  ◦   B[ℓPRFnfSapling ],
)
rk ◦   SpendAuthSig.Public                                                                                        ,
the prover knows an auxiliary input :
(
path ◦ B[ℓMerkle ][MerkleDepthSapling ],
pos ◦ {0 .. 2MerkleDepthSapling −1},
gd  ◦ J,
pkd  ◦ J,
vold  ◦   {0 .. 2ℓvalue −1},
rcvold  ◦   {0 .. 2ℓscalar −1},
cmold  ◦ J,
rcmold  ◦ {0 .. 2ℓscalar −1},
α ◦ {0 .. 2ℓscalar −1},
ak ◦ SpendAuthSig.Public,
nsk ◦ {0 .. 2ℓscalar −1})
such that the following conditions hold:
Note commitment integrity   cmold  = NoteCommitSapoidg                                                                                                                                                                                                                                                                       (reprJ (gd ), reprJ (pkd ), vold ).
                                                                                                                                                                                                                                                                                                                       rcm
                                                                                                                                                                                                                                                                                                                                                                   Sapling
                                                                                                                                                                                                                 Merkle path validity   Either vold  = 0; or (path, pos) is a valid Merkle path of depth MerkleDepth                                                         , as de   ned
                                                                                                                  in § 4.8 ‘Merkle path validity’ on p. 34, from cmu  = ExtractJ(r) (cmold ) to the anchor rt.
Value commitment integrity   cvold  = ValueCommitrcvold (vold ).
Small order checks   gd and ak are not of small order, i.e. [hJ] gd  , OJ and [hJ] ak , OJ.
(ρ⋆) where
⋆
                                                                                                                  (                                                                                              )
nk⋆ = reprJ                                                                                                       [nsk] H
(
ρ⋆ = reprJ                                                                                                        MixingPedersenHash(cmold, pos)).
Spend authority   rk = SpendAuthSig.RandomizePublic(α, ak).
Diversi  ed address integrity   pkd  = [ivk] gd where
ivk = CRHivk (ak⋆, nk⋆)
ak⋆ = reprJ (ak).
For details of the form and encoding of Spend statement proofs, see § 5.4.9.2 ‘Groth16’ on p. 71.
42




Notes:
•  Public and auxiliary inputs MUST be constrained to have the types speci  ed.  In particular, see §A.3.3.2
‘Edwards [de]compression and validation’ on p. 126 for implementation of validity checks on compressed
representations of Jubjub curve points.
The ValueCommit.Output and SpendAuthSig.Public types also represent points, i.e. J.
•  In the Merkle path validity check, each layer does not check that its input bit sequence is a canonical encod-
ing (in {0 .. rS − 1}) of the integer from the previous layer .
•  It is not checked in the Spend statement that rk is not of small order. However, this is checked outside the
Spend statement , as speci  ed in § 4.4 ‘Spend Descriptions’ on p. 30.
•  It is not checked that rcvold  < rJ or that rcmold  < rJ.
•  SpendAuthSig.RandomizePublic(α, ak) = ak +[α] G. (G is as de  ned in § 5.4.6.1 ‘Spend Authorization Signature’
on p. 63.)
4.15.3                                                                                                              Output Statement (Sapling)
Let ℓMerkleSapling , ℓPRFnfSapling , and ℓscalar be as de  ned in § 5.3 ‘Constants’ on p. 50.
Let ValueCommit and NoteCommitSapling be as speci  ed in § 4.1.7 ‘Commitment’ on p. 23.
Let J, reprJ, and hJ be as de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68.
A valid instance of πZKOutput assures that given a primary input :
(
cvnew  ◦ ValueCommit.Output,
)
epk ◦ J                                                                                                             ,
the prover knows an auxiliary input :
(gd  ◦ J,
pk⋆d  ◦ B[ℓJ ],
vnew  ◦ {0 .. 2ℓvalue −1},
rcvnew  ◦ {0 .. 2ℓscalar −1},
rcmnew  ◦ {0 .. 2ℓscalar −1},
esk ◦ {0 .. 2ℓscalar −1})
such that the following conditions hold:
                                                                                                                                                                     (
                                                                                                                    Note commitment integrity   cmu  = ExtractJ(r)   NoteCommitSapniew         (g⋆d, pk⋆d, vnew )), where g⋆   d   = reprJ (gd ).
                                                                                                                                                                                         rcm
Value commitment integrity   cvnew  = ValueCommitrcvnew (vnew ).
Small order check   gd is not of small order, i.e. [hJ] gd  , OJ.
Ephemeral public key integrity   epk = [esk] gd.
For details of the form and encoding of Output statement proofs, see § 5.4.9.2 ‘Groth16’ on p. 71.
43




Notes:
•  Public and auxiliary inputs MUST be constrained to have the types speci  ed.  In particular, see §A.3.3.2
‘Edwards [de]compression and validation’ on p. 126 for implementation of validity checks on compressed
representations of Jubjub curve points.
The ValueCommit.Output type also represents points, i.e. J.
•  The validity of pk⋆d is not checked in this circuit.
•  It is not checked that rcvold  < rJ or that rcmold  < rJ.
4.16                                                                                                                     In-band secret distribution (Sprout)
In Sprout, the secrets that need to be transmitted to a recipient of funds in order for them to later spend, are v, ρ,
and rcm. A memo   eld (§ 3.2.1 ‘Note Plaintexts and Memo Fields’ on p. 13) is also transmitted.
To transmit these secrets securely to a recipient without requiring an out-of-band communication channel, the
transmission key pkenc is used to encrypt them. The recipient’s possession of the associated incoming viewing key
ivk is used to reconstruct the original note and memo   eld .
A single ephemeral public key is shared between encryptions of the Nnew shielded outputs in a JoinSplit descrip-
tion. All of the resulting ciphertexts are combined to form a transmitted notes ciphertext .
For both encryption and decryption,
•  let Sym be the scheme instantiated in § 5.4.3 ‘Authenticated One-Time Symmetric Encryption’ on p. 58;
•  let KDFSprout be the Key Derivation Function instantiated in § 5.4.4.2 ‘Sprout Key Derivation’ on p. 59;
•  let KASprout be the key agreement scheme instantiated in § 5.4.4.1 ‘Sprout Key Agreement’ on p. 59;
•  let hSig be the value computed for this JoinSplit description in § 4.3 ‘JoinSplit Descriptions’ on p. 29.
4.16.1                                                                                                                   Encryption (Sprout)
Let KASprout be the key agreement scheme instantiated in § 5.4.4.1 ‘Sprout Key Agreement’ on p. 59.
Let pkenc
,1..Nnew  be the transmission keys for the intended recipient addresses of each new note .
Let np1..Nnew  be Sprout note plaintexts de  ned in § 5.5 ‘Encodings of Note Plaintexts and Memo Fields’ on p. 72.
Then to encrypt:
•  Generate a new KASprout (public, private) key pair (epk, esk).
•  For i ∈ {1..Nnew },
-  Let Pinc be the raw encoding of npi.
-  Let sharedSecreti  := KASprout.Agree(esk, pkenc                                                                       ,i ).
–  Let Kinc  := KDFSprout (i, hSig , sharedSecreti, epk, pkenc                                                                                                  ,i ).
–  Let Cinc  := Sym.EncryptKenc                                                                                          (Pinc ).
i
..Nnew ).
Note:   It is technically possible to replace Cinc for a given note with a random (and undecryptable) dummy ci-
phertext, relying instead on out-of-band transmission of the note to the recipient. In this case the ephemeral key
MUST still be generated as a random public key (rather than a random bit sequence) to ensure indistinguishability
from other JoinSplit descriptions . This mode of operation raises further security considerations, for example of
how to validate a Sprout note received out-of-band, which are not addressed in this document.
44




4.16.2                                                                                                                            Decryption (Sprout)
Let ivk = (apk , skenc ) be the recipient’s incoming viewing key , and let pkenc be the corresponding transmission key
derived from skenc as speci  ed in § 4.2.1 ‘Sprout Key Components’ on p. 27.
Let cm1.w
.Nnew  be the note commitments of each output coin.
Then for each i ∈ {1..Nnew }, the recipient will attempt to decrypt that ciphertext component (epk, Cinc ) as follows:
let sharedSecreti  = KASprout.Agree(skenc, epk)
let Kinc  = KDFSprout (i, hSig , sharedSecreti, epk, pkenc )
return DecryptNoteSprout(Kinc, Cinc, cmiew , apk ).
DecryptNoteSprout(Kinc, Cinc, cmiew , apk ) is de  ned as follows:
let Pinc  = Sym.DecryptKenc                                                                                                       (Cinc )
i
if Pinc  = ⊥, return ⊥
extract npi  = (view  ◦ {0 .. 2ℓvalue −1}, ρiew  ◦ B[ℓPRFSprout ], rcmiew  ◦ NoteCommitSprout.Trapdoor, memoi  ◦ BY[512] ) from
Pinc
if NoteCommitmentSprout ((apk , view , ρiew , rcmiew )) , cmiew , return ⊥, else return npi.
To test whether a note is unspent in a particular block chain also requires the spending key ask ; the coin is unspent
if and only if nf = PRFaf                                                                                                         (ρ) is not in the nulli  er set for that block chain.
sk
Notes:
•  The decryption algorithm corresponds to step 3 (b) i. and ii. (  rst bullet point) of the Receive algorithm shown
in [BCGGMTV2014, Figure 2].
•  A note can change from being unspent to spent as a node’s view of the best block chain is extended by new
transactions . Also, block chain reorganizations can cause a node to switch to a different best block chain
that does not contain the transaction in which a note was output.
See § 8.7 ‘In-band secret distribution’ on p. 95 for further discussion of the security and engineering rationale be-
hind this encryption scheme.
4.17                                                                                                                              In-band secret distribution (Sapling)
In Sapling, the secrets that need to be transmitted to a recipient of funds in order for them to later spend, are d, v,
and rcm. A memo   eld (§ 3.2.1 ‘Note Plaintexts and Memo Fields’ on p. 13) is also transmitted.
To transmit these secrets securely to a recipient without requiring an out-of-band communication channel, the
diversi  ed transmission key pkd is used to encrypt them. The recipient’s possession of the associated incoming
viewing key ivk is used to reconstruct the original note and memo   eld .
Unlike in a Sprout JoinSplit description, each Sapling shielded output is encrypted using a fresh ephemeral public
key.
For both encryption and decryption,
•  let ℓovk be as de  ned in § 5.3 ‘Constants’ on p. 50;
•  let Sym be the scheme instantiated in § 5.4.3 ‘Authenticated One-Time Symmetric Encryption’ on p. 58;
•  let KDFSapling be the Key Derivation Function instantiated in § 5.4.4.4 ‘Sapling Key Derivation’ on p. 60;
•  let KASapling be the key agreement scheme instantiated in § 5.4.4.3 ‘Sapling Key Agreement’ on p. 59;
•  let ℓJ and reprJ be as de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68;
•  let ExtractJ(r)  be as de  ned in § 5.4.8.4 ‘Hash Extractor for Jubjub’ on p. 69;
•  let PRFock be as instantiated in § 5.4.2 ‘Pseudo Random Functions’ on p. 57.
45




4.17.1                                                                                                                     Encryption (Sapling)
Let pkdew  ◦ KASapling .PublicPrimeOrder be the diversi  ed transmission key for the intended recipient address of a
new Sapling note , and let gdew  ◦ KASapling .PublicPrimeOrder be the corresponding diversi  ed base computed as
DiversifyHash(d).
Since Sapling note encryption is used only in the context of § 4.6.2 ‘Sending Notes (Sapling)’ on p. 32, we may
assume that gdew has already been calculated and is not ⊥.
Let ovk ◦ BY[ℓovk /8] ∪ {⊥} be as described in § 4.6.2 ‘Sending Notes (Sapling)’ on p. 32, i.e. the outgoing viewing key
of the shielded payment address from which the note is being spent, or an outgoing viewing key associated with
a [ZIP-32] account, or ⊥.
Let np = (d, v, rcm, memo) be the Sapling note plaintext .
np is encoded as de  ned in § 5.5 ‘Encodings of Note Plaintexts and Memo Fields’ on p. 72.
Let cvnew be the value commitment for the new note , and let cmnew be the note commitment .
Then to encrypt:
choose a uniformly random ephemeral private key esk ←R  KASapling .Private \ {0}
let epk = KASapling .DerivePublic(esk, gdew )
let Penc be the raw encoding of np
let sharedSecret = KASapling .Agree(esk, pkdew )
let Kenc  = KDFSapling (sharedSecret, epk)
let Cenc  = Sym.EncryptKenc (Penc )
if ovk = ⊥:
choose random ock ←R  Sym.K and op ←R  BY[(ℓJ +256)/8]
else:
(
reprJ (cvnew ))
let cv = LEBS2OSPℓJ
                                                                                                                           (
let cmu = LEBS2OSP256                                                                                                      ExtractJ(r) (cmnew ))
                                                                                                                           (                                                    )
reprJ (epk)
let ephemeralKey = LEBS2OSPℓJ
let ock = PRFovk (cv, cmu, ephemeralKey)
(
reprJ (pkdew )  || I2LEBSP256 (esk))
let op = LEBS2OSPℓJ +256
let Cout  = Sym.Encryptock (op)
The resulting transmitted note ciphertext is (epk, Cenc, Cout ).
Note:   It is technically possible to replace Cenc for a given note with a random (and undecryptable) dummy ci-
phertext, relying instead on out-of-band transmission of the note to the recipient. In this case the ephemeral key
MUST still be generated as a random public key (rather than a random bit sequence) to ensure indistinguishability
from other Output descriptions .  This mode of operation raises further security considerations, for example of
how to validate a Sapling note received out-of-band, which are not addressed in this document.
4.17.2                                                                                                                     Decryption using an Incoming Viewing Key (Sapling)
Let ivk  ◦  {0 .. 2ℓivk −1} be the recipient’s incoming viewing key , as speci  ed in § 4.2.2 ‘Sapling Key Components’
on p. 27.
Let (epk, Cenc, Cout ) be the transmitted note ciphertext from the Output description.  Let cmu be that   eld of the
Output description (encoding the u-coordinate of the note commitment ).
46




The recipient will attempt to decrypt the epk and Cenc components of the transmitted note ciphertext as follows:
let sharedSecret = KASapling .Agree(ivk, epk)
let Kenc  = KDFSapling (sharedSecret, epk)
let Penc  = Sym.DecryptKenc (Cenc )
if Penc  = ⊥, return ⊥
extract np = (d ◦ B[ℓd ], v ◦ {0 .. 2ℓvalue −1}, rcm ◦ BY[32], memo ◦ BY[512] ) from Penc
                                                                                                                                                                                                            (                                                                 )
let rcm = LEOS2IP256                                                                                                                                                                                        rcm                                                               and gd  = DiversifyHash(d)
                                                                                                                         if rcm ≥ rJ or gd  = ⊥, return ⊥
                                                                                                                         let pkd  = KASapling .DerivePublic(ivk, gd )
                                                                                                                                                                                                            (                                                                                                                                                                                                                                                                                                 )
let cm′                                                                                                                  u  = ExtractJ(r)                                                                   NoteCommitSapniew                                                                                                        (reprJ (gd ), reprJ (pkd ), v)
                                                                                                                                                                                                                                                                                                                 rcm
                                                                                                                                                                         (                                  )
if LEBS2OSP256                                                                                                                                                           cm′                                u                                                                 , cmu, return ⊥, else return np.
                                                                                                                                                                                                                                                                                                                                                                        A received Sapling note is necessarily a positioned note , and so its ρ value can immediately be calculated as
                                                                                                                                                                                                            described in § 4.14 ‘Note Commitments and Nullifiers’ on p. 40.
                                                                                                                                                                                                                                                                                                                                                                        To test whether a Sapling note is unspent in a particular block chain also requires the nulli  er deriving key nk⋆;
                                                                                                                                                                                                                                                                                                                                                                        (                                                                                                                                 )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              reprJ (ρ)           is not in the nulli  er set for that block chain.
⋆
Note:   A note can change from being unspent to spent as a node’s view of the best block chain is extended by
new transactions . Also, block chain reorganizations can cause a node to switch to a different best block chain that
does not contain the transaction in which a note was output.
4.17.3                                                                                                                   Decryption using a Full Viewing Key (Sapling)
Let ovk ◦ BY[ℓovk /8] be the outgoing viewing key , as speci  ed in § 4.2.2 ‘Sapling Key Components’ on p. 27, that is
to be used for decryption. (If ovk = ⊥ was used for encryption, the payment is not decryptable by this method.)
Let (epk, Cenc, Cout ) be the transmitted note ciphertext , and let cv, cmu, and ephemeralKey be those   elds of the
Output description (encoding the value commitment , the u-coordinate of the note commitment , and epk).
The outgoing viewing key holder will attempt to decrypt the transmitted note ciphertext as follows:
let ock = PRFovk (cv, cmu, ephemeralKey)
let op = Sym.Decryptock (Cout )
if op = ⊥, return ⊥
extract (pk⋆d  ◦ B[ℓJ ], esk ◦ BY[32] ) from op
                                                                                                                         (                                               )
let esk = LEOS2IP256                                                                                                     esk                                             and pkd  = abstJ (pk⋆d )
if esk ≥ rJ or pkd  < KASapling .PublicPrimeOrder, return ⊥
let sharedSecret = KASapling .Agree(esk, pkd )
let Kenc  = KDFSapling (sharedSecret, epk)
let Penc  = Sym.DecryptKenc (Cenc )
if Penc  = ⊥, return ⊥
extract np = (d ◦ B[ℓd ], v ◦ {0 .. 2ℓvalue −1}, rcm ◦ BY[32], memo ◦ BY[512] ) from Penc
                                                                                                                                                                                                                                                                              (                                  )
                                                                                                                         let rcm = LEOS2IP256                                                                                                                                 rcm                                                    and gd  = DiversifyHash(d)
                                                                                                                                                                         if rcm ≥ rJ or gd  = ⊥, return ⊥
                                                                                                                                                                                                            if KASapling .DerivePublic(esk, gd ) , epk, return ⊥
                                                                                                                                                                                                                                                                              (                                                                                                                                                                                                               )
let cm′                                                                                                                  u  = ExtractJ(r)                                                                                                                                                                        NoteCommitSapniew                                      (reprJ (gd ), reprJ (pkd ), v)
                                                                                                                                                                                                                                                                                                                                     rcm
                                                                                                                                                                                                            (                                                                 )
if LEBS2OSP256                                                                                                                                                                                              cm′                                                               u                                                      , cmu, return ⊥, else return np.
47




(                                                                                                                               )
reprJ (epk)
Note:   For a valid transaction it must be the case that ephemeralKey = LEBS2OSPℓJ
4.18                                                                                                                            Block Chain Scanning (Sprout)
The following algorithm can be used, given the block chain and a Sprout spending key ask , to obtain each note
sent to the corresponding shielded payment address , its memo   eld   eld, and its   nal status (spent or unspent).
Let ℓPRFSprout be as de  ned in § 5.3 ‘Constants’ on p. 50.
Let NoteSprout be as de  ned in § 3.2 ‘Notes’ on p. 12.
Let ivk = (apk  ◦ B[ℓPRFSprout ], skenc  ◦ KASprout.Private) be the incoming viewing key corresponding to ask , and let pkenc
be the associated transmission key , as speci  ed in § 4.2.1 ‘Sprout Key Components’ on p. 27.
Initialize ReceivedSet ◦ P(NoteSprout × BY[512]) = {}.
Initialize SpentSet ◦ P(NoteSprout) = {}.
Initialize NullifierMap ◦ B[ℓPRFSprout ]  → NoteSprout to the empty mapping.
For each transaction tx,
For each JoinSplit description in tx,
..Nnew ) be the transmitted notes ciphertext of the JoinSplit description.
For i in 1..Nnew ,
Attempt to decrypt the transmitted note ciphertext component (epk, Cinc ) using ivk with the
algorithm in § 4.16.2 ‘Decryption (Sprout)’ on p. 45. If this succeeds giving np:
Extract n and memo ◦ BY[512] from np (taking the apk   eld of the note to be apk from ivk).
Add (n, memo) to ReceivedSet.
Calculate the nulli  er nf of n using ask as described in § 3.2 ‘Notes’ on p. 12.
Add the mapping nf → n to NullifierMap.
Let nf 1..Nold  be the nulli  ers of the JoinSplit description.
For i in 1..Nold,
If nfi is present in NullifierMap, add NullifierMap(nfi ) to SpentSet.
Return (ReceivedSet, SpentSet).
4.19                                                                                                                            Block Chain Scanning (Sapling)
In Sapling, block chain scanning requires only the nk and ivk key components, rather than a spending key as in
Sprout.
Typically, these components are derived from a full viewing key as described in § 4.2.2 ‘Sapling Key Components’
on p. 27.
The following algorithm can be used, given the block chain and (nk ◦ J(r) , ivk ◦ {0 .. 2ℓivk −1}), to obtain each note
sent to the corresponding shielded payment address , its memo   eld   eld, and its   nal status (spent or unspent).
Let ℓPRFnfSapling be as de  ned in § 5.3 ‘Constants’ on p. 50.
Let NoteSapling be as de  ned in § 3.2 ‘Notes’ on p. 12.
48




Initialize ReceivedSet ◦ P(NoteSapling × BY[512]) = {}.
Initialize SpentSet ◦ P(NoteSapling ) = {}.
Initialize NullifierMap ◦ B[ℓPRFnfSapling ]  → NoteSapling to the empty mapping.
For each transaction tx,
For each Output description in tx with note position pos,
Attempt to decrypt the transmitted note ciphertext components epk and Cenc using ivk with the algorithm
in § 4.17.2 ‘Decryption using an Incoming Viewing Key (Sapling)’ on p. 46. If this succeeds giving np:
Extract n and memo ◦ BY[512] from np.
Add (n, memo) to ReceivedSet.
Calculate the nulli  er nf of n using nk and pos as described in § 3.2 ‘Notes’ on p. 12.
Add the mapping nf → n to NullifierMap.
For each Spend description in tx,
Let nf be the nulli  er of the Spend description.
If nf is present in NullifierMap, add NullifierMap(nf ) to SpentSet.
Return (ReceivedSet, SpentSet).
Non-normative notes:
•  The above algorithm does not use the ovk key component, or the Cout transmitted note ciphertext compo-
nent. When scanning the whole block chain, these are indeed not necessary. The advantage of supporting
decryption using ovk as described in § 4.17.3 ‘Decryption using a Full Viewing Key (Sapling)’ on p. 47, is
that it allows recovering information about the note plaintexts sent in a transaction from that transaction
alone.
•  When scanning only part of a block chain, it may be useful to augment the above algorithm with decryption
of Cout components for each transaction, in order to obtain information about notes that were spent in the
scanned period but received outside it.
•  The above algorithm does not detect notes that were sent “out-of-band” or with incorrect transmitted note
ciphertexts . It is possible to detect whether such notes were spent only if their nulli  ers are known.
5                                                                                                                      Concrete Protocol
5.1                                                                                                                    Caution
TODO: Explain the kind of things that can go wrong with linkage between abstract and concrete protocol. E.g.  § 8.5
‘Internal hash collision attack and fix’ on p. 93
5.2                                                                                                                    Integers, Bit Sequences, and Endianness
All integers in Zcash-speci  c encodings are unsigned, have a  xed bit length, and are encoded in little-endian byte
order unless otherwise specified.
The following functions convert between sequences of bits, sequences of bytes, and integers:
◦
•  I2LEBSP  ◦                                                                                                          (ℓ                                        ◦     N) × {0 .. 2ℓ −1}  → B[ℓ], such that I2LEBSPℓ (x) is the sequence of ℓ bits representing x in
                                                                                                                       little-endian order;
49




•  I2BEBSP  ◦  (ℓ  ◦  N) × {0 .. 2ℓ −1}  → B[ℓ] such that I2BEBSPℓ (x) is the sequence of ℓ bits representing x in
big-endian order.
•  LEBS2IP ◦ (ℓ ◦ N) × B[ℓ]  → {0 .. 2ℓ −1} such that LEBS2IPℓ (S ) is the integer represented in little-endian order
by the bit sequence S of length ℓ.
•  LEOS2IP  ◦  (ℓ  ◦ N | ℓ mod 8 = 0) × BY[ℓ/8]  → {0 .. 2ℓ −1} such that LEOS2IPℓ (S ) is the integer represented in
little-endian order by the byte sequence S of length ℓ/8.
•  LEBS2OSP ◦ (ℓ ◦ N) ×B[ℓ]  → BY[ceiling(ℓ/8)] de  ned as follows: pad the input on the right with 8 ·ceiling (ℓ/8) −ℓ
zero bits so that its length is a multiple of 8 bits. Then convert each group of 8 bits to a byte value with the
least signi  cant bit   rst, and concatenate the resulting bytes in the same order as the groups.
•  LEOS2BSP ◦ (ℓ ◦ N | ℓ mod 8 = 0) × BY[ceiling(ℓ/8)]  → B[ℓ] de  ned as follows: convert each byte to a group of 8
bits with the least signi  cant bit   rst, and concatenate the resulting groups in the same order as the bytes.
In bit layout diagrams, each box of the diagram represents a sequence of bits.  Diagrams are read from left-to-
right, with lines read from top-to-bottom; the breaking of boxes across lines has no signi  cance. The bit length ℓ
is given explicitly in each box, except when it is obvious (e.g. for a single bit, or for the notation [0]ℓ representing
the sequence of ℓ zero bits, or for the output of LEBS2OSPℓ).
The entire diagram represents the sequence of bytes formed by  rst concatenating these bit sequences, and then
treating each subsequence of 8 bits as a byte with the bits ordered from most significant to least significant. Thus
the most significant bit in each byte is toward the left of a diagram. (This convention is used only in descriptions of
the Sprout design; in the Sapling additions, bit/byte sequence conversions are always speci                                ed explicitly.) Where
bit   elds are used, the text will clarify their position in each case.
5.3                                                                                                                        Constants
De  ne:
MerkleDepthSprout  ◦ N := 29
MerkleDepthSapling  ◦ N :=                                                                                                 32
Nold  ◦ N := 2
Nnew  ◦ N := 2
ℓvalue  ◦   N := 64
ℓMerkleSprout  ◦   N := 256
ℓMerkleSapling  ◦   N := 255
ℓhSig  ◦   N := 256
ℓPRFSprout  ◦ N := 256
ℓPRFexpand  ◦ N := 512
ℓPRFnfSapling  ◦   N := 256
ℓrcm  ◦ N := 256
ℓSeed  ◦   N := 256
◦
ℓa                                                                                                                         ◦   N                   := 252
sk
ℓϕ  ◦ N := 252
ℓsk  ◦   N := 256
ℓd  ◦   N := 88
ℓivk  ◦   N := 251
ℓovk  ◦   N := 256
50




ℓscalar  ◦   N := 252
UncommittedSprout  ◦ B[ℓMerkleSprout ]  := [0]ℓMerkleSprout
UncommittedSapling  ◦ B[ℓMerkleSapling ]  := I2LEBSPℓ                                                                   (1)
MerkleSapling
MAX_MONEY ◦ N := 2.1·1015 (zatoshi )
SlowStartInterval ◦ N := 20000
HalvingInterval ◦ N := 840000
MaxBlockSubsidy ◦ N := 1.25·109 (zatoshi )
NumFounderAddresses ◦ N := 48
FoundersFraction ◦ Q := 5
{
2243 − 1,  for the production network
PoWLimit ◦ N :=
2251 − 1,  for the test network
PoWAveragingWindow ◦ N := 17
PoWMedianBlockSpan ◦ N := 11
00
00
PoWDampingFactor ◦ N := 4
PoWTargetSpacing ◦ N := 150 (seconds).
5.4                                                                                                                     Concrete Cryptographic Schemes
5.4.1                                                                                                                   Hash Functions
5.4.1.1                                                                                                                 SHA-256 and SHA256Compress Hash Functions
SHA-256 is de  ned by [NIST2015].
Zcash uses the full SHA-256 hash function to instantiate NoteCommitmentSprout.
SHA-256 ◦ BY[N]  → BY[32]
[NIST2015] strictly speaking only speci  es the application of SHA-256 to messages that are bit sequences, produc-
ing outputs (“message digests”) that are also bit sequences. In practice, SHA-256 is universally implemented with
a byte-sequence interface for messages and outputs, such that the most significant bit of each byte corresponds
to the   rst bit of the associated bit sequence. (In the NIST speci  cation “  rst” is con  ated with “leftmost”.)
Zcash also uses the SHA-256 compression function, SHA256Compress. This operates on a single 512-bit block and
excludes the padding step speci  ed in [NIST2015, section 5.1].
That is, the input to SHA256Compress is what [NIST2015, section 5.2] refers to as “the message and its padding”. The
Initial Hash Value is the same as for full SHA-256.
SHA256Compress is used to instantiate several Pseudo Random Functions and MerkleCRHSprout.
SHA256Compress ◦ B[512]  → B[256]
The ordering of bits within words in the interface to SHA256Compress is consistent with [NIST2015, section 3.1], i.e.
big-endian.
51




5.4.1.2                                                                                                                                    BLAKE2 Hash Function
BLAKE2 is de  ned by [ANWW2013].  Zcash uses both the BLAKE2b and BLAKE2s variants.
BLAKE2b-ℓ(p, x) refers to unkeyed BLAKE2b-ℓ in sequential mode, with an output digest length of ℓ/8 bytes, 16-
byte personalization string p, and input x.
BLAKE2b is used to instantiate hSigCRH, EquihashGen, and KDFSprout. From Overwinter onward, it is used to com-
pute SIGHASH transaction hashes as speci  ed in [ZIP-143], or as in [ZIP-243] after Sapling activation. For Sapling,
it is also used to instantiate PRFexpand, PRFock , KDFSapling , and in the RedJubjub signature scheme which instantiates
SpendAuthSig and BindingSig.
BLAKE2b-ℓ ◦ BY[16] × BY[N]  → BY[ℓ/8]
Note:   BLAKE2b-ℓ is not the same as BLAKE2b-512 truncated to ℓ bits, because the digest length is encoded in the
parameter block.
BLAKE2s-ℓ(p, x) refers to unkeyed BLAKE2s-ℓ in sequential mode, with an output digest length of ℓ/8 bytes, 8-byte
personalization string p, and input x.
BLAKE2s is used to instantiate PRFnfSapling , CRHivk , and GroupHashJ(r)∗ .
BLAKE2s-ℓ ◦ BY[8] × BY[N]  → BY[ℓ/8]
5.4.1.3                                                                                                                                    Merkle Tree Hash Function
MerkleCRHSprout and MerkleCRHSapling are used to hash incremental Merkle tree hash values for Sprout and Sapling
respectively.
MerkleCRHSprout Hash Function
Let SHA256Compress be as speci  ed in § 5.4.1.1 ‘SHA-256 and SHA256Compress Hash Functions’ on p. 51.
MerkleCRHSprout  ◦ {0 .. MerkleDepthSprout − 1} × B[ℓMerkleSprout ] × B[ℓMerkleSprout ]  → B[ℓMerkleSprout ] is de  ned as follows:
                                                                                                                                           (                                  )
MerkleCRHSprout (layer, left, right) := SHA256Compress                                                                                     256-bit left                       256-bit right
Security requirement:   SHA256Compress must be collision-resistant , and it must be infeasible to  nd a preimage
x such that SHA256Compress(x) = [0]256.
Notes:
•  The layer argument does not affect the output.
•  SHA256Compress is not the same as the SHA-256 function, which hashes arbitrary-length byte sequences.
MerkleCRHSapling Hash Function
Let PedersenHash be as speci  ed in § 5.4.1.7 ‘Pedersen Hash Function’ on p. 54.
MerkleCRHSapling  ◦ {0 .. MerkleDepthSapling − 1} × B[ℓMerkleSapling ] × B[ℓMerkleSapling ]  → B[ℓMerkleSapling ] is de  ned as follows:
MerkleCRHSapling (layer, left, right) := PedersenHash(“Zcash_PH”, l || left || right)
(
where l = I2LEBSP6                                                                                                                         MerkleDepthSapling − 1 − layer).
Security requirement:   PedersenHash must be collision-resistant .
Note:   The pre  x l provides domain separation between inputs at different layers of the note commitment tree .
NoteCommitSapling , like PedersenHash, is de  ned in terms of PedersenHashToPoint, but using a pre  x that cannot
collide with a layer pre  x, as noted in § 5.4.7.2 ‘Windowed Pedersen commitments’ on p. 64.
52




5.4.1.4
hSig Hash Function
hSigCRH is used to compute the value hSig in § 4.3 ‘JoinSplit Descriptions’ on p. 29.
                                                                                                                                                                                                                                                     (                                                                                     )
hSigCRH(randomSeed, nfold                                                                                                                                                                                                                                                                “ZcashComputehSig”, hSigInput
                                                                                                                                                                                                         1..Nold , joinSplitPubKey) := BLAKE2b-256
where
hSigInput :=                                                                                                                256-bit randomSeed                                                           256-bit nf1ld                               256-bit nfolo                       256-bit joinSplitPubKey
                                                                                                                                                                                                                                                                                         N ld
                                                                                                                            BLAKE2b-256(p, x) is de  ned in § 5.4.1.2 ‘BLAKE2 Hash Function’ on p. 52.
                                                                                                                                                                                                         (                                           )
                                                                                                                            Security requirement:   BLAKE2b-256                                          “ZcashComputehSig”, x                       must be collision-resistant on x.
5.4.1.5                                                                                                                     CRHivk Hash Function
CRHivk is used to derive the incoming viewing key ivk for a Sapling shielded payment address . For its use when
generating an address see § 4.2.2 ‘Sapling Key Components’ on p. 27, and for its use in the Spend statement see
§ 4.15.2 ‘Spend Statement (Sapling)’ on p. 42.
It is de  ned as follows:
CRHivk (ak⋆, nk⋆) := LEOS2IP256(BLAKE2s-256(“Zcashivk”, crhInput)) mod 2ℓivk
where
crhInput :=                                                                                                                 LEBS2OSP256 (ak⋆)                                                            LEBS2OSP256 (nk⋆)
                                                                                                                            BLAKE2b-256(p, x) is de  ned in § 5.4.1.2 ‘BLAKE2 Hash Function’ on p. 52.
                                                                                                                            (                                                                            (                                           ))
Security requirement:   LEOS2IP256                                                                                          BLAKE2s-256                                                                  “Zcashivk”, x                                                                   mod 2ℓivk  must be collision-resistant on a 64-
byte input x. Note that this does not follow from collision resistance of BLAKE2s-256 (and the best possible con-
crete security is that of a 251-bit hash rather than a 256-bit hash), but it is a reasonable assumption given the design,
structure, and cryptanalysis to date of BLAKE2s.
Non-normative note:   BLAKE2s has a variable output digest length feature, but it does not support arbitrary
bit lengths, otherwise it would have been used rather than external truncation. However, the protocol-speci  c
personalization string together with truncation achieve essentially the same effect as using that feature.
5.4.1.6                                                                                                                     DiversifyHash Hash Function
DiversifyHash is used to derive a diversi  ed base from a diversi  er in § 4.2.2 ‘Sapling Key Components’ on p. 27.
Let GroupHashJ(r)∗  and U be as de  ned in § 5.4.8.5 ‘Group Hash into Jubjub’ on p. 70.
De  ne
)
DiversifyHash(d) := GroupHashU(r)∗ (“Zcash_gd”, LEBS2OSP                                                                    ℓd (d)
Security requirement:   Unlinkability: Given two randomly selected shielded payment addresses from different
spend authorities, and a third shielded payment address which could be derived from either of those authorities,
such that the three addresses use different diversi  ers , it is not possible to tell which authority the third address
was derived from.
53




Non-normative notes:
•                                                                                                                    Suppose that GroupHashJ(r)∗  (restricted to inputs for which it does not return ⊥) is modelled as a random oracle
from diversi  ers to points of order rJ on the Jubjub curve . In this model, Unlinkability of DiversifyHash holds
under the Decisional Dif  e-Hellman assumption on the prime-order subgroup of the Jubjub curve .
To prove this, consider the ElGamal encryption scheme [ElGamal1985] on this prime-order subgroup, re-
stricted to encrypting plaintexts encoded as the group identity OJ.  (ElGamal was originally de  ned for Fp
but works in any prime-order group.) ElGamal public keys then have the same form as diversi  ed payment
addresses . If we make the assumption above on GroupHashJ(r)∗ , then generating a new diversi  ed payment
address from a given address pk, gives the same distribution of (gd′, pkd′ ) pairs as the distribution of ElGamal
ciphertexts obtained by encrypting OJ under pk. TODO: check whether this is justified. Then, the de  nition of
key privacy (IK-CPA as de  ned in [BBDP2001, De  nition 1]) for ElGamal corresponds to the de  nition of Un-
linkability for DiversifyHash. (IK-CCA corresponds to the potentially stronger requirement that DiversifyHash
remains Unlinkable when given Dif  e-Hellman key agreement oracles for each of the candidate diversi  ed
payment addresses .) So if ElGamal is key-private , then DiversifyHash is Unlinkable under the same condi-
tions. [BBDP2001, Appendix A] gives a security proof for key privacy  (both IK-CPA and IK-CCA) of ElGamal
under the Decisional Dif  e-Hellman assumption on the relevant group. (In fact the proof needed is the “small
modi  cation” described in the last paragraph in which the generator is chosen at random for each key.)
•                                                                                                                    It is assumed (also for the security of other uses of the group hash, such as Pedersen hashes and commit-
ments) that the discrete logarithm of the output group element with respect to any other generator is un-
known. This assumption is justi  ed if the group hash acts as a random oracle. Essentially, diversi  ers act as
handles to unknown random numbers. (The group hash inputs used with different personalizations are in
different “namespaces”.)
•                                                                                                                    Informally, the random self-reducibility property of DDH implies that an adversary would gain no advan-
tage from being able to query an oracle for additional (gd, pkd ) pairs with the same spend authority as an
existing shielded payment address , since they could also create such pairs on their own. This justi  es only
considering two shielded payment addresses in the security de  nition.
TODO: FIXME This is not correct, because additional pairs don’t quite follow the same distribution as an address
with a valid diversifier. The security definition may need to be more complex to model this properly.
•                                                                                                                    An 88-bit diversi  er cannot be considered cryptographically unguessable at a 128-bit security level; also,
randomly chosen diversi  ers are likely to suffer birthday collisions when the number of choices approaches
244.
If most users are choosing diversi  ers randomly (as recommended in § 4.2.2 ‘Sapling Key Components’ on
p. 27), then the fact that they may accidentally choose diversi  ers that collide (and therefore reveal the fact
that they are not derived from the same incoming viewing key ) does not appreciably reduce the anonymity
set.
In [ZIP-32] an 88-bit Pseudo Random Permutation, keyed differently for each node of the derivation tree, is
used to select new diversi  ers . This resolves the potential problem, provided that the input to the Pseudo
Random Permutation does not repeat for a given node.
•                                                                                                                    If the holder of an incoming viewing key permits an adversary to ask for a new address for that incoming
viewing key with a given diversi  er , then it can trivially break Unlinkability for the other diversi  ed payment
addresses associated with the incoming viewing key  (this does not compromise other privacy properties).
Implementations SHOULD avoid providing such a “chosen diversi  er ” oracle.
5.4.1.7                                                                                                              Pedersen Hash Function
PedersenHash is an algebraic hash function with collision resistance (for  xed input length) derived from assumed
hardness of the Discrete Logarithm Problem on the Jubjub curve . It is based on the work of David Chaum, Ivan
Damgård, Jeroen van de Graaf, Jurjen Bos, George Purdy, Eugène van Heijst and Birgit P  tzmann in [CDvdG1987],
[BCP1988] and [CvHP1991], and of Mihir Bellare, Oded Goldreich, and Sha   Goldwasser in [BGG1995], with opti-
mizations for ef  cient instantiation in zk-SNARK circuits by Sean Bowe and Daira Hopwood.
54




PedersenHash is used in the de  nitions of Pedersen commitments (§ 5.4.7.2 ‘Windowed Pedersen commitments’ on
p. 64), and of the hash function for the Sapling incremental Merkle tree (§ 5.4.1.3 ‘MerkleCRHSapling Hash Function’
on p. 52).
Let J, J(r) , OJ, qJ, rJ, aJ, and dJ be as de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68.
Let ExtractJ(r)   ◦ J(r)  → B[ℓMerkleSapling ] be as de  ned in § 5.4.8.4 ‘Hash Extractor for Jubjub’ on p. 69.
Let FindGroupHashJ(r)∗  be as de  ned in § 5.4.8.5 ‘Group Hash into Jubjub’ on p. 70.
Let c := 63.
De  ne I ◦ BY[8] × N → J(r)∗ by:
                                                                                                                                                                                                 (                                                                                                                        )
i                                                                                                                      := FindGroupHashJ(r)∗                                                     D,                                                                                              32-bit i − 1
De  ne PedersenHashToPoint(D ◦ BY[8], M  ◦ B[N+ ] ) → J(r) as follows:
Pad M to a multiple of 3 bits by appending zero bits, giving M ′.
                                                                                                                       (                                                                         )
                                                                                                                       length(M ′ )
Let n = ceiling
                                                                                                                       3 · c
                                                                                                                                                                                                 Split M ′ into n “segments ” M1 .. n so that M ′  = concatB (M1 .. n ), and each of M1 .. n−1   is of length             3 ·c bits. (Mn
may be shorter.)
∑n
◦
Return                                                                                                                 ◦   J(r) .
i=1                                                                                                                    i
where 〈•〉 ◦ B[3·{1 .. c}]  → {−rJ − 1                                                                                                                                                            .. rJ − 1                                                                                       } \ {0} is de  ned as:
                                                                                                                       2                                                                         2
Let ki  = length(Mi )/3.
Split Mi into 3-bit “chunks ” m1 .. ki  so that Mi  = concatB (m1 .. ki ).
Write each mj as [s0 , s1 , s2 ], and let enc(mj ) = (1 − 2·s2 ) · (1 + s0  + 2·s1 ) ◦ Z.
∑k                                                                                                                     i
Let 〈Mi〉 =                                                                                                             enc(mj ) · 24·(j−1) .
j=1
                                                                                                                       Finally, de  ne PedersenHash ◦ BY[8] × B[N+ ]  → B[ℓMerkleSapling ] by:
                                                                                                                       (                                                                         )
PedersenHash(D, M ) := ExtractJ(r)                                                                                     PedersenHashToPoint(D, M )
See §A.3.3.9 ‘Pedersen hash’ on p. 131 for rationale and ef  cient circuit implementation of these functions.
Security requirement:   PedersenHash and PedersenHashToPoint are required to be collision-resistant between
inputs of   xed length, for a given personalization input D.  No other security properties commonly associated
with hash functions are needed.
Non-normative note:   These hash functions are not collision-resistant for variable-length inputs.
Theorem 5.4.1.  The encoding function 〈•〉 is injective.
∑
Proof.  We  rst check that the range of                                                                                enc(mj ) · 24·(j−1) is a subset of the allowable range {−rJ − 1           .. rJ − 1                                                                                       } \ {0}.
                                                                                                                       2                                                                         2
j=1
                                                                                                                       ∑
The range of this expression is a subset of {−Δ .. Δ} \ {0} where Δ = 4 ·                                              24·(i−1)  = 4 · 24·c
                                                                                                                       15  .
i=1
55




When c = 63, we have
4 · 24·c                                                                                                                               = 0x444444444444444444444444444444444444444444444444444444444444444
15
rJ − 1
= 0x73EDA753299D7D483339D80809A1D8053341049E6640841684B872F6B7B965B
2
∑k                                                                                                                                     i
                                                                                                                                                                                                                                      so the required condition is met. This implies that there is no “wrap around” and so                                                               enc(mj ) · 24·(j−1) may be
                                                                                                                                                                                                                                                                                                                                                      j=1
treated as an integer expression.
                                                                                                                                                                                                                                                                                                                             ◦         [3·{1 .. c}]
                                                                                                                                       enc is injective.  In order to prove that 〈•〉 is injective, consider 〈•〉Δ                                                                                                             ◦     B                  →  {0 .. 2·Δ} such that 〈Mi〉Δ  =
∑k
i
〈Mi〉 + Δ. With ki and mj de  ned as above, we have 〈Mi〉Δ  =                                                                            enc′ (mj ) · 24·(j−1) where enc′ (mj ) = enc(mj ) + 4
j=1
is in {0 .. 8} and enc′ is injective. Express this sum in hexadecimal; then each mj affects only one hex digit, and it is
easy to see that 〈•〉Δ is injective. Therefore so is 〈•〉.                                                                               □
Since the security proof from [BGG1995, Appendix A] depends only on the encoding being injective and its range
not including zero, the proof can be adapted straightforwardly to show that PedersenHashToPoint is collision-resis-
tant under the same assumptions and security bounds. Because ExtractJ(r)  is injective, it follows that PedersenHash
is equally collision-resistant .
Theorem 5.4.2.  UncommittedSapling  = I2LEBSPℓ                                                                                         (1) is not in the range of PedersenHash.
MerkleSapling
Proof.  By injectivity of I2LEBSPℓMerkleSapling  and the de  nitions of PedersenHash and ExtractJ(r) , I2LEBSPℓMerkleSapling (1) can
be in the range of PedersenHash only if there exist (D ◦ BY[8], M  ◦ B[N+ ] ) such that u(PedersenHashToPoint(D, M )) = 1.
The latter can only be the af  ne-Edwards u-coordinate of a point in J. We show that there are no points in J with
af  ne-Edwards u-coordinate 1. Suppose for a contradiction that (u, v) ∈ J for u = 1 and some v ◦ FrS . By writing
the curve equation as v2  = (1 − aJ ·u2 )/(1 − dJ ·u2 ), and noting that 1 − dJ ·u2  , 0, we have v2  = (1 − aJ )/(1 − dJ ).
□
                                                                                                                                       The right-hand-side is a nonsquare in FrS , so there are no solutions for v (contradiction).
5.4.1.8                                                                                                                                Mixing Pedersen Hash Function
A mixing Pedersen hash is used to compute ρ from cm and pos in § 4.14 ‘Note Commitments and Nullifiers’ on
p. 40. It takes as input a Pedersen commitment P , and hashes it with another input x.
De  ne J  := FindGroupHashJ(r)∗ (“Zcash_J_”, “”).
We de  ne MixingPedersenHash ◦ J × {0 .. rJ − 1} → J by:
MixingPedersenHash(P, x) := P + [x] J .
Security requirement:   The function
(r, M, x) ◦ {0 .. rJ − 1} × B[N+ ] × {0 .. rJ − 1} → MixingPedersenHash(WindowedPedersenCommitr (M ), x) ◦ J
must be collision-resistant on (r, M, x).
See §A.3.3.10 ‘Mixing Pedersen hash’ on p. 134 for ef  cient circuit implementation of this function.
56




5.4.1.9                                                                                                                Equihash Generator
                                                                                                                                                             EquihashGenn,k is a specialized hash function that maps an input and an index to an output of length n bits. It is
used in § 7.6.1 ‘Equihash’ on p. 86.
Let powtag :=                                                                                                          64-bit “ZcashPoW”                     32-bit n                                                                                                             32-bit k
Let powcount(g) :=                                                                                                     32-bit g
                                                                                                                                                                                                                                                                                             Let EquihashGenn,k (S, i) := Th+1 .. h+n, where
                                                                                                                                                             ( 512                                                                                                                           )
m := floor                                                                                                                                                                                                                                                                                   ;
                                                                                                                                                                                                                                                                                  n
                                                                                                                       h := (i − 1 mod m) · n;
                                                                                                                                                                                                                                                                                                                                               (                                                                                                                           (i−1          )         )
                                                                                                                       T  := BLAKE2b-(n · m)                                                                                                                                                                                                       powtag, S || powcount(floor                                                                                                                     )
m
Indices of bits in T are 1-based.
BLAKE2b-ℓ(p, x) is de  ned in § 5.4.1.2 ‘BLAKE2 Hash Function’ on p. 52.
Security requirement:   BLAKE2b-ℓ(powtag, x) must generate output that is suf  ciently unpredictable to avoid
short-cuts to the Equihash solution process. It would suf  ce to model it as a random oracle.
Note:   When EquihashGen is evaluated for sequential indices, as in the Equi(ash)solving process (§ 7.6.1 ‘Equihash’
on p. 86), the number of calls to BLAKE2b can be reduced by a factor of floor  5n2                                     in the best case (which is a factor
of 2 for n = 200).
5.4.2                                                                                                                  Pseudo Random Functions
                                                                                                                                                                                                                                                                                                                                                   PRFaddr , PRFnf , PRFpk , and PRFρ, described in § 4.1.2 ‘Pseudo Random Functions’ on p. 18, are all instantiated us-
                                                                                                                                                                                                                                                                                                                                                   ing the SHA-256 compression function de  ned in § 5.4.1.1 ‘SHA-256 and SHA256Compress Hash Functions’ on
p. 51:
                                                                                                                                                             (                                                                                                                                                                                                                                                                                                                                                    )
PRFxddr (t) := SHA256Compress                                                                                                                                                                                                                                                     1          1                                                 0   0                                                                                                                       252-bit x     8-bit t   [0]248
                                                                                                                                                             (                                                                                                                                                                                                                                                                                                                                                    )
PRFaf                                                                                                                  (ρ) := SHA256Compress                                                                                                                                      1          1                                                 1   0                                                                                                                       252-bit ask             256-bit ρ
sk
                                                                                                                                                             (                                                                                                                                                                                                                                                                                                                                                    )
PRFak                                                                                                                  (i, hSig ) := SHA256Compress                                                                                                                               0          i -1                                              0   0                                                                                                                       252-bit ask             256-bit hSig
sk
                                                                                                                                                             (                                                                                                                                                                                                                                                                                                                                                    )
PRFϕ (i, hSig ) := SHA256Compress                                                                                                                                                                                                                                                 0          i -1                                              1   0                                                                                                                       252-bit ϕ               256-bit hSig
Security requirements:
•  The SHA-256 compression function must be collision-resistant .
•  The SHA-256 compression function must be a PRF when keyed by the bits corresponding to x, ask or ϕ in
the above diagrams, with input in the remaining bits.
57




Note:   The   rst four bits -i.e. the most signi  cant four bits of the   rst byte- are used to separate distinct uses of
SHA256Compress, ensuring that the functions are independent. As well as the inputs shown here, bits 1011 in this
position are used to distinguish uses of the full SHA-256 hash function; see § 5.4.7.1 ‘Sprout Note Commitments’
on p. 63.
(The speci  c bit patterns chosen here were motivated by the possibility of future extensions that might have in-
creased Nold and/or Nnew to 3, or added an additional bit to ask to encode a new key type, or that would have re-
quired an additional PRF. In fact since Sapling switches to non-SHA256Compress-based cryptographic primitives,
these extensions are unlikely to be necessary.)
PRFexpand is used in § 4.2.2 ‘Sapling Key Components’ on p. 27 to derive the spend authorizing key ask and the
proof authorizing key nsk.
It is instantiated using the BLAKE2b hash function de  ned in § 5.4.1.2 ‘BLAKE2 Hash Function’ on p. 52:
)
                                                                                                                            PRFskpand (t) := BLAKE2b-512(“Zcash_ExpandSeed”, LEBS2OSP                                                                                                                                                                        256                 (sk) || t
                                                                                                                                                                                                                                                                                                   (                                                                                                 )
Security requirement:   BLAKE2b-512                                                                                                                                                                                                                                                                              “Zcash_ExpandSeed”, LEBS2OSP256 (sk) || t                                                         must be a PRF for output range
                                                                                                                                                                                        BY[ℓPRFexpand /8] when keyed by the bits corresponding to sk, with input in the bits corresponding to t.
PRFock is used in § 4.17.1 ‘Encryption (Sapling)’ on p. 46 to derive the outgoing cipher key ock used to encrypt an
output ciphertext .
It is instantiated using the BLAKE2b hash function de  ned in § 5.4.1.2 ‘BLAKE2 Hash Function’ on p. 52:
PRFovk (cv, cmu, ephemeralKey) := BLAKE2b-256(“Zcash_Derive_ock”, ockInput)
where ockInput =                                                                                                            LEBS2OSP256 (ovk)                                           32-byte cv                                                                                                 32-byte cmu   32-byte ephemeralKey
                                                                                                                                                                                        (                                                                                                          )
Security requirement:   BLAKE2b-512                                                                                         “Zcash_Derive_ock”, ockInput                                must be a PRF for output range Sym.K (de-
ned in § 5.4.3 ‘Authenticated One-Time Symmetric Encryption’ on p. 58) when keyed by the bits corresponding
to ovk, with input in the bits corresponding to cv, cmu, and ephemeralKey.
PRFnfSapling is used to derive the nulli  er for a Sapling note . It is instantiated using the BLAKE2s hash function
de  ned in § 5.4.1.2 ‘BLAKE2 Hash Function’ on p. 52:
                                                                                                                                                                                                                                                                                                   (                                                                                                                                                     )
                                                                                                                                                                                                                                                                                                                                                                                                                   (                                )
                                                                                                                                                                                        (ρ⋆) := BLAKE2s-256                                                                                        “Zcash_nf”,                                               LEBS2OSP256 (nk⋆)                       LEBS2OSP256                                    ρ⋆
⋆
                                                                                                                                                                                                                                                                                                                 (                                                                                                                                       )
                                                                                                                                                                                                                                                                                                                                                                                                                                                    (    )
                                                                                                                            Security requirement:   BLAKE2s-256                                                                                                                                                  “Zcash_nf”,                                                     LEBS2OSP256 (nk⋆)                 LEBS2OSP256                      ρ⋆       must be a col-
lision-resistant PRF for output range BY[32] when keyed by the bits corresponding to nk⋆, with input in the bits cor-
responding to ρ⋆. Note that nk⋆ ◦ J(r) is a representation of a point in the rJ-order subgroup of the Jubjub curve ,
and therefore is not uniformly distributed on B[ℓJ ]. J(r) is de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68.
5.4.3                                                                                                                       Authenticated One-Time Symmetric Encryption
Let Sym.K := B[256], Sym.P := BY[N], and Sym.C := BY[N].
Let Sym.EncryptK (P) be authenticated encryption using AEAD_CHACHA20_POLY1305 [RFC-7539] encryption of
plaintext P ∈ Sym.P, with empty “associated data", all-zero nonce [0]96, and 256-bit key K ∈ Sym.K.
Similarly, let Sym.DecryptK (C) be AEAD_CHACHA20_POLY1305 decryption of ciphertext C  ∈ Sym.C, with empty
“associated data", all-zero nonce [0]96, and 256-bit key K ∈ Sym.K. The result is either the plaintext byte sequence,
or ⊥ indicating failure to decrypt.
58




Note:   The “IETF" de  nition of AEAD_CHACHA20_POLY1305 from [RFC-7539] is used; this has a 32-bit block count
and a 96-bit nonce, rather than a 64-bit block count and 64-bit nonce as in the original de  nition of ChaCha20.
5.4.4                                                                                                                         Key Agreement and Derivation
5.4.4.1                                                                                                                       Sprout Key Agreement
KASprout is a key agreement scheme as speci  ed in § 4.1.4 ‘Key Agreement’ on p. 19.
It is instantiated as Curve25519 key agreement, described in [Bernstein2006], as follows.
Let KASprout.Public and KASprout.SharedSecret be the type of Curve25519 public keys (i.e. BY[32]), and let KASprout.Private
be the type of Curve25519 secret keys.
Let Curve25519(n, q) be the result of point multiplication of the Curve25519 public key represented by the byte se-
quence q by the Curve25519 secret key represented by the byte sequence n, as de  ned in [Bernstein2006, section 2].
Let KASprout.Base := 9 be the public byte sequence representing the Curve25519 base point.
Let clampCurve25519 (x) take a 32-byte sequence x as input and return a byte sequence representing a Curve25519
private key, with bits “clamped” as described in [Bernstein2006, section 3]: “clear bits 0, 1, 2 of the   rst byte, clear
bit 7 of the last byte, and set bit 6 of the last byte.” Here the bits of a byte are numbered such that bit b has numeric
weight 2b.
De  ne KASprout.FormatPrivate(x) := clampCurve25519 (x).
De  ne KASprout.DerivePublic(n, q) := Curve25519(n, q).
De  ne KASprout.Agree(n, q) := Curve25519(n, q).
5.4.4.2                                                                                                                       Sprout Key Derivation
                                                                                                                                                                                 KDFSprout is a Key Derivation Function as speci  ed in § 4.1.5 ‘Key Derivation’ on p. 19.
                                                                                                                              It is instantiated using BLAKE2b-256 as follows:
                                                                                                                              KDFSprout (i, hSig , sharedSecreti, epk, pkenc                                                                                                 ,i ) := BLAKE2b-256(kdftag, kdfinput)
where:
kdftag :=                                                                                                                     64-bit “ZcashKDF”                                  8-bit i−1                                                                                   [0]56
kdfinput :=                                                                                                                                                                      256-bit hSig                                                                                256-bit sharedSecreti                   256-bit epk   256-bit pkenc   ,i
                                                                                                                                                                                 BLAKE2b-256(p, x) is de  ned in § 5.4.1.2 ‘BLAKE2 Hash Function’ on p. 52.
5.4.4.3                                                                                                                       Sapling Key Agreement
KASapling is a key agreement scheme as speci  ed in § 4.1.4 ‘Key Agreement’ on p. 19.
It is instantiated as Dif  e-Hellman with cofactor multiplication on Jubjub as follows:
Let J, J(r) , J(r)∗, and the cofactor hJ be as de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68.
De  ne KASapling .Public := J.
De  ne KASapling .PublicPrimeOrder := J(r)∗.
De  ne KASapling .SharedSecret := J(r) .
59




De  ne KASapling .Private := Fr
J
De  ne KASapling .DerivePublic(sk, B ) := [sk] B.
De  ne KASapling .Agree(sk, P ) := [hJ · sk] P .
5.4.4.4                                                                                                                  Sapling Key Derivation
KDFSapling is a Key Derivation Function as speci  ed in § 4.1.5 ‘Key Derivation’ on p. 19.
It is instantiated using BLAKE2b-256 as follows:
KDFSapling (sharedSecret, epk) := BLAKE2b-256(“Zcash_SaplingKDF”, kdfinput).
where:
                                                                                                                                                  (                                                                            )                 (             )
kdfinput :=                                                                                                              LEBS2OSP256              reprJ (sharedSecret )                                                            LEBS2OSP256   reprJ (epk)
                                                                                                                                                  BLAKE2b-256(p, x) is de  ned in § 5.4.1.2 ‘BLAKE2 Hash Function’ on p. 52.
5.4.5                                                                                                                    JoinSplit Signature
JoinSplitSig is a signature scheme as speci  ed in § 4.1.6 ‘Signature’ on p. 20.
It is instantiated as Ed25519 [BDLSY2012], with the additional requirements that:
•  S MUST represent an integer less than the prime ℓ = 2252 + 27742317777372353535851937790883648493;
•  R MUST represent a point on the Ed25519 curve of order at least ℓ.
If these requirements are not met then the signature is considered invalid. Note that it is not required that the
encoding of the y-coordinate in R is less than 2255 − 19; also the order of the point represented by R is permitted
to be greater than ℓ.
Ed25519 is de  ned as using SHA-512 internally.
A valid Ed25519 public key is de  ned as a point of order ℓ on the Ed25519 curve, in the encoding speci  ed by
[BDLSY2012]. Again, it is not required that the encoding of the y-coordinate of the public key is less than 2255 − 19.
The encoding of a signature is:
256-bit R                                                                                                                256-bit S
where R and S are as de  ned in [BDLSY2012]. The encoding of a public key is as de  ned in [BDLSY2012].
5.4.6                                                                                                                    RedDSA and RedJubjub
RedDSA is a Schnorr-based signature scheme , optionally supporting key re-randomization as described in § 4.1.6.1
‘Signature with Re-Randomizable Keys’ on p. 21.  It also supports a Secret Key to Public Key Homomorphism
as described in § 4.1.6.2 ‘Signature with Private Key to Public Key Homomorphism’ on p. 22.  It is based on a
scheme from [FKMSSS2016, section 3], with some ideas from EdDSA [BJLSY2015].
RedJubjub is a specialization of RedDSA to the Jubjub curve (§ 5.4.8.3 ‘Jubjub’ on p. 68), using the BLAKE2b-512 hash
function.
The spend authorization signature scheme de  ned in § 5.4.6.1 ‘Spend Authorization Signature’ on p. 63 is instan-
tiated by RedJubjub. The binding signature scheme BindingSig de  ned in § 5.4.6.2 ‘Binding Signature’ on p. 63 is
instantiated by RedJubjub without use of key re-randomization.
60




We   rst describe the scheme RedDSA over a general represented group. Its parameters are:
•  a represented group G, which also de  nes a subgroup G(r) of order rG, a cofactor hG, a group operation +,
an additive identity OG , a bit-length ℓG , a representation function repr                                      and an abstraction function abstG ,
G ,
as speci  ed in § 4.1.8 ‘Represented Group’ on p. 24;
•  PG , a generator of G(r) ;
•  a bit-length ℓH  ◦ N such that 2ℓH −128  ≥ rG and ℓH mod 8 =                                                 0;
•  a cryptographic hash function H ◦ BY[N]  → BY[ℓH /8].
Its associated types are de  ned as follows:
RedDSA.Message := BY[N]
RedDSA.Signature := BY[ceiling(ℓG /8) + ceiling(bitlength(rG )/8)]
RedDSA.Public := G
RedDSA.Private := FrG .
RedDSA.Random := FrG .
De  ne H⊛  ◦ BY[N]  → Fr                                                                                        by:
G
                                                                                                                (                                     )
H⊛ (B ) = LEOS2IPℓ                                                                                              H(B )                                 (mod rG )
                                                                                                                H
                                                                                                                                                      R   RedDSA.Private as:
Return sk ←R  FrG .
De  ne RedDSA.DerivePublic ◦ RedDSA.Private → RedDSA.Public by:
RedDSA.DerivePublic(sk) := [sk] PG .
R   RedDSA.Random as:
Choose a byte sequence T uniformly at random on BY[(ℓH +128)/8].
Return H⊛ (T ).
De  ne ORedDSA.Random  := 0  (mod rG ).
De  ne RedDSA.RandomizePrivate ◦ RedDSA.Random × RedDSA.Private → RedDSA.Private by:
RedDSA.RandomizePrivate(α, sk) := sk + α  (mod rG ).
De  ne RedDSA.RandomizePublic ◦ RedDSA.Random × RedDSA.Public → RedDSA.Public as:
RedDSA.RandomizePublic(α, vk) := vk + [α] PG .
R   RedDSA.Signature as:
Choose a byte sequence T uniformly at random on BY[(ℓH +128)/8].
(                                                                                                                                                     )
                                                                                                                reprG (RedDSA.DerivePublic(sk))
Let vk = LEBS2OSPℓG
Let r = H⊛ (T || vk || M ).
Let R = [r] PG .
(                                                                                                               )
reprG (R )
Let R = LEBS2OSPℓG
Let S = (r + H⊛ (R || vk || M ) · sk) mod rG.
                                                                                                                (                                     )
Let S = LEBS2OSPbitlength(rG )                                                                                  I2LEBSPbitlength(rG ) (S )
Return R || S.
61




De  ne RedDSA.Verify ◦ (vk ◦ RedDSA.Public) × (M  ◦ RedDSA.Message) × (σ ◦ RedDSA.Signature) → B as:
                                                                                                                      (                                                                                                                       )                                                                                                           (                  )
Let R be the   rst ceiling                                                                                            ℓG /8                                                                                                                   bytes of σ, and let S be the remaining ceiling                                                              bitlength(rG )/8   bytes.
                                                                                                                      (                                                                                                                       )
Let R = abstG                                                                                                                                                                                                                                 , and let S = LEOS2IP8·length(S ) (S ).
                                                                                                                      LEOS2BSPℓG (R )
                                                                                                                      (                                                                                                                       )
                                                                                                                      reprG (vk)
Let vk = LEBS2OSPℓG
Let c = H⊛ (R || vk || M ).
                                                                                                                                                                                                                                              (                                                )
                                                                                                                      Return 1 if R , ⊥ and S < rG and [hG]                                                                                   −[S] PG  + R + [c] vk                            = OG , otherwise 0.
Notes:
•  The veri  cation algorithm does not check that R is a point of order at least rG. It does check that R is the
canonical representation (as output by reprG ) of a point on the curve. This is different to Ed25519 as speci  ed
in § 5.4.5 ‘JoinSplit Signature’ on p. 60.
•  Appendix §B.1 ‘RedDSA batch verification’ on p. 141 describes an optimization that MAY be used to speed up
veri  cation of batches of RedDSA signatures.
Non-normative note:   The randomization used in RedDSA.RandomizePrivate and RedDSA.RandomizePublic may
interact with other uses of additive properties of keys for Schnorr-based signature schemes. In the Zcash protocol,
such properties are used for binding signatures but not at the same time as key randomization. They are also used
in [ZIP-32] when deriving child extended keys, but this does not result in any practical security weakness as long
as the security recommendations of ZIP-32 are followed. If RedDSA is reused in other protocols making use of
these additive properties, careful analysis of potential interactions is required.
The two abelian groups speci  ed in § 4.1.6.2 ‘Signature with Private Key to Public Key Homomorphism’ on p. 22
are instantiated for RedDSA as follows:
•  O                                                                                                                  := 0  (mod rG )
•  sk1                                                                                                                sk2  := sk1 + sk2  (mod rG )
•  O                                                                                                                  := OG
•  vk1                                                                                                                vk2  := vk1 + vk2.
                                                                                                                      As required, RedDSA.DerivePublic is a group homomorphism:
RedDSA.DerivePublic(sk1                                                                                                                                                                                                                       sk2 ) = [sk1 + sk2  (mod rG )] PG
                                                                                                                                                                                                                                              = [sk1] PG  + [sk2] PG                           (since PG has order rG)
= RedDSA.DerivePublic(sk1 )    RedDSA.DerivePublic(sk2 ).
A RedDSA public key vk can be encoded as a bit sequence reprG (vk) of length ℓG bits (or as a corresponding byte
sequence vk by then applying LEBS2OSPℓG ).
The scheme RedJubjub specializes RedDSA with:
•  G := J as de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68;
•  ℓH  := 512;
                                                                                                                      (                                                                                                                       )
•  H(x) := BLAKE2b-512                                                                                                “Zcash_RedJubjubH”, x                                                                                                                                                    as de  ned in § 5.4.1.2 ‘BLAKE2 Hash Function’ on p. 52.
                                                                                                                      The generator PG  ◦ G(r) is left as an unspeci  ed parameter, which is different between BindingSig and SpendAuthSig.
62




5.4.6.1                                                                                                           Spend Authorization Signature
Let RedJubjub be as de  ned in § 5.4.6 ‘RedDSA and RedJubjub’ on p. 60.
De  ne G := FindGroupHashJ(r)∗ (“Zcash_G_”, “”).
SpendAuthSig is instantiated as RedJubjub with key re-randomization, and with generator PG  = G.
See § 4.13 ‘Spend Authorization Signature’ on p. 39 for details on the use of this signature scheme .
Security requirement:   SpendAuthSig must be a SURK-CMA secure signature scheme with re-randomizable
keys as de  ned in § 4.1.6.1 ‘Signature with Re-Randomizable Keys’ on p. 21.
5.4.6.2                                                                                                           Binding Signature
Let RedJubjub be as de  ned in § 5.4.6 ‘RedDSA and RedJubjub’ on p. 60.
Let R be the randomness base de  ned in § 5.4.7.3 ‘Homomorphic Pedersen commitments’ on p. 64.
BindingSig is instantiated as RedJubjub, without use of key re-randomization, and with generator PG  = R.
See § 4.12 ‘Balance and Binding Signature (Sapling)’ on p. 37 for details on the use of this signature scheme .
Security requirement:   BindingSig must be a SUF-CMA secure signature scheme with private key to public key
homomorphism as de  ned in § 4.1.6.2 ‘Signature with Private Key to Public Key Homomorphism’ on p. 22.  A
signature must prove knowledge of the discrete logarithm of the public key with respect to the base R.
5.4.7                                                                                                             Commitment schemes
5.4.7.1                                                                                                           Sprout Note Commitments
                                                                                                                                                                                                            The commitment scheme NoteCommitSprout speci  ed in § 4.1.7 ‘Commitment’ on p. 23 is instantiated using SHA-256
as follows:
                                                                                                                                                                            (                                                                                                                                                                                                    )
                                                                                                                  cm                              (apk , v, ρ) := SHA-256       1   0   1   1   0   0   0   0                                                                                                                 256-bit apk   64-bit v   256-bit ρ   256-bit rcm
NoteCommitSprout.GenTrapdoor() generates the uniform distribution on NoteCommitSprout.Trapdoor.
Note:   The leading byte of the SHA-256 input is 0xB0.
Security requirements:
•  The SHA-256 compression function must be collision-resistant .
•  The SHA-256 compression function must be a PRF when keyed by the bits corresponding to the position of
rcm in the second block of SHA-256 input, with input to the PRF in the remaining bits of the block and the
chaining variable.
63




5.4.7.2                                                                                                             Windowed Pedersen commitments
                                                                                                                    § 5.4.1.7 ‘Pedersen Hash Function’ on p. 54 de  nes a Pedersen hash construction. We construct “windowed ” Ped-
                                                                                                                    ersen commitments by reusing that construction, and adding a randomized point on the Jubjub curve (see § 5.4.8.3
‘Jubjub’ on p. 68):
                                                                                                                    (                                                                                                                  )
WindowedPedersenCommitr (s) := PedersenHashToPoint                                                                  “Zcash_PH”, s                                                                                                      + [r] FindGroupHashJ(r)∗ (“Zcash_PH”, “r”)
See §A.3.5 ‘Windowed Pedersen Commitment’ on p. 134 for rationale and ef  cient circuit implementation of this
function.
The commitment scheme NoteCommitSapling  speci  ed in § 4.1.7 ‘Commitment’ on p. 23 is instantiated as follows
using WindowedPedersenCommit:
(
(g⋆d, pk⋆d, v) := WindowedPedersenCommitrcm                                                                         [1]6 || I2LEBSP64 (v) || g⋆d || pk⋆d)
cm
NoteCommitSapling .GenTrapdoor() generates the uniform distribution on Fr
J
Security requirements:
•  WindowedPedersenCommit, and hence NoteCommitSapling , must be computationally binding and at least com-
putationally hiding commitment schemes .
(They are in fact unconditionally hiding commitment schemes .)
Notes:
•  MerkleCRHSapling is also de  ned in terms of PedersenHashToPoint (see § 5.4.1.3 ‘Merkle Tree Hash Function’ on
p. 52). The pre  x [1]6  distinguishes the use of WindowedPedersenCommit in NoteCommitSapling from the layer
pre  x used in MerkleCRHSapling . That layer pre  x is a 6-bit little-endian encoding of an integer in the range
{0 .. MerkleDepthSapling − 1}; because MerkleDepthSapling  < 64, it cannot collide with [1]6.
•  The arguments to NoteCommitSapling are in a different order to their encodings in WindowedPedersenCommit.
There is no particularly good reason for this.
5.4.7.3                                                                                                             Homomorphic Pedersen commitments
The windowed Pedersen commitments de  ned in the preceding section are highly ef  cient, but they do not sup-
port the homomorphic property we need when instantiating ValueCommit.
For more details on the use of this property, see § 4.12 ‘Balance and Binding Signature (Sapling)’ on p. 37 and
§ 3.6 ‘Spend Transfers, Output Transfers, and their Descriptions’ on p. 15.
In order to support this property, we also de  ne “homomorphic ” Pedersen commitments as follows:
HomomorphicPedersenCommitrcv (D, v) := [v] FindGroupHashJ(r)∗ (D, “v”)+ [rcv] FindGroupHashJ(r)∗ (D, “r”)
ValueCommit.GenTrapdoor() generates the uniform distribution on FrJ .
See §A.3.6 ‘Homomorphic Pedersen Commitment’ on p. 135 for rationale and ef  cient circuit implementation of
this function.
De  ne:
V := FindGroupHashJ(r)∗ (“Zcash_cv”, “v”)
R := FindGroupHashJ(r)∗ (“Zcash_cv”, “r”).
64




The commitment scheme ValueCommit speci  ed in § 4.1.7 ‘Commitment’ on p. 23 is instantiated as follows using
HomomorphicPedersenCommit:
ValueCommitrcv (v) := HomomorphicPedersenCommitrcv (“Zcash_cv”, v).
which is equivalent to:
ValueCommitrcv (v) := [v] V + [rcv] R.
Security requirements:
•  HomomorphicPedersenCommit must be a computationally binding and at least computationally hiding com-
mitment scheme , for a given personalization input D.
•  ValueCommit must be a computationally binding and at least computationally hiding commitment scheme .
(They are in fact unconditionally hiding commitment schemes .)
5.4.8                                                                                                                             Represented Groups and Pairings
5.4.8.1                                                                                                                           BN-254
The represented pairing BN-254 is de  ned in this section.
Let qG  := 21888242871839275222246405745257275088696311157297823662689037894645226208583.
Let rG  := 21888242871839275222246405745257275088548364400416034343698204186575808495617.
Let bG  := 3.
(qG and rG are prime.)
Let G1r)  be the group (of order rG) of rational points on a Barreto-Naehrig ([BN2005]) curve EG
                                                                                                                                                                                                                                                                                                                     1   over FqG  with
                                                                                                                                  equation y2  = x3 + bG. This curve has embedding degree 12 with respect to rG.
                                                                                                                                  Let G2r)  be the subgroup of order rG in the sextic twist EG
                                                                                                                                  2                                                                                of EG1  over Fq                                                                               G       ξ  , where
ξ ◦   Fq                                                                                                                          2 .
                                                                                                                                  G
                                                                                                                                  We represent elements of Fq
                                                                                                                                  G                                                                                2  as polynomials a1 · t + a0  ◦ FqG [t], modulo the irreducible polynomial t2 + 1; in this
                                                                                                                                  representation, ξ is given by t + 9.
Let GTr) be the subgroup of rGth roots of unity in F∗
qG12 , with multiplicative identity 1G.
Let êG be the optimal ate pairing (see [Vercauter2009] and [AKLGL2010, section 2]) of type G1r) × G2r)  → GTr) .
For i ◦ {1 .. 2}, let OGi  be the point at in  nity (which is the additive identity) in Gir) , and let Gir)∗  := Gir) \ {OGi }.
Let PG1  ◦ G1r)∗  := (1, 2).
Let PG2  ◦ G2r)∗  := (11559732032986387107991004021392285783925812861821192530917403151452391805634 · t +
10857046999023057135944570762232829481370756359578518086990519993285655852781,
4082367875863433681332203403145435568316851327593401208105741076214120093531 · t +
8495653923123431417604973247489272438418190587263600148770280649306958101930).
PG1  and PG2  are generators of G1r) and G2r) respectively.
De  ne I2BEBSP ◦ (ℓ ◦ N) × {0 .. 2ℓ −1} → B[ℓ] as in § 5.2 ‘Integers, Bit Sequences, and Endianness’ on p. 49.
65




For a point P  ◦ G1r)∗  = (xP , yP ):
•  The   eld elements xP  and yP  ◦ Fq are represented as integers x and y ◦ {0 .. q −1}.
•  Let y = y mod 2.
•  P is encoded as                                                                                                       0                                                                                0   0   0   0   0   1   1-bit y   256-bit I2BEBSP256 (x)
For a point P  ◦ G2r)∗  = (xP , yP ):
•  De  ne FE2IP ◦ FqG [t]/(t2 + 1) → {0 .. qG2 −1} such that FE2IP(aw,1 · t + aw,0 ) = aw,1 · q + aw,0.
•  Let x = FE2IP(xP ), y = FE2IP(yP ), and y′  = FE2IP(−yP ).
{
1,  if y > y′
•  Let y =
0,  otherwise.
•  P is encoded as                                                                                                       0                                                                                0   0   0   1   0   1   1-bit y   512-bit I2BEBSP512 (x)
Non-normative notes:
•  Only the rG-order subgroups G2r)
,T  are used in the protocol, not their containing groups G2,T . Points in G2r)∗
are always checked to be of order rG when decoding from external representation. (The group of rational
points G1  on EG1 /FqG  is of order rG so no subgroup checks are needed in that case, and elements of GTr)
are never represented externally.)  The (r) superscripts on G1r)
,2,T  are used for consistency with notation
elsewhere in this speci  cation.
•  The points at in  nity OG1,2  never occur in proofs and have no de  ned encodings in this protocol.
•  A rational point P  , OG2  on the curve EG2  can be veri  ed to be of order rG, and therefore in G2r)∗, by checking
that rG · P  = OG2 .
•  The use of big-endian order by I2BEBSP is different from the encoding of most other integers in this pro-
,                                                                                                                        2  are consistent with the de  nition of EC2OSP for compressed curve points in
[IEEE2004, section 5.5.6.2].  The LSB compressed form (i.e. EC2OSP-XL) is used for points in G1r)∗, and the
SORT compressed form (i.e. EC2OSP-XS) for points in G2r)∗.
•  Testing y > y′ for the compression of G2r)∗ points is equivalent to testing whether (ay,1, ay,0 ) > (a−y,1, a−y,0 )
in lexicographic order.
•  Algorithms for decompressing points from the above encodings are given in [IEEE2000, Appendix A.12.8]
for G1r)∗, and [IEEE2004, Appendix A.12.11] for G2r)∗.
2  in order to decompress a point encoding, the implementation MUST
When computing square roots in FqG  or Fq                                                                                G
NOT assume that the square root exists, or that the encoding represents a point on the curve.
66




5.4.8.2                                                                                                                           BLS12-381
The represented pairing BLS12-381 is de  ned in this section. Parameters are taken from [Bowe2017].
Let qS  := 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787.
Let rS  := 52435875175126190479447740508185965837690552500527637822603658699938581184513.
Let uS  := −15132376222941642752.
Let bS  := 4.
(qS and rS are prime.)
Let S1r) be the subgroup of order rS of the group of rational points on a Barreto-Lynn-Scott ([BLS2002]) curve ES
1
over FqS  with equation y2  = x3 + bS. This curve has embedding degree 12 with respect to rS.
                                                                                                                                  Let S2r) be the subgroup of order rS in the sextic twist ES                         2  with equation y2  = x3 + 4(i + 1), where
                                                                                                                                                                                                2   of ES1  over Fq   S
i ◦   Fq                                                                                                                          2 .
                                                                                                                                  S
                                                                                                                                  We represent elements of Fq
                                                                                                                                  S                                                                                   2  as polynomials a1 · t + a0  ◦ FqS [t], modulo the irreducible polynomial t2 + 1; in this
                                                                                                                                  representation, i is given by t.
Let STr) be the subgroup of rSth roots of unity in F∗
qS12 , with multiplicative identity 1S.
Let êS be the optimal ate pairing of type S1r) × S2r)  → STr) .
For i ◦ {1 .. 2}, let OSi  be the point at in  nity in Sir) , and let Sir)∗  := Sir) \ {OSi }.
Let PS1  ◦ S1r)∗  := (1, 2).
Let PS2  ◦ S2r)∗  := (11559732032986387107991004021392285783925812861821192530917403151452391805634 · t +
10857046999023057135944570762232829481370756359578518086990519993285655852781,
4082367875863433681332203403145435568316851327593401208105741076214120093531 · t +
8495653923123431417604973247489272438418190587263600148770280649306958101930).
PS1  and PS2  are generators of S1r) and S2r) respectively.
De  ne I2BEBSP ◦ (ℓ ◦ N) × {0 .. 2ℓ −1} → B[ℓ] as in § 5.2 ‘Integers, Bit Sequences, and Endianness’ on p. 49.
For a point P  ◦ S1r)∗  = (xP , yP ):
•  The   eld elements xP  and yP  ◦ FqS  are represented as integers x and y ◦ {0 .. qS −1}.
{
1,  if y > qS − y
•  Let y =
0,  otherwise.
•  P is encoded as                                                                                                                1                                                             0   1-bit y           381-bit I2BEBSP381 (x)
For a point P  ◦ S2r)∗  = (xP , yP ):
•  De  ne FE2IPP ◦ FqS [t]/(t2 + 1) → {0 .. qS −1}[2] such that FE2IPP(aw,1 · t + aw,0 ) = [aw,1, aw,0].
•  Let x = FE2IPP(xP ), y = FE2IPP(yP ), and y′  = FE2IPP(−yP ).
{
1,  if y > y′ lexicographically
•  Let y =
0,  otherwise.
•  P is encoded as                                                                                                                1                                                             0   1-bit y           381-bit I2BEBSP381 (x1 )                                                                      384-bit I2BEBSP384 (x2 )
67




Non-normative notes:
•  Only the rS-order subgroups S1r)
,2,T  are used in the protocol, not their containing groups S1,2,T .  Points in
,                                                                                                                               2  are always checked to be of order rS when decoding from external representation. (Elements of STr) are
never represented externally.) The (r) superscripts on S1r)
                                                                                                                                ,2,T are used for consistency with notation elsewhere
in this speci  cation.
•  The points at in  nity OS1,2  never occur in proofs and have no de  ned encodings in this protocol.
•  In contrast to the corresponding BN-254 curve, ES1  over FqS  is not of prime order.
•  A rational point P  , OSi  on the curve ESi  for i ∈ {1, 2} can be veri  ed to be of order rS, and therefore in Sir)∗,
by checking that rS · P  = OSi .
,                                                                                                                               2  are speci  c to Zcash.
                                                                                                                                                                                                                                            ,   2
in § 5.4.8.1 ‘BN-254’ on p. 65, taking into account that the SORT compressed form (not the LSB compressed
form) is used for S1r)∗.
2  in order to decompress a point encoding, the implementation MUST
When computing square roots in FqS  or Fq                                                                                       S
NOT assume that the square root exists, or that the encoding represents a point on the curve.
5.4.8.3                                                                                                                         Jubjub
Sapling uses an elliptic curve designed to be ef  ciently implementable in zk-SNARK circuits , called “Jubjub”
[Carroll1876]. The represented group Jubjub of points on this curve is de  ned in this section.
Let qJ  := rS, as de  ned in § 5.4.8.2 ‘BLS12-381’ on p. 67.
Let rJ  := 6554484396890773809930967563523245729705921265872317281365359162392183254199.
(qJ and rJ are prime.)
Let hJ  := 8.
Let aJ  := −1.
Let dJ  := −10240/10241  (mod qJ ).
Let J be the group of points (u, v) on a twisted Edwards curve EJ over FqJ  with equation aJ ·u2 + v2  = 1 + dJ ·u2 ·v2.
The zero point with coordinates (0, 1) is denoted OJ. J has order hJ ·rJ.
Let ℓJ  := 256.
De  ne I2LEBSP ◦ (ℓ ◦ N) × {0 .. 2ℓ −1} → B[ℓ] as in § 5.2 ‘Integers, Bit Sequences, and Endianness’ on p. 49.
De  ne reprJ  ◦ J → B[ℓJ ] such that reprJ (u, v) = I2LEBSP256(v + 2255 · ũ), where ũ = u mod 2.
Let abstJ  ◦ B[ℓJ ]  → J ∪ {⊥} be the left inverse of reprJ such that if S is not in the range of reprJ, then abstJ (S ) = ⊥.
De  ne J(r) as the order-rJ subgroup of J. Note that this includes OJ. For the set of points of order rJ (which excludes
OJ), we write J(r)∗.
De  ne J(r)  := {reprJ (P ) ◦ B[ℓJ ] | P  ∈ J(r) }.
68




Non-normative notes:
•  The encoding of a compressed twisted Edwards point used here is consistent with that used in EdDSA
[BJLSY2015] for public keys and the R element of a signature.
•                                                                                                                          [BJLSY2015, “Encoding and parsing curve points”] gives algorithms for decompressing points from the en-
coding of J.
When computing square roots in FqJ  in order to decompress a point encoding, the implementation MUST NOT
assume that the square root exists, or that the encoding represents a point on the curve.
This speci  cation requires “strict” parsing as de  ned in [BJLSY2015, “Encoding and parsing integers”].
Note that algorithms elsewhere in this speci  cation that use Jubjub may impose other conditions on points, for
example that they have order at least rJ.
5.4.8.4                                                                                                                    Hash Extractor for Jubjub
Let u((u, v)) = u and let v((u, v)) = v.
De  ne ExtractJ(r)   ◦ J(r)  → B[ℓMerkleSapling ] by
ExtractJ(r) (P ) := I2LEBSPℓMerkleSapling (u(P )).
Facts:   The point (0, 1) = OJ, and the point (0, −1) has order 2 in J. J(r) is of odd-prime order.
Lemma.  Let P  = (u, v) ∈ J(r) . Then (u, −v) < J(r) .
Proof.  If P                                                                                                               =  OJ  then (u, −v)  =  (0, −1)  <  J(r) .  Else, P is of odd-prime order.  Note that v  ,  0.  (If v  =  0 then
a · u2  = 1, and so applying the doubling formula gives [2] P  = (0, −1), then [4] P  = (0, 1) = OJ; contradiction since
then P would not be of odd-prime order.) Therefore, −v , v. Now suppose (u, −v) = Q is a point in J(r) . Then by
applying the doubling formula we have [2] Q = −[2] P . But also [2] (−P ) = −[2] P . Therefore either Q = −P (then
v(Q) = v(−P ); contradiction since −v , v), or doubling is not injective on J(r)  (contradiction since J(r) is of odd
order [KvE2013]).                                                                                                          □
Theorem 5.4.3.  u is injective on J(r) .
Proof.  By writing the curve equation as v2  = (1 − a·u2 )/(1 − d·u2 ), and noting that the potentially exceptional case
1 − d·u2  = 0 does not occur for a complete twisted Edwards curve, we see that for a given u there can be at most
two possible solutions for v, and that if there are two solutions they can be written as v and −v. In that case by the
Lemma, at most one of (u, v) and (u, −v) is in J(r) . Therefore, u is injective on points in J(r) .                        □
Since I2LEBSPℓMerkleSapling  is injective, it follows that ExtractJ(r)  is injective on J(r) .
69




5.4.8.5                                                                                                                      Group Hash into Jubjub
Let GroupHash.Input := BY[8] × BY[N], and let GroupHash.URSType := BY[64].
(The input element with type BY[8] is intended to act as a “personalization” parameter to distinguish uses of the
group hash for different purposes.)
Let URS be the MPC randomness beacon de  ned in § 5.9 ‘Randomness Beacon’ on p. 78.
Let BLAKE2s-256 be as de  ned in § 5.4.1.2 ‘BLAKE2 Hash Function’ on p. 52.
Let LEOS2IP be as de  ned in § 5.2 ‘Integers, Bit Sequences, and Endianness’ on p. 49.
Let J(r) , J(r)∗, and abstJ be as de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68.
Let D ◦ BY[8] be an 8-byte domain separator, and let M  ◦ BY[N] be the hash input.
RS (D, M ) ◦ J(r)∗ is calculated as follows:
let H = BLAKE2s-256(D, URS || M )
(                                                                                                                            )
let P  = abstJ                                                                                                               LEOS2BSP256 (H )
if P  = ⊥ then return ⊥
let Q = [hJ] P
if Q = OJ then return ⊥, else return Q.
Notes:
•  The BLAKE2s-256 chaining variable after processing URS may be precomputed.
RS for DiversifyHash and to generate independent bases needs a random oracle (for
RS does not return ⊥); here we show that it is suf  cient to employ a simpler
random oracle instantiated by BLAKE2s-256 in the security analysis.
)
◦
H ◦ BY[32]  →,⊥ abstJ(LEOS2BSP                                                                                               (H )                             ◦   J                                                                                   is injective, and both it and its inverse are ef  ciently computable.
256
P  ◦ J →,OJ  [hJ] P  ◦ J(r)∗ is exactly hJ-to-1, and both it and its inverse relation are ef  ciently computable.
(
It follows that when                                                                                                                                          D ◦ BY[8], M  ◦ BY[N])  → BLAKE2s-256(D, URS || M ) ◦ BY[32]  is modelled as a random
(                                                                                                                            (                                )
◦
oracle,                                                                                                                      D ◦ BY[8], M  ◦ BY[N]) →         D, M                                                                                    ◦   J(r)∗ also acts as a random oracle.
RS
De  ne first ◦ (BY  → T ∪ {⊥}) → T ∪ {⊥} so that first(f ) = f (i) where i is the least integer in BY such that f (i) , ⊥,
or ⊥ if no such i exists.
(                                                                                                                            )
◦
D, M || [i]                                                                                                                  ◦   J(r)∗ ∪ {⊥}).
RS
Note:   For random input, FindGroupHashJ(r)∗  returns ⊥ with probability approximately 2−256. In the Zcash pro-
tocol, most uses of FindGroupHashJ(r)∗  are for constants and do not return ⊥; the only use that could potentially
return ⊥ is in the computation of a default diversi  ed payment address in § 4.2.2 ‘Sapling Key Components’ on
p. 27.
5.4.9                                                                                                                        Zero-Knowledge Proving Systems
5.4.9.1                                                                                                                      BCTV14
Before Sapling activation, Zcash uses zk-SNARKs generated by a fork of libsnark [Zcash-libsnark] with the BCTV14
proving system described in [BCTV2014a], which is a modi  cation of the systems in [PHGR2013] and [BCGTV2013].
C  ◦ G1r)∗, πK  ◦ G1r)∗, πH  ◦ G1r)∗ ).
It is computed as described in [BCTV2014a, Appendix B], using the pairing parameters speci  ed in § 5.4.8.1 ‘BN-254’
on p. 65.
70




Note:   Many details of the proving system are beyond the scope of this protocol document.  For example, the
quadratic constraint program verifying the JoinSplit statement , or its translation to a Quadratic Arithmetic Pro-
gram [BCTV2014a, section 2.3], are not speci  ed in this document. In 2015, Bryan Parno found a bug in this trans-
lation, which is corrected by the libsnark implementation 5  [WCBTV2015] [Parno2015] [BCTV2014a, Remark 2.5].
In practice it will be necessary to use the speci  c proving and veri  cation keys that were generated for the Zcash
production block chain, given in § 5.7 ‘BCTV14 zk-SNARK Parameters’ on p. 77, together with a proving system
implementation that is interoperable with the Zcash fork of libsnark , to ensure compatibility.
Vulnerability disclosure:   BCTV14 is subject to a security vulnerability, separate from [Parno2015], that could
allow violation of Knowledge Soundness (and Soundness) [CVE-2019-7167] [SWB2019] [Gabizon2019]. The conse-
quence for Zcash is that balance violation could have occurred before activation of the Sapling network upgrade,
although there is no evidence of this having happened. Use of the vulnerability to produce false proofs is believed
to have been fully mitigated by activation of Sapling. The use of BCTV14 in Zcash is now limited to verifying proofs
that were made prior to the Sapling network upgrade.
Due to this issue, new forks of Zcash MUST NOT use BCTV14, and any other users of the Zcash protocol SHOULD
discontinue use of BCTV14 as soon as possible.
The vulnerability does not affect the Zero Knowledge property of the scheme (as described in any version of
[BCTV2014a] or as implemented in any version of libsnark that has been used in Zcash), even under subversion of
the parameter generation [BGG2016, Theorem 4.10].
Encoding of BCTV14 Proofs   A BCTV14 proof is encoded by concatenating the encodings of its elements; for the
BN-254 pairing this is:
264-bit πA                                                                                                                                  520-bit πB   264-bit πC   264-bit πK   264-bit πH
                                                                                                                                            A            B            C
The resulting proof size is 296 bytes.
In addition to the steps to verify a proof given in [BCTV2014a, Appendix B], the veri  er MUST check, for the en-
coding of each element, that:
•  the lead byte is of the required form;
•  the remaining bytes encode a big-endian representation of an integer in {0 .. qS −1} or (in the case of πB )
{0 .. qS2 −1};
•  the encoding represents a point in G1r)∗ or (in the case of πB ) G2r)∗, including checking that it is of order rG in
the latter case.
5.4.9.2                                                                                                                                     Groth16
After Sapling activation, Zcash uses zk-SNARKs with the proving system described in [Groth2016]. These are used
in transaction version 4 and later (§ 7.1 ‘Encoding of Transactions’ on p. 79) for proofs both in Sprout JoinSplit
descriptions , and in Sapling Spend descriptions and Output descriptions .  They are generated by the bellman
library [Bowe-bellman].
A Groth16 proof consists of (πA  ◦ S1r)∗, πB  ◦ S2r)∗, πC  ◦ S1r)∗ ). It is computed as described in [Groth2016, section 3.2],
using the pairing parameters speci  ed in § 5.4.8.2 ‘BLS12-381’ on p. 67. The proof elements are in a different order
to the presentation in [Groth2016].
5 Confusingly, the bug found by Bryan Parno was   xed in libsnark in 2015, but that   x was incompletely described in the May 2015 update
[BCTV2014a-old, Theorem 2.4]. It is described completely in [BCTV2014a, Theorem 2.4] and in [Gabizon2019].
71




Note:   The quadratic constraint programs verifying the Spend statement and Output statement are described in
Appendix A ‘Circuit Design’ on p. 121. However, many other details of the proving system are beyond the scope
of this protocol document.  For example, certain details of the translations of the Spend statement and Output
statement to Quadratic Arithmetic Programs are not speci  ed in this document.  In practice it will be neces-
sary to use the speci  c proving and veri  cation keys generated for the Zcash production block chain (see § 5.8
‘Groth16 zk-SNARK Parameters’ on p. 77), and a proving system implementation that is interoperable with the
bellman library used by Zcash, to ensure compatibility.
Encoding of Groth16 Proofs   A Groth16 proof is encoded by concatenating the encodings of its elements; for the
BLS12-381 pairing this is:
384-bit πA                                                                                                                768-bit πB                                     384-bit πC
The resulting proof size is 192 bytes.
In addition to the steps to verify a proof given in [Groth2016], the veri  er MUST check, for the encoding of each
element, that:
•  the leading bit  eld is of the required form;
•  the remaining bits encode a big-endian representation of an integer in {0 .. qS −1} or (in the case of πB ) two
integers in that range;
•  the encoding represents a point in S1r)∗ or (in the case of πB ) S2r)∗, including checking that it is of order rS in
each case.
5.5                                                                                                                       Encodings of Note Plaintexts and Memo Fields
As explained in § 3.2.1 ‘Note Plaintexts and Memo Fields’ on p. 13, transmitted notes are stored on the block chain
in encrypted form.
The note plaintexts in a JoinSplit description are encrypted to the respective transmission keys pkenc
,1..Nnew . Each
Sprout note plaintext (denoted np) consists of:
(v ◦   {0 .. 2ℓvalue −1}, ρ ◦   B[ℓPRFSprout ], rcm ◦   NoteCommitSprout.Output, memo ◦ BY[512] )
[Sapling onward]  The note plaintext in each Output description is encrypted to the diversi  ed transmission key
pkd. Each Sapling note plaintext (denoted np) consists of:
(d ◦   B[ℓd ], v ◦   {0 .. 2ℓvalue −1}, rcm ◦   NoteCommitSapling .Output, memo ◦ BY[512] )
memo is a 512-byte memo   eld associated with this note .
The usage of the memo   eld is by agreement between the sender and recipient of the note .  The memo   eld
SHOULD be encoded either as:
•  a UTF-8 human-readable string [Unicode], padded by appending zero bytes; or
•  an arbitrary sequence of 512 bytes starting with a byte value of 0xF5 or greater, which is therefore not a valid
UTF-8 string.
In the former case, wallet software is expected to strip any trailing zero bytes and then display the resulting UTF-8
string to the recipient user, where applicable. Incorrect UTF-8-encoded byte sequences SHOULD be displayed as
replacement characters (U+FFFD).
In the latter case, the contents of the memo   eld SHOULD NOT be displayed.  A start byte of 0xF5 is reserved
for use by automated software by private agreement. A start byte of 0xF6 followed by 511 0x00 bytes means “no
memo”. A start byte of 0xF6 followed by anything else, or a start byte of 0xF7 or greater, are reserved for use in
future Zcash protocol extensions.
Other   elds are as de  ned in § 3.2 ‘Notes’ on p. 12.
72




The encoding of a Sprout note plaintext consists of:
8-bit 0x00                                                                                                                                                            64-bit v                                                256-bit ρ                                                                                            256-bit rcm   memo (512 bytes)
                                                                                                                                                                                                                                          •  A byte, 0x00, indicating this version of the encoding of a Sprout note plaintext .
•                                                                                                                 8 bytes specifying v.
•                                                                                                                 32 bytes specifying ρ.
•                                                                                                                 32 bytes specifying rcm.
•                                                                                                                 512 bytes specifying memo.
                                                                                                                                                                      The encoding of a Sapling note plaintext consists of:
8-bit 0x01                                                                                                                                                            88-bit d                                                64-bit v                                                                                             256-bit rcm   memo (512 bytes)
                                                                                                                                                                                                                                          •  A byte, 0x01, indicating this version of the encoding of a Sapling note plaintext .
•                                                                                                                 11 bytes specifying d.
•                                                                                                                 8 bytes specifying v.
•                                                                                                                 32 bytes specifying rcm.
•                                                                                                                 512 bytes specifying memo.
5.6                                                                                                               Encodings of Addresses and Keys
This section describes how Zcash encodes shielded payment addresses , incoming viewing keys , and spending
keys .
Addresses and keys can be encoded as a byte sequence; this is called the raw encoding . This byte sequence can
then be further encoded using Base58Check. The Base58Check layer is the same as for upstream Bitcoin addresses
[Bitcoin-Base58].
For Sapling-speci  c key and address formats, Bech32 [BIP-173] is used instead of Base58Check. All conformance
requirements of BIP 173 apply except for the limit of 90 characters on an encoded Bech32 string (which does not
hold for Sapling viewing keys, for example), and requirements speci  c to Bitcoin’s Segwit addresses.
SHA-256 compression outputs are always represented as sequences of 32 bytes.
The language consisting of the following encoding possibilities is pre  x-free.
5.6.1                                                                                                             Transparent Addresses
Transparent addresses are either P2SH (Pay to Script Hash) addresses [BIP-13] or P2PKH (Pay to Public Key Hash)
addresses [Bitcoin-P2PKH].
The raw encoding of a P2SH address consists of:
8-bit 0x1C                                                                                                        8-bit 0xBD                                          160-bit script hash
•  Two bytes [0x1C, 0xBD], indicating this version of the raw encoding of a P2SH address on the production
network. (Addresses on the test network use [0x1C, 0xBA] instead.)
•                                                                                                                 20 bytes specifying a script hash [Bitcoin-P2SH].
73




The raw encoding of a P2PKH address consists of:
8-bit 0x1C                                                                                                                8-bit 0xB8                                                                                                    160-bit public key hash
                                                                                                                          •  Two bytes [0x1C, 0xB8], indicating this version of the raw encoding of a P2PKH address on the production
network. (Addresses on the test network use [0x1D, 0x25] instead.)
•                                                                                                                         20 bytes specifying a public key hash, which is a RIPEMD-160 hash [RIPEMD160] of a SHA-256 hash [NIST2015]
of a compressed ECDSA key encoding.
Notes:
•  In Bitcoin a single byte is used for the version  eld identifying the address type. In Zcash two bytes are used.
For addresses on the production network, this and the encoded length cause the   rst two characters of the
Base58Check encoding to be   xed as “t3” for P2SH addresses, and as “t1” for P2PKH addresses. (This does
not imply that a transparent Zcash address can be parsed identically to a Bitcoin address just by removing
the “t”.)
•  Zcash does not yet support Hierarchical Deterministic Wallet addresses [BIP-32].
5.6.2                                                                                                                     Transparent Private Keys
These are encoded in the same way as in Bitcoin [Bitcoin-Base58], for both the production and test networks.
5.6.3                                                                                                                     Sprout Shielded Payment Addresses
A Sprout shielded payment address consists of apk  ◦ B[ℓPRFSprout ] and pkenc  ◦ KASprout.Public.
apk is a SHA-256 compression output. pkenc is a KASprout.Public key (see § 5.4.4.1 ‘Sprout Key Agreement’ on p. 59),
for use with the encryption scheme de  ned in § 4.16 ‘In-band secret distribution (Sprout)’ on p. 44. These com-
ponents are derived from a spending key as described in § 4.2.1 ‘Sprout Key Components’ on p. 27.
The raw encoding of a Sprout shielded payment address consists of:
8-bit 0x16                                                                                                                8-bit 0x9A                                                                                                    256-bit apk                                                                                        256-bit pkenc
                                                                                                                                                                                                                                                                                                                                           •  Two bytes [0x16, 0x9A], indicating this version of the raw encoding of a Sprout shielded payment address on
                                                                                                                          the production network. (Addresses on the test network use [0x16, 0xB6] instead.)
• 32 bytes specifying apk .
•                                                                                                                                                                                                                                       32 bytes specifying pkenc, using the normal encoding of a Curve25519 public key [Bernstein2006].
Note:   For addresses on the production network, the lead bytes and encoded length cause the  rst two characters
of the Base58Check encoding to be   xed as “zc”. For the test network, the   rst two characters are   xed as “zt”.
5.6.4                                                                                                                     Sapling Shielded Payment Addresses
A Sapling shielded payment address consists of d ◦ B[ℓd ] and pkd  ◦ KASapling .PublicPrimeOrder.
pkd is an encoding of a KASapling public key of type KASapling .PublicPrimeOrder (see § 5.4.4.3 ‘Sapling Key Agreement’
on p. 59), for use with the encryption scheme de  ned in § 4.17 ‘In-band secret distribution (Sapling)’ on p. 45. d is
a sequence of 11 bytes. These components are derived as described in § 4.2.2 ‘Sapling Key Components’ on p. 27.
74




The raw encoding of a Sapling shielded payment address consists of:
                                                                                                                                                                                                                                                                                                                                                              (              )
                                                                                                                                                                                                                             LEBS2OSP88 (d)                                                                                                   LEBS2OSP256     reprJ (pkd )
•                                                                                                                        11 bytes specifying d.
•                                                                                                                                                                                                                                             32 bytes specifying the compressed Edwards encoding of pkd (see § 5.4.8.3 ‘Jubjub’ on p. 68).
When decoding the representation of pkd, the address is not valid if abstJ returns ⊥ or if the resulting pkd is not of
prime order.
For addresses on the production network, the Human-Readable Part is “zs”. For addresses on the test network,
the Human-Readable Part is “ztestsapling”.
5.6.5                                                                                                                    Sprout Incoming Viewing Keys
An incoming viewing key consists of apk  ◦ B[ℓPRFSprout ] and skenc  ◦ KASprout.Private.
apk is a SHA-256 compression output. skenc is a KASprout.Private key (see § 5.4.4.1 ‘Sprout Key Agreement’ on p. 59),
for use with the encryption scheme de  ned in § 4.16 ‘In-band secret distribution (Sprout)’ on p. 44. These com-
ponents are derived from a spending key as described in § 4.2.1 ‘Sprout Key Components’ on p. 27.
The raw encoding of an incoming viewing key consists of, in order:
8-bit 0xA8                                                                                                               8-bit 0xAB                                                                                          8-bit 0xD3       256-bit apk                                                                                     256-bit skenc
•  Three bytes [0xA8, 0xAB, 0xD3], indicating this version of the raw encoding of a Zcash incoming viewing key
on the production network. (Addresses on the test network use [0xA8, 0xAC, 0x0C] instead.)
•                                                                                                                        32 bytes specifying apk .
•                                                                                                                        32 bytes specifying skenc, using the normal encoding of a Curve25519 private key [Bernstein2006].
skenc  MUST be “clamped” using KASprout.FormatPrivate as speci  ed in § 4.2.1 ‘Sprout Key Components’ on p. 27.
That is, a decoded incoming viewing key MUST be considered invalid if skenc  , KASprout.FormatPrivate(skenc ).
KASprout.FormatPrivate is de  ned in § 5.4.4.1 ‘Sprout Key Agreement’ on p. 59.
Note:   For addresses on the production network, the lead bytes and encoded length cause the  rst four characters
of the Base58Check encoding to be  xed as “ZiVK”. For the test network, the  rst four characters are  xed as “ZiVt”.
5.6.6                                                                                                                    Sapling Incoming Viewing Keys
Let ℓivk be as de  ned in § 5.3 ‘Constants’ on p. 50.
A Sapling incoming viewing key consists of ivk ◦ {0 .. 2ℓivk −1}.
ivk is a KASapling .Private key (restricted to ℓivk bits), derived as described in § 4.2.2 ‘Sapling Key Components’ on
p. 27. It is used with the encryption scheme de  ned in § 4.17 ‘In-band secret distribution (Sapling)’ on p. 45.
75




The raw encoding of an incoming viewing key consists of:
256-bit ivk
•                                                                                                                         32 bytes (little-endian) specifying ivk, padded with zeros in the most signi  cant bits.
ivk MUST be in the range {0 .. 2ℓivk −1} as speci  ed in § 4.2.2 ‘Sapling Key Components’ on p. 27. That is, a decoded
incoming viewing key MUST be considered invalid if ivk is not in this range.
For incoming viewing keys on the production network, the Human-Readable Part is “zivks”. For incoming viewing
keys on the test network, the Human-Readable Part is “zivktestsapling”.
5.6.7                                                                                                                     Sapling Full Viewing Keys
A Sapling full viewing key consists of ak ◦ J(r)∗, nk ◦ J(r) , and ovk ◦ BY[ℓovk /8].
ak and nk are points on the Jubjub curve (see § 5.4.8.3 ‘Jubjub’ on p. 68). They are derived as described in § 4.2.2
‘Sapling Key Components’ on p. 27.
The raw encoding of a full viewing key consists of:
                                                                                                                                                                                                                     (                                                            )                                                                                              (            )
                                                                                                                          LEBS2OSP256                                                                                reprJ (ak)                                                   LEBS2OSP256                                                                                    reprJ (nk)       32-byte ovk
•                                                                                                                                                                                                                                                                                 32 bytes specifying the compressed Edwards encoding of ak (see § 5.4.8.3 ‘Jubjub’ on p. 68).
•                                                                                                                                                                                                                    32 bytes specifying the compressed Edwards encoding of nk.
•                                                                                                                         32 bytes specifying the outgoing viewing key ovk.
When decoding this representation, the key is not valid if abstJ returns ⊥ for either ak or nk, or if ak < J(r)∗, or if
nk < J(r) .
For incoming viewing keys on the production network, the Human-Readable Part is “zviews”. For incoming view-
ing keys on the test network, the Human-Readable Part is “zviewtestsapling”.
5.6.8                                                                                                                     Sprout Spending Keys
A Sprout spending key consists of ask , which is a sequence of 252 bits (see § 4.2.1 ‘Sprout Key Components’ on
p. 27).
The raw encoding of a Sprout spending key consists of:
8-bit 0xAB                                                                                                                8-bit 0x36                                                                                 [0]4                                                         252-bit ask
•  Two bytes [0xAB, 0x36], indicating this version of the raw encoding of a Zcash spending key on the production
network. (Addresses on the test network use [0xAC, 0x08] instead.)
•                                                                                                                         32 bytes: 4 zero padding bits and 252 bits specifying ask .
The zero padding occupies the most signi  cant 4 bits of the third byte.
76




Notes:
•  If an implementation represents ask internally as a sequence of 32 bytes with the 4 bits of zero padding intact,
it will be in the correct form for use as an input to PRFaddr , PRFnf , and PRFpk without need for bit-shifting.
Future key representations may make use of these padding bits.
•  For addresses on the production network, the lead bytes and encoded length cause the   rst two characters
of the Base58Check encoding to be   xed as “SK”. For the test network, the   rst two characters are   xed as
“ST”.
5.6.9                                                                                                                 Sapling Spending Keys
A Sapling spending key consists of sk ◦ B[ℓsk ] (see § 4.2.2 ‘Sapling Key Components’ on p. 27).
The raw encoding of a Sapling spending key consists of:
LEBS2OSP256 (sk)
•                                                                                                                     32 bytes specifying sk.
For spending keys on the production network, the Human-Readable Part is “secret-spending-key-main”.  For
spending keys on the test network, the Human-Readable Part is “secret-spending-key-test”.
5.7                                                                                                                   BCTV14 zk-SNARK Parameters
For the Zcash production block chain and testnet, the SHA-256 hashes of the proving key and verifying key for the
Sprout JoinSplit circuit , encoded in libsnark format, are:
8bc20a7f013b2b58970cddd2e7ea028975c88ae7ceb9259a5344a16bc2c0eef7  sprout-proving.key
4bd498dae0aacfd8e98dc306338d017d9c08dd0918ead18172bd0aec2fc5df82  sprout-verifying.key
These parameters were obtained by a multi-party computation described in [BGG-mpc] and [BGG2016]. They are
used only before Sapling activation. Due to the security vulnerability described in § 5.4.9.1 ‘BCTV14’ on p. 70, it
is not recommended to use these parameters in new protocols, and it is recommended to stop using them in
protocols other than Zcash where they are currently used.
5.8                                                                                                                   Groth16 zk-SNARK Parameters
bellman [Bowe-bellman] encodes the proving key and verifying key for a zk-SNARK circuit in a single parameters
le. The BLAKE2b-512 hashes of this  le for the Sapling Spend circuit and Output circuit , and for the implemen-
tation of the Sprout JoinSplit circuit used after Sapling activation, are respectively:
8270785a1a0d0bc77196f000ee6d221c9c9894f55307bd9357c3f0105d31ca63
991ab91324160d8f53e2bbd3c2633a6eb8bdf5205d822e7f3f73edac51b2b70c sapling-spend.params
657e3d38dbb5cb5e7dd2970e8b03d69b4787dd907285b5a7f0790dcc8072f60b
f593b32cc2d1c030e00ff5ae64bf84c5c3beb84ddc841d48264b4a171744d028  sapling-output.params
e9b238411bd6c0ec4791e9d04245ec350c9c5744f5610dfcce4365d5ca49dfef
d5054e371842b3f88fa1b9d7e8e075249b3ebabd167fa8b0f3161292d36c180a sprout-groth16.params
These parameters were obtained by a multi-party computation described in [BGM2018].
77




5.9                                                                                                                         Randomness Beacon
Let URS := “096b36a5804bfacef1691e173c366a47ff5ba84a44f26ddd7e8d9f79d5b42df0”.
This value is used in the de  nition of GroupHashJ(r)∗  in § 5.4.8.5 ‘Group Hash into Jubjub’ on p. 70, and in the multi-
party computation to obtain the Sapling parameters given in § 5.8 ‘Groth16 zk-SNARK Parameters’ on p. 77.
It is derived as described in [Bowe2018]:
•  Take the hash of the Bitcoin block at height 514200 in RPC byte order [Bitcoin-Order], i.e. the big-endian
32-byte representation of 0x00000000000000000034b33e842ac1c50456abe5fa92b60f6b3dfc5d247f7b58.
•  Apply SHA-256 242 times.
•  Convert to a US-ASCII lowercase hexadecimal string.
Note:   URS is a 64-byte US-ASCII string, i.e. the   rst byte is 0x30, not 0x09.
6                                                                                                                           Network Upgrades
Zcash launched with a protocol revision that we call Sprout. A  rst network upgrade, called Overwinter, activated
on the production Zcash network on 26 June 2018 at block height 347500 [Swihart2018]. A second upgrade, called
Sapling, activated on the production network on 28 October 2018 at block height 419200 [Hamdon2018].  This
section summarizes the strategy for upgrading from Sprout to Overwinter to Sapling, and then to future upgrades.
The upgrade mechanism is described in [ZIP-200]. The speci  cations of the Overwinter upgrade are described
in this document, [ZIP-201], [ZIP-202], [ZIP-203], and [ZIP-143]. The speci  cations of the Sapling upgrade are de-
scribed in this document, [ZIP-205], and [ZIP-243].
Each network upgrade is introduced as a “bilateral consensus rule change ”. In this kind of upgrade,
•  there is a block height at which the consensus rule change takes effect;
•  blocks and transactions that are valid according to the post-upgrade rules are not valid before the upgrade
block height ;
•  blocks and transactions that are valid according to the pre-upgrade rules are no longer valid at or after the
upgrade block height .
Full support for each upgrade is indicated by a minimum version of the peer-to-peer protocol. At the planned
upgrade block height , nodes that support a given upgrade will disconnect from (and will not reconnect to) nodes
with a protocol version lower than this minimum. See [ZIP-201] for how this applies to the Overwinter upgrade.
This ensures that upgrade-supporting nodes transition cleanly from the old protocol to the new protocol. Nodes
that do not support the upgrade will  nd themselves on a network that uses the old protocol and is fully partitioned
from the upgrade-supporting network. This allows us to specify arbitrary protocol changes that take effect at a
given block height .
Note, however, that a block chain reorganization across the upgrade block height is possible. In the case of such
a reorganization, blocks at a height before the upgrade block height will still be created and validated according
to the pre-upgrade rules, and upgrade-supporting nodes MUST allow for this.
78




7                                                                                                                                                                   Consensus Changes from Bitcoin
7.1                                                                                                                   Encoding of Transactions
                                                                                                                      The Zcash transaction format is as follows:
Version                                                                                                               Bytes                                         Name                             Data Type              Description
≥ 1                                                                                                                   4                                             header                           uint32                 Contains:
                                                                                                                                                                                                                            ·  fOverwintered  ag (bit 31)
                                                                                                                                                                                                                            ·  version (bits 30 .. 0) - transaction version.
≥ 3                                                                                                                   4                                             nVersionGroupId                  uint32                 Version group ID (nonzero).
≥ 1                                                                                                                   Varies                                        tx_in_count                      compactSize uint       Number of transparent inputs in this
                                                                                                                                                                                                                            transaction.
≥ 1                                                                                                                   Varies                                        tx_in                            tx_in                  Transparent inputs, encoded as in Bitcoin.
≥ 1                                                                                                                   Varies                                        tx_out_count                     compactSize uint       Number of transparent outputs in this
                                                                                                                                                                                                                            transaction.
≥ 1                                                                                                                   Varies                                        tx_out                           tx_out                 Transparent outputs, encoded as in Bitcoin.
≥ 1                                                                                                                   4                                             lock_time                        uint32                 A Unix epoch time (UTC) or block height ,
encoded as in Bitcoin.
≥ 3                                                                                                                   4                                             nExpiryHeight                    uint32                 A block height in the range {1 .. 499999999}
after which the transaction will expire, or 0 to
disable expiry ([ZIP-203]).
≥ 4                                                                                                                   8                                             valueBalance                     int64                                                                     The net value of Sapling Spend transfers
                                                                                                                                                                                                                                                                               minus Output transfers .
≥ 4                                                                                                                   Varies                                        nShieldedSpend                   compactSize uint                                                          The number of Spend descriptions in
                                                                                                                                                                                                                            vShieldedSpend.
≥ 4                                                                                                                   384·                                          vShieldedSpend                   SpendDescription                                                          A sequence of Spend descriptions , each
                                                                                                                      nShieldedSpend                                                                 [nShieldedSpend]       encoded as in § 7.3
                                                                                                                                                                                                                                                                               ‘Encoding of Spend Descriptions’ on p. 83.
≥ 4                                                                                                                   Varies                                        nShieldedOutput                  compactSize uint                                                          The number of Output descriptions in
                                                                                                                                                                                                                            vShieldedOutput.
≥ 4                                                                                                                   948·                                          vShieldedOutput                  OutputDescription                                                         A sequence of Output descriptions , each
                                                                                                                      nShieldedOutput                                                                [nShieldedOutput]      encoded as in § 7.4
                                                                                                                                                                                                                                                                               ‘Encoding of Output Descriptions’ on p. 83.
≥ 2                                                                                                                   Varies                                        nJoinSplit                       compactSize uint                                                          The number of JoinSplit descriptions in
                                                                                                                                                                                                                            vJoinSplit.
2 .. 3                                                                                                                1802·                                         vJoinSplit                       JSDescriptionBCTV14                                                       A sequence of JoinSplit descriptions using
                                                                                                                      nJoinSplit                                                                     [nJoinSplit]                                                              BCTV14 proofs, each encoded as in § 7.2
                                                                                                                                                                                                                                                                               ‘Encoding of JoinSplit Descriptions’ on p. 82.
≥ 4                                                                                                                   1698·                                         vJoinSplit                       JSDescriptionGroth16                                                      A sequence of JoinSplit descriptions using
                                                                                                                      nJoinSplit                                                                     [nJoinSplit]                                                              Groth16 proofs, each encoded as in § 7.2
‘Encoding of JoinSplit Descriptions’ on p. 82.
≥ 2 †                                                                                                                 32                                            joinSplitPubKey                  char[32]               An encoding of a JoinSplitSig public
veri  cation key.
≥ 2 †                                                                                                                 64                                            joinSplitSig                     char[64]               A signature on a pre  x of the transaction
encoding, to be veri  ed using
joinSplitPubKey.
≥ 4 ‡                                                                                                                 64                                            bindingSig                       char[64]               A signature on the SIGHASH transaction hash,
to be veri  ed as speci  ed in § 5.4.6.2
‘Binding Signature’ on p. 63.
† The joinSplitPubKey and joinSplitSig  elds are present if and only if version ≥ 2 and nJoinSplit > 0. The
encoding of joinSplitPubKey and the data to be signed are speci  ed in § 4.10 ‘Non-malleability (Sprout)’ on p. 36.
‡ The bindingSig  eld is present if and only if version ≥ 4 and nShieldedSpend + nShieldedOutput > 0.
79




Consensus rules:
•                                                                                                                                                                                                                                 The transaction version number MUST be greater than or equal to 1.
•                                                                                                                     [Pre-Overwinter ] The fOverwintered  ag MUST NOT be set.
•                                                                                                                     [Overwinter onward] The fOverwintered  ag MUST be set.
•                                                                                                                                                                                                                                 [Overwinter onward] The version group ID MUST be recognized.
•                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              [Overwinter only, pre-Sapling] The transaction version number MUST be 3 and the version group ID MUST
be 0x03C48270.
•                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              [Sapling onward] The transaction version number MUST be 4 and the version group ID MUST be 0x892F2085.
•                                                                                                                                                                                                                                                                                                                                                                                                                             [Pre-Sapling ] The encoded size of the transaction MUST be less than or equal to 100000 bytes.
•                                                                                                                                                                                                                                                                                                                 [Pre-Sapling ] If version = 1 or nJoinSplit = 0, then tx_in_count MUST NOT be 0.
•                                                                                                                                                                                                                                                                                                                                                                                                                             [Sapling onward] At least one of tx_in_count, nShieldedSpend, and nJoinSplit MUST be nonzero.
•                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              A transaction with one or more inputs from coinbase transactions MUST have no transparent outputs (i.e.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               tx_out_count MUST be 0). Note that inputs from coinbase transactions include Founders’ Reward outputs.
• If version ≥ 2 and nJoinSplit > 0, then:
-  joinSplitPubKey MUST represent a valid Ed25519 public key encoding (§ 5.4.5 ‘JoinSplit Signature’ on
p. 60).
-  joinSplitSig MUST represent a valid signature under joinSplitPubKey of dataToBeSigned, as de  ned
in § 4.10 ‘Non-malleability (Sprout)’ on p. 36.
•                                                                                                                     [Sapling onward] If version ≥ 4 and nShieldedSpend + nShieldedOutput > 0, then:
-  let bvk and SigHash be as de  ned in § 4.12 ‘Balance and Binding Signature (Sapling)’ on p. 37;
-  bindingSig MUST represent a valid signature under the transaction binding veri  cation key  bvk of
SigHash — i.e. BindingSig.Verifybvk (SigHash, bindingSig) = 1.
•                                                                                                                     [Sapling onward] If version ≥ 4 and nShieldedSpend + nShieldedOutput = 0, then valueBalance MUST be 0.
•                                                                                                                     A coinbase transaction MUST NOT have any JoinSplit descriptions , Spend descriptions , or Output descrip-
tions .
•                                                                                                                     A transaction MUST NOT spend an output of a coinbase transaction (necessarily a transparent output) from
a block less than 100 blocks prior to the spend. Note that outputs of coinbase transactions include Founders’
Reward outputs.
•                                                                                                                     [Overwinter onward] nExpiryHeight MUST be less than or equal to 499999999.
•                                                                                                                                                                                                                                                                                                                 [Overwinter onward] If a transaction is not a coinbase transaction and its nExpiryHeight  eld is nonzero,
                                                                                                                      then it MUST NOT be mined at a block height greater than its nExpiryHeight.
•                                                                                                                                                                                                                                 [Sapling onward] valueBalance MUST be in the range {−MAX_MONEY .. MAX_MONEY}.
• TODO: Other rules inherited from Bitcoin.
In addition, consensus rules associated with each JoinSplit description (§ 7.2 ‘Encoding of JoinSplit Descriptions’
on p. 82), each Spend description (§ 7.3 ‘Encoding of Spend Descriptions’ on p. 83), and each Output description
(§ 7.4 ‘Encoding of Output Descriptions’ on p. 83) MUST be followed.
Notes:
•  Previous versions of this speci  cation de  ned what is now the header  eld as a signed int32                      eld which was
required to be positive. The consensus rule that the fOverwintered  ag MUST NOT be set before Overwinter
has activated, has the same effect.
•  The semantics of transactions with transaction version number not equal to 1, 2, 3, or 4 is not currently
de  ned. Miners MUST NOT create blocks before the Overwinter activation block height containing trans-
actions with version other than 1 or 2.
80




•  The exclusion of transactions with transaction version number greater than 2 is not a consensus rule before
Overwinter activation. Such transactions may exist in the block chain and MUST be treated identically to
version 2 transactions .
•                                                                                                                   [Overwinter onward] Once Overwinter has activated, limits on the maximum transaction version number
are consensus rules.
•  Note that a future upgrade might use any transaction version number or version group ID . It is likely that an
upgrade that changes the transaction version number or version group ID will also change the transaction
format, and software that parses transactions SHOULD take this into account.
•                                                                                                                   [Overwinter onward] The purpose of version group ID is to allow unambiguous parsing of “loose ” transac-
tions , independent of the context of a block chain. Code that parses transactions is likely to be reused be-
tween block chain branches as de  ned in [ZIP-200], and in that case the fOverwintered and version  elds
alone may be insuf  cient to determine the format to be used for parsing.
•  A transaction version number of 2 does not have the same meaning as in Bitcoin, where it is associated with
support for OP_CHECKSEQUENCEVERIFY as speci  ed in [BIP-68]. Zcash was forked from Bitcoin v0.11.2 and does
not currently support BIP 68.
The changes relative to Bitcoin version 1 transactions as described in [Bitcoin-Format] are:
•  Transaction version 0 is not supported.
•  A version 1 transaction is equivalent to a version 2 transaction with nJoinSplit = 0.
•  The nJoinSplit, vJoinSplit, joinSplitPubKey, and joinSplitSig  elds have been added.
•  In Zcash it is permitted for a transaction to have no transparent inputs provided that nJoinSplit > 0.
•  A consensus rule limiting transaction size has been added. In Bitcoin there is a corresponding standard rule
but no consensus rule.
[Pre-Overwinter ]  Software that creates transactions SHOULD use version 1 for transactions with no JoinSplit
descriptions .
81




7.2                                                                                                            Encoding of JoinSplit Descriptions
                                                                                                               An abstract JoinSplit description, as described in § 3.5 ‘JoinSplit Transfers and Descriptions’ on p. 15, is encoded
                                                                                                               in a transaction as an instance of a JoinSplitDescription type as follows:
Bytes                                                                                                          Name                                                                                                                   Data Type         Description
8                                                                                                              vpub_old                                                                                                               uint64            A value vpudb that the JoinSplit transfer removes from
the transparent value pool .
8                                                                                                              vpub_new                                                                                                               uint64            A value vpub that the JoinSplit transfer inserts into the
transparent value pool .
32                                                                                                             anchor                                                                                                                 char[32]          A root rt of the Sprout note commitment tree at some
block height in the past, or the root produced by a
previous JoinSplit transfer in this transaction.
64                                                                                                             nullifiers                                                                                                             char[32][Nold]    A sequence of nulli  ers of the input notes nfold
                                                                                                                                                                                                                                                        1..Nold .
64                                                                                                             commitments                                                                                                            char[32][Nnew]    A sequence of note commitments for the output
                                                                                                                                                                                                                                                        notes cm1.w
                                                                                                                                                                                                                                                        .Nnew .
32                                                                                                             ephemeralKey                                                                                                           char[32]          A Curve25519 public key epk.
32                                                                                                             randomSeed                                                                                                             char[32]          A 256-bit seed that must be chosen independently at
random for each JoinSplit description.
64                                                                                                             vmacs                                                                                                                  char[32][Nold]    A sequence of message authentication tags h1..Nold
binding hSig to each ask of the JoinSplit description,
computed as described in § 4.10
‘Non-malleability (Sprout)’ on p. 36.
296 †                                                                                                          zkproof                                                                                                                char[296]         An encoding of the zero-knowledge proof  πZKJoinSplit
(see § 5.4.9.1 ‘BCTV14’ on p. 70).
192 ‡                                                                                                          zkproof                                                                                                                char[192]         An encoding of the zero-knowledge proof  πZKJoinSplit
(see § 5.4.9.2 ‘Groth16’ on p. 71).
1202                                                                                                           encCiphertexts                                                                                                         char[601][Nnew]   A sequence of ciphertext components for the
..Nnew .
† BCTV14 proofs are used when the transaction version is 2 or 3, i.e. before Sapling activation.
‡ Groth16 proofs are used when the transaction version is ≥ 4, i.e. after Sapling activation.
The ephemeralKey and encCiphertexts  elds together form the transmitted notes ciphertext , which is computed
as described in § 4.16 ‘In-band secret distribution (Sprout)’ on p. 44.
Consensus rules applying to a JoinSplit description are given in § 4.3 ‘JoinSplit Descriptions’ on p. 29.
82




7.3                                                                                                                          Encoding of Spend Descriptions
Let LEBS2OSP be as de  ned in § 5.2 ‘Integers, Bit Sequences, and Endianness’ on p. 49.
Let reprJ and qJ be as de  ned in § 5.4.8.3 ‘Jubjub’ on p. 68.
An abstract Spend description, as described in § 3.6 ‘Spend Transfers, Output Transfers, and their Descriptions’
on p. 15, is encoded in a transaction as an instance of a SpendDescription type as follows:
Bytes                                                                                                                        Name                              Data Type   Description
32                                                                                                                           cv                                char[32]    A value comm(itment t) the value of the input note ,
                                                                                                                                                                           LEBS2OSP256  reprJ (cv) .
32                                                                                                                           anchor                            char[32]    A root of the Sapling note commitment tree at some block
                                                                                                                                                                           height in the past, LEBS2OSP256 (rt).
32                                                                                                                           nullifier                         char[32]    The nulli  er of the input note , LEBS2OSP256 (nf ).
32                                                                                                                           rk                                char[32]    The randomiz(ed publi) key for spendAuthSig,
LEBS2OSP256  reprJ (rk) .
192                                                                                                                          zkproof                           char[192]   An encoding of the zero-knowledge proof πZKSpend (see § 5.4.9.2
‘Groth16’ on p. 71).
64                                                                                                                           spendAuthSig                      char[64]    A signature authorizing this spend.
Consensus rule:   LEOS2IP256 (anchor) MUST be less than qJ.
Other consensus rules applying to a Spend description are given in § 4.4 ‘Spend Descriptions’ on p. 30.
7.4                                                                                                                          Encoding of Output Descriptions
Let LEBS2OSP be as de  ned in § 5.2 ‘Integers, Bit Sequences, and Endianness’ on p. 49.
Let reprJ and qJ be as in § 5.4.8.3 ‘Jubjub’ on p. 68, and ExtractJ(r)  as in § 5.4.8.5 ‘Group Hash into Jubjub’ on p. 70.
An abstract Output description, described in § 3.6 ‘Spend Transfers, Output Transfers, and their Descriptions’
on p. 15, is encoded in a transaction as an instance of an OutputDescription type as follows:
Bytes                                                                                                                        Name                              Data Type                                                                     Description
32                                                                                                                           cv                                char[32]                                                                      A value comm(itment t) the value of the output note ,
                                                                                                                                                                           LEBS2OSP256  reprJ (cv) .
32                                                                                                                           cmu                               char[32]                                                                      The u-coordinate of the note commitment for the output
                                                                                                                                                                                                                                             note , LEBS2OSP256 (cmu ) where cmu  = ExtractJ(r) (cm).
32                                                                                                                           ephemeralKey                      char[32]
                                                                                                                                                                           (                                                                 )
                                                                                                                                                                           LEBS2OSP256                                                       reprJ (epk)
580                                                                                                                          encCiphertext                     char[580]                                                                     A ciphertext component for the encrypted output note , Cenc.
80                                                                                                                           outCiphertext                     char[80]                                                                      A ciphertext component for the encrypted output note , Cout.
192                                                                                                                          zkproof                           char[192]                                                                     An encoding of the zero-knowledge proof  πZKOutput (see
§ 5.4.9.2 ‘Groth16’ on p. 71).
The ephemeralKey, encCiphertext, and outCiphertext  elds together form the transmitted note ciphertext , which
is computed as described in § 4.17 ‘In-band secret distribution (Sapling)’ on p. 45.
83




Consensus rule:   LEOS2IP256 (cmu) MUST be less than qJ.
Other consensus rules applying to an Output description are given in § 4.5 ‘Output Descriptions’ on p. 31.
7.5                                                                                                                   Block Header
                                                                                                                      The Zcash block header format is as follows:
Bytes                                                                                                                 Name                                           Data Type          Description
4                                                                                                                     nVersion                                       int32              The block version number indicates which
set of block validation rules to follow. The
current and only de  ned block version
number for Zcash is 4.
32                                                                                                                    hashPrevBlock                                  char[32]           A SHA-256d hash in internal byte order of
the previous block ’s header . This ensures no
previous block can be changed without also
changing this block ’s header .
32                                                                                                                    hashMerkleRoot                                 char[32]           A SHA-256d hash in internal byte order. The
merkle root is derived from the hashes of all
transactions included in this block , ensuring
that none of those transactions can be
modi  ed without modifying the header .
32                                                                                                                    hashReserved /                                 char[32]           [Pre-Sapling ] A reserved   eld which should
                                                                                                                      hashFinalSaplingRoot                                              be ignored. [Sapling onward] The root
LEBS2OSP256 (rt) of the Sapling note
commitment tree corresponding to the   nal
Sapling treestate of this block .
4                                                                                                                     nTime                                          uint32             The block time is a Unix epoch time (UTC)
when the miner started hashing the header
(according to the miner).
4                                                                                                                     nBits                                          uint32             An encoded version of the target threshold
this block ’s header hash must be less than or
equal to, in the same nBits format used by
Bitcoin. [Bitcoin-nBits]
32                                                                                                                    nNonce                                         char[32]           An arbitrary   eld that miners can change to
modify the header hash in order to produce
a hash less than or equal to the target
threshold .
3                                                                                                                     solutionSize                                   compactSize uint   The size of an Equihash solution in bytes
(always 1344).
1344                                                                                                                  solution                                       char[1344]         The Equihash solution.
A block consists of a block header and a sequence of transactions . How transactions are encoded in a block is
part of the Zcash peer-to-peer protocol but not part of the consensus protocol.
Let ThresholdBits be as de  ned in § 7.6.3 ‘Difficulty adjustment’ on p. 87, and let PoWMedianBlockSpan be the con-
stant de  ned in § 5.3 ‘Constants’ on p. 50.
84




Consensus rules:
•  The block version number MUST be greater than or equal to 4.
•  For a block at block height height, nBits MUST be equal to ThresholdBits(height).
•  The block MUST pass the dif  culty   lter de  ned in § 7.6.2 ‘Difficulty filter’ on p. 87.
•  solution MUST represent a valid Equihash solution as de  ned in § 7.6.1 ‘Equihash’ on p. 86.
•  nTime MUST be strictly greater than the median time of the previous PoWMedianBlockSpan blocks .
•  The size of a block MUST be less than or equal to 2000000 bytes.
•                                                                                                                       [Sapling onward] hashFinalSaplingRoot MUST be LEBS2OSP256 (rt) where rt is the root of the Sapling note
commitment tree for the   nal Sapling treestate of this block .
•  TODO: Other rules inherited from Bitcoin.
In addition, a full validator MUST NOT accept blocks with nTime more than two hours in the future according to
its clock. This is not strictly a consensus rule because it is nondeterministic, and clock time varies between nodes.
Also note that a block that is rejected by this rule at a given point in time may later be accepted.
Notes:
•  The semantics of blocks with block version number not equal to 4 is not currently de  ned. Miners MUST
NOT create such blocks , and SHOULD NOT mine other blocks that chain to them.
•  The exclusion of blocks with block version number  greater than 4 is not a consensus rule; such blocks may
exist in the block chain and MUST be treated identically to version 4 blocks by full validators . Note that a
future upgrade might use block version number either greater than or less than 4. It is likely that such an
upgrade will change the block header and/or transaction format, and software that parses blocks SHOULD
take this into account.
•  The nVersion  eld is a signed integer. (It was speci  ed as unsigned in a previous version of this speci  cation.)
A future upgrade might use negative values for this   eld, or otherwise change its interpretation.
•  There is no relation between the values of the version  eld of a transaction, and the nVersion  eld of a block
header .
•  Like other serialized   elds of type compactSize uint, the solutionSize  eld MUST be encoded with the
minimum number of bytes (3 in this case), and other encodings MUST be rejected. This is necessary to avoid
a potential attack in which a miner could test several distinct encodings of each Equihash solution against
the dif  culty   lter, rather than only the single intended encoding.
•  As in Bitcoin, the nTime  eld MUST represent a time strictly greater than the median of the timestamps
of the past PoWMedianBlockSpan blocks . The Bitcoin Developer Reference [Bitcoin-Block] was previously in
error on this point, but has now been corrected.
•  There are no changes to the block version number or format for Overwinter.
•  Although the block version number does not change for Sapling, the previously reserved (and ignored)  eld
hashReserved has been repurposed for hashFinalSaplingRoot. There are no other format changes.
The changes relative to Bitcoin version 4 blocks as described in [Bitcoin-Block] are:
•  Block versions less than 4 are not supported.
•  The hashReserved (or hashFinalSaplingRoot), solutionSize, and solution  elds have been added.
•  The type of the nNonce  eld has changed from uint32 to char[32].
•  The maximum block size has been doubled to 2000000 bytes.
85




7.6                                                                                                                          Proof of Work
Zcash uses Equihash [BK2016] as its Proof of Work. Motivations for changing the Proof of Work from SHA-256d
used by Bitcoin are described in [WG2016].
A block satis  es the Proof of Work if and only if:
•  The solution  eld encodes a valid Equihash solution according to § 7.6.1 ‘Equihash’ on p. 86.
•  The block header satis  es the dif  culty check according to § 7.6.2 ‘Difficulty filter’ on p. 87.
7.6.1                                                                                                                        Equihash
An instance of the Equihash algorithm is parameterized by positive integers n and k, such that n is a multiple of
k + 1. We assume k ≥ 3.
The Equihash parameters for the production and test networks are n = 200, k = 9.
The Generalized Birthday Problem is de  ned as follows: given a sequence X1 .. N of n-bit strings,   nd 2k distinct
⊕2k
Xi                                                                                                                           such that                Xi                = 0.
                                                                                                                             j                        j=1               j
                                                                                                                                                                                               In Equihash, N = 2 k+1 +1, and the sequence X1 .. N is derived from the block header and a nonce.
Let powheader :=
                                                                                                                                                      32-bit nVersion                          256-bit hashPrevBlock                                                                                                             256-bit hashMerkleRoot
                                                                                                                                                                        256-bit hashReserved                                                                                                       32-bit nTime   32-bit nBits                            256-bit nNonce
For i ∈ {1 .. N }, let Xi  = EquihashGenn,k (powheader, i).
EquihashGen is instantiated in § 5.4.1.9 ‘Equihash Generator’ on p. 57.
De  ne I2BEBSP ◦ (ℓ ◦ N) × {0 .. 2ℓ −1} → B[ℓ] as in § 5.2 ‘Integers, Bit Sequences, and Endianness’ on p. 49.
A valid Equihash solution is then a sequence i ◦ {1 .. N }2k  that satis  es the following conditions:
⊕
Generalized Birthday condition                                                                                               Xi                       = 0.
j
j=1
Algorithm Binding conditions
⊕
•  For all r ∈ {1 .. k −1}, for all w ∈ {0 .. 2k−r −1} :                                                                     Xi
                                                                                                                             +1  leading zeros; and
j=1
•  For all r ∈ {1 .. k}, for all w ∈ {0 .. 2k−r −1} : iw·2r +1..w·2r +2r−1  < iw·2r +2r−1 +1..w·2r +2r  lexicographically.
Notes:
•  This does not include a dif  culty condition, because here we are de  ning validity of an Equihash solution
independent of dif  culty.
•  Previous versions of this speci  cation incorrectly speci  ed the range of r to be {1 .. k −1} for both parts of
the algorithm binding condition. The implementation in zcashd was as intended.
An Equihash solution with n = 200 and k = 9 is encoded in the solution  eld of a block header as follows:
I2BEBSP21 (i1 − 1)                                                                                                           I2BEBSP21 (i2 − 1)       · · ·             I2BEBSP21 (i512 − 1)
86




Recall from § 5.2 ‘Integers, Bit Sequences, and Endianness’ on p. 49 that bits in the above diagram are ordered
from most to least signi  cant in each byte. For example, if the   rst 3 elements of i are [69, 42, 221], then the corre-
sponding bit array is:
                                                                                                                                                                                           I2BEBSP21 (68)                                                                                                      I2BEBSP21 (41)                                                                                                          I2BEBSP21 (221 − 1)
0                                                                                                                            0                       0   0         0   0   0   0   0   0   0                0         0   0   1   0   0   0   1   0          0   0   0   0   0   0   0   0         0   0   0   0                0   0   0   0          1   0   1   0   0   1   1   1           1   1   1   1   1   1   1   1           1                     1   1   1   1   1   1   1       1   1   1
                                                                                                                                                         8-bit 0                                            8-bit 2                               8-bit 32                               8-bit 0                                            8-bit 10                               8-bit 127                               8-bit 255                                                 · · ·
and so the   rst 7 bytes of solution would be [0, 2, 32, 0, 10, 127, 255].
Note:   I2BEBSP is big-endian, while integer   eld encodings in powheader and in the instantiation of EquihashGen
are little-endian. The rationale for this is that little-endian serialization of block headers is consistent with Bitcoin,
but little-endian ordering of bits in the solution encoding would require bit-reversal (as opposed to only shifting).
7.6.2                                                                                                                        Dif  culty   lter
Let ToTarget be as de  ned in § 7.6.4 ‘nBits conversion’ on p. 88.
Dif  culty is de  ned in terms of a target threshold , which is adjusted for each block according to the algorithm
de  ned in § 7.6.3 ‘Difficulty adjustment’ on p. 87.
The dif  culty   lter is unchanged from Bitcoin, and is calculated using SHA-256d on the whole block header (in-
cluding solutionSize and solution). The result is interpreted as a 256-bit integer represented in little-endian byte
order, which MUST be less than or equal to the target threshold given by ToTarget(nBits).
7.6.3                                                                                                                        Dif  culty adjustment
Zcash uses a dif  culty adjustment algorithm based on DigiShield v3/v4 [DigiByte-PoW], with simpli  cations and
altered parameters, to adjust dif  culty to target the desired 2.5-minute block time. Unlike Bitcoin, the dif  culty
adjustment occurs after every block.
The constants PoWLimit, PoWAveragingWindow, PoWMaxAdjustDown, PoWMaxAdjustUp, PoWDampingFactor, and
PoWTargetSpacing are instantiated in § 5.3 ‘Constants’ on p. 50.
Let ToCompact and ToTarget be as de  ned in § 7.6.4 ‘nBits conversion’ on p. 88.
Let nTime(height) be the value of the nTime  eld in the header of the block at block height height.
Let nBits(height) be the value of the nBits  eld in the header of the block at block height height.
Block header   elds are speci  ed in § 7.5 ‘Block Header’ on p. 84.
De  ne:
∑length(S )
i=1                                                                                                                          Si
mean(S ) :=
length(S )
median(S ) := sorted(S )ceiling
(length(S )/2)
ower (x) := max(lower, min(upper, x)))
{
floor(x) ,                                                                                                                   if x ≥ 0
trunc(x) :=
−floor(−x) ,  otherwise
AveragingWindowTimespan := PoWAveragingWindow · PoWTargetSpacing
MinActualTimespan := floor(AveragingWindowTimespan · (1 − PoWMaxAdjustUp))
MaxActualTimespan := floor(AveragingWindowTimespan · (1 + PoWMaxAdjustDown))
MedianTime(height) := median([[ nTime(i) for i from max(0, height − PoWMedianBlockSpan) up to height − 1 ]])
87




ActualTimespan(height) := MedianTime(height) − MedianTime(height − PoWAveragingWindow)
                                                                                                                                                                                                                                                                                                                (                                                                                                                )
                                                                                                                                                                                                                                                                                                                                          ActualTimespan(height) − AveragingWindowTimespan
                                                                                                                       ActualTimespanDamped(height) := AveragingWindowTimespan + trunc
                                                                                                                                                                                                                                                                                                                                                                                             PoWDampingFactor
                                                                                                                                                                                                                      nActualTimespan (ActualTimespanDamped(height))
                                                                                                                       
                                                                                                                                                                                        PoWLimit,                                                                                                                                        if height ≤ PoWAveragingWindow
MeanTarget(height) :=                                                                                                                                                                                                 mean([[ ToTarget(nBits(i)) for i from height − PoWAveragingWindow up to height − 1 ]]),
                                                                                                                       
otherwise.
The target threshold for a given block height height is then calculated as:

                                                                                                                                                                                        PoWLimit,                                                                                                                                                                                           if height = 0
                                                                                                                                                                                                                     (                                                                                                                   )
                                                                                                                                                                                                                                                                                                                MeanTarget(height)
Threshold(height)                                                                                                      :=                                                                min(PoWLimit, floor                                                                                                                                                                                 · ActualTimespanBounded(height)),
                                                                                                                                                                                                                                                                                                               AveragingWindowTimespan

otherwise
ThresholdBits(height) := ToCompact(Threshold(height)).
Note:   The convention used for the height parameters to MedianTime, ActualTimespan, ActualTimespanDamped,
ActualTimespanBounded, MeanTarget, Threshold, and ThresholdBits is that these functions use only information from
blocks preceding the given block height .
On the test network from block height  299188 onward, the dif  culty adjustment algorithm is changed to allow
minimum-dif  culty blocks , as described in [ZIP-205]. This change does not apply to the production network.
7.6.4                                                                                                                  nBits conversion
Deterministic conversions between a target threshold and a “compact" nBits value are not fully de  ned in the
Bitcoin documentation [Bitcoin-nBits], and so we de  ne them here:
(                                                                                                                      )
bitlength(x)
size(x) := ceiling
8
(
                                                                                                                       mantissa(x) := floor                                              x · 2563−size(x) )
                                                                                                                       {
                                                                                                                                                                                                                      if mantissa(x) < 223
                                                                                                                                                                                         )
                                                                                                                       ToCompact(x) :=
                                                                                                                                                                                         floor  mantissa(x)           + 224 · (size(x) + 1),  otherwise
                                                                                                                                                                                         256
                                                                                                                       {
                                                                                                                       0,                                                                                             if x î 223  = 223
                                                                                                                                                                                         (                            )
ToTarget(x) :=
                                                                                                                                                                                                                      x/224
                                                                                                                                                                                         (x î (223 − 1)) · 256floor   −3,  otherwise.
7.6.5                                                                                                                  De  nition of Work
As explained in § 3.3 ‘The Block Chain’ on p. 14, a node chooses the “best” block chain visible to it by   nding the
chain of valid blocks with the greatest total work.
Let ToTarget be as de  ned in § 7.6.4 ‘nBits conversion’ on p. 88.
(                                                                                                                      )
2256
The work of a block with value nBits for the nBits  eld in its block header is de  ned as floor
ToTarget(nBits) + 1
88




7.7                                                                                                                         Calculation of Block Subsidy and Founders’ Reward
§ 3.9 ‘Block Subsidy and Founders’ Reward’ on p. 17 de  nes the block subsidy , miner subsidy , and Founders’
Reward . Their amounts in zatoshi are calculated from the block height using the formulae below. The constants
SlowStartInterval, HalvingInterval, MaxBlockSubsidy, and FoundersFraction are instantiated in § 5.3 ‘Constants’ on p. 50.
SlowStartShift ◦ N := SlowStartInterval
2
SlowStartRate ◦ N := MaxBlockSubsidy
SlowStartInterval
(                                                                                                                           )
height − SlowStartShift
Halving(height) := floor
HalvingInterval

                                                                                                                           SlowStartRate · height,                               if height < SlowStartInterval
                                                                                                                                                                                 2
BlockSubsidy(height) :=                                                                                                     SlowStartRate · (height + 1),  if SlowStartInterval   ≤ height < SlowStartInterval
                                                                                                                                                                                 2
(                                                                                                                           )
                                                                                                                           MaxBlockSubsidy
floor                                                                                                                       ,                                                     otherwise
                                                                                                                            2Halving(height)
{
                                                                                                                                                                                  BlockSubsidy(height) · FoundersFraction,  if height < SlowStartShift + HalvingInterval
FoundersReward(height) :=
0,                                                                                                                                                                                otherwise
MinerSubsidy(height) := BlockSubsidy(height) − FoundersReward(height).
7.8                                                                                                                         Payment of Founders’ Reward
The Founders’ Reward is paid by a transparent output in the coinbase transaction, to one of NumFounderAddresses
transparent addresses, depending on the block height .
For the production network, FounderAddressList1..NumFounderAddresses is:
[ “t3Vz22vK5z2LcKEdg16Yv4FFneEL1zg9ojd”, “t3cL9AucCajm3HXDhb5jBnJK2vapVoXsop3”,
“t3fqvkzrrNaMcamkQMwAyHRjfDdM2xQvDTR”, “t3TgZ9ZT2CTSK44AnUPi6qeNaHa2eC7pUyF”,
“t3SpkcPQPfuRYHsP5vz3Pv86PgKo5m9KVmx”, “t3Xt4oQMRPagwbpQqkgAViQgtST4VoSWR6S”,
“t3ayBkZ4w6kKXynwoHZFUSSgXRKtogTXNgb”, “t3adJBQuaa21u7NxbR8YMzp3km3TbSZ4MGB”,
“t3K4aLYagSSBySdrfAGGeUd5H9z5Qvz88t2”, “t3RYnsc5nhEvKiva3ZPhfRSk7eyh1CrA6Rk”,
“t3Ut4KUq2ZSMTPNE67pBU5LqYCi2q36KpXQ”, “t3ZnCNAvgu6CSyHm1vWtrx3aiN98dSAGpnD”,
“t3fB9cB3eSYim64BS9xfwAHQUKLgQQroBDG”, “t3cwZfKNNj2vXMAHBQeewm6pXhKFdhk18kD”,
“t3YcoujXfspWy7rbNUsGKxFEWZqNstGpeG4”, “t3bLvCLigc6rbNrUTS5NwkgyVrZcZumTRa4”,
“t3VvHWa7r3oy67YtU4LZKGCWa2J6eGHvShi”, “t3eF9X6X2dSo7MCvTjfZEzwWrVzquxRLNeY”,
“t3esCNwwmcyc8i9qQfyTbYhTqmYXZ9AwK3X”, “t3M4jN7hYE2e27yLsuQPPjuVek81WV3VbBj”,
“t3gGWxdC67CYNoBbPjNvrrWLAWxPqZLxrVY”, “t3LTWeoxeWPbmdkUD3NWBquk4WkazhFBmvU”,
“t3P5KKX97gXYFSaSjJPiruQEX84yF5z3Tjq”, “t3f3T3nCWsEpzmD35VK62JgQfFig74dV8C9”,
“t3Rqonuzz7afkF7156ZA4vi4iimRSEn41hj”, “t3fJZ5jYsyxDtvNrWBeoMbvJaQCj4JJgbgX”,
“t3Pnbg7XjP7FGPBUuz75H65aczphHgkpoJW”, “t3WeKQDxCijL5X7rwFem1MTL9ZwVJkUFhpF”,
“t3Y9FNi26J7UtAUC4moaETLbMo8KS1Be6ME”, “t3aNRLLsL2y8xcjPheZZwFy3Pcv7CsTwBec”,
“t3gQDEavk5VzAAHK8TrQu2BWDLxEiF1unBm”, “t3Rbykhx1TUFrgXrmBYrAJe2STxRKFL7G9r”,
“t3aaW4aTdP7a8d1VTE1Bod2yhbeggHgMajR”, “t3YEiAa6uEjXwFL2v5ztU1fn3yKgzMQqNyo”,
“t3g1yUUwt2PbmDvMDevTCPWUcbDatL2iQGP”, “t3dPWnep6YqGPuY1CecgbeZrY9iUwH8Yd4z”,
“t3QRZXHDPh2hwU46iQs2776kRuuWfwFp4dV”, “t3enhACRxi1ZD7e8ePomVGKn7wp7N9fFJ3r”,
“t3PkLgT71TnF112nSwBToXsD77yNbx2gJJY”, “t3LQtHUDoe7ZhhvddRv4vnaoNAhCr2f4oFN”,
“t3fNcdBUbycvbCtsD2n9q3LuxG7jVPvFB8L”, “t3dKojUU2EMjs28nHV84TvkVEUDu1M1FaEx”,
“t3aKH6NiWN1ofGd8c19rZiqgYpkJ3n679ME”, “t3MEXDF9Wsi63KwpPuQdD6by32Mw2bNTbEa”,
“t3WDhPfik343yNmPTqtkZAoQZeqA83K7Y3f”, “t3PSn5TbMMAEw7Eu36DYctFezRzpX1hzf3M”,
“t3R3Y5vnBLrEn8L6wFjPjBLnxSUQsKnmFpv”, “t3Pcm737EsVkGTbhsu2NekKtJeG92mvYyoN” ]
89




For the test network, FounderAddressList1..NumFounderAddresses is:
[ “t2UNzUUx8mWBCRYPRezvA363EYXyEpHokyi”, “t2N9PH9Wk9xjqYg9iin1Ua3aekJqfAtE543”,
“t2NGQjYMQhFndDHguvUw4wZdNdsssA6K7x2”, “t2ENg7hHVqqs9JwU5cgjvSbxnT2a9USNfhy”,
“t2BkYdVCHzvTJJUTx4yZB8qeegD8QsPx8bo”, “t2J8q1xH1EuigJ52MfExyyjYtN3VgvshKDf”,
“t2Crq9mydTm37kZokC68HzT6yez3t2FBnFj”, “t2EaMPUiQ1kthqcP5UEkF42CAFKJqXCkXC9”,
“t2F9dtQc63JDDyrhnfpzvVYTJcr57MkqA12”, “t2LPirmnfYSZc481GgZBa6xUGcoovfytBnC”,
“t26xfxoSw2UV9Pe5o3C8V4YybQD4SESfxtp”, “t2D3k4fNdErd66YxtvXEdft9xuLoKD7CcVo”,
“t2DWYBkxKNivdmsMiivNJzutaQGqmoRjRnL”, “t2C3kFF9iQRxfc4B9zgbWo4dQLLqzqjpuGQ”,
“t2MnT5tzu9HSKcppRyUNwoTp8MUueuSGNaB”, “t2AREsWdoW1F8EQYsScsjkgqobmgrkKeUkK”,
“t2Vf4wKcJ3ZFtLj4jezUUKkwYR92BLHn5UT”, “t2K3fdViH6R5tRuXLphKyoYXyZhyWGghDNY”,
“t2VEn3KiKyHSGyzd3nDw6ESWtaCQHwuv9WC”, “t2F8XouqdNMq6zzEvxQXHV1TjwZRHwRg8gC”,
“t2BS7Mrbaef3fA4xrmkvDisFVXVrRBnZ6Qj”, “t2FuSwoLCdBVPwdZuYoHrEzxAb9qy4qjbnL”,
“t2SX3U8NtrT6gz5Db1AtQCSGjrpptr8JC6h”, “t2V51gZNSoJ5kRL74bf9YTtbZuv8Fcqx2FH”,
“t2FyTsLjjdm4jeVwir4xzj7FAkUidbr1b4R”, “t2EYbGLekmpqHyn8UBF6kqpahrYm7D6N1Le”,
“t2NQTrStZHtJECNFT3dUBLYA9AErxPCmkka”, “t2GSWZZJzoesYxfPTWXkFn5UaxjiYxGBU2a”,
“t2RpffkzyLRevGM3w9aWdqMX6bd8uuAK3vn”, “t2JzjoQqnuXtTGSN7k7yk5keURBGvYofh1d”,
“t2AEefc72ieTnsXKmgK2bZNckiwvZe3oPNL”, “t2NNs3ZGZFsNj2wvmVd8BSwSfvETgiLrD8J”,
“t2ECCQPVcxUCSSQopdNquguEPE14HsVfcUn”, “t2JabDUkG8TaqVKYfqDJ3rqkVdHKp6hwXvG”,
“t2FGzW5Zdc8Cy98ZKmRygsVGi6oKcmYir9n”, “t2DUD8a21FtEFn42oVLp5NGbogY13uyjy9t”,
“t2UjVSd3zheHPgAkuX8WQW2CiC9xHQ8EvWp”, “t2TBUAhELyHUn8i6SXYsXz5Lmy7kDzA1uT5”,
“t2Tz3uCyhP6eizUWDc3bGH7XUC9GQsEyQNc”, “t2NysJSZtLwMLWEJ6MH3BsxRh6h27mNcsSy”,
“t2KXJVVyyrjVxxSeazbY9ksGyft4qsXUNm9”, “t2J9YYtH31cveiLZzjaE4AcuwVho6qjTNzp”,
“t2QgvW4sP9zaGpPMH1GRzy7cpydmuRfB4AZ”, “t2NDTJP9MosKpyFPHJmfjc5pGCvAU58XGa4”,
“t29pHDBWq7qN4EjwSEHg8wEqYe9pkmVrtRP”, “t2Ez9KM8VJLuArcxuEkNRAkhNvidKkzXcjJ”,
“t2D5y7J5fpXajLbGrMBQkFg2mFN8fo3n8cX”, “t2UV2wr1PTaUiybpkV3FdSdGxUJeZdZztyt” ]
Note:   For the test network only, the addresses from index 4 onward have been changed from what was imple-
mented at launch. This re  ects an upgrade on the test network, starting from block height 53127. [Zcash-Issue2113]
Each address representation in FounderAddressList denotes a transparent P2SH multisig address.
Let SlowStartShift be de  ned as in the previous section.
De  ne:
(                                                                                                                      )
SlowStartShift + HalvingInterval
FounderAddressChangeInterval := ceiling
NumFounderAddresses
(                                                                                                                      )
height
FounderAddressIndex(height) := 1 + floor
FounderAddressChangeInterval
Let RedeemScriptHash(height) be the standard redeem script hash, as de  ned in [Bitcoin-Multisig], for the P2SH
multisig address with Base58Check representation given by FounderAddressList FounderAddressIndex(height) .
Consensus rule:   A coinbase transaction for block height height ∈ {1 .. SlowStartShift + HalvingInterval − 1} MUST
include at least one output that pays exactly FoundersReward(height) zatoshi with a standard P2SH script of the form
OP_HASH160  RedeemScriptHash(height)  OP_EQUAL as its scriptPubKey.
Notes:
•  No Founders’ Reward is required to be paid for height  ≥ SlowStartShift + HalvingInterval (i.e. after the   rst
halving), or for height = 0 (i.e. the genesis block ).
•  The Founders’ Reward addresses are not treated specially in any other way, and there can be other outputs to
them, in coinbase transactions or otherwise. In particular, it is valid for a coinbase transaction with height ∈
{1 .. SlowStartShift + HalvingInterval − 1} to have other outputs, possibly to the same address, that do not meet
the criterion in the above consensus rule, as long as at least one output meets it.
90




7.9                                                                                                                       Changes to the Script System
The OP_CODESEPARATOR opcode has been disabled. This opcode also no longer affects the calculation of SIGHASH
transaction hashes .
7.10                                                                                                                      Bitcoin Improvement Proposals
In general, Bitcoin Improvement Proposals (BIPs) do not apply to Zcash unless otherwise speci  ed in this section.
All of the BIPs referenced below should be interpreted by replacing “BTC”, or “bitcoin” used as a currency unit, with
“ZEC”; and “satoshi” with “zatoshi”.
The following BIPs apply, otherwise unchanged, to Zcash: [BIP-11], [BIP-14], [BIP-31], [BIP-35], [BIP-37], [BIP-61].
The following BIPs apply starting from the Zcash genesis block , i.e. any activation rules or exceptions for particular
blocks in the Bitcoin block chain are to be ignored: [BIP-16], [BIP-30], [BIP-65], [BIP-66].
[BIP-34] applies to all blocks other than the Zcash genesis block (for which the “height in coinbase” was inadver-
tently omitted).
[BIP-13] applies with the changes to address version bytes described in § 5.6.1 ‘Transparent Addresses’ on p. 73.
[BIP-111] applies from network protocol version 170004 onward; that is:
•  references to protocol version 70002 are to be replaced by 170003;
•  references to protocol version 70011 are to be replaced by 170004;
•  the reference to protocol version 70000 is to be ignored (Zcash nodes have supported Bloom-  ltered con-
nections since launch).
8                                                                                                                         Differences from the Zerocash paper
8.1                                                                                                                       Transaction Structure
Zerocash introduces two new operations, which are described in the paper as new transaction types, in addition
to the original transaction type of the cryptocurrency on which it is based (e.g. Bitcoin).
In Zcash, there is only the original Bitcoin transaction type, which is extended to contain a sequence of zero or
more Zcash-speci  c operations.
This allows for the possibility of chaining transfers of shielded value in a single Zcash transaction, e.g. to spend a
shielded note that has just been created. (In Zcash, we refer to value stored in UTXOs as transparent , and value
stored in JoinSplit transfer output notes as shielded .) This was not possible in the Zerocash design without using
multiple transactions. It also allows transparent and shielded transfers to happen atomically — possibly under the
control of nontrivial script conditions, at some cost in distinguishability.
Computation of SIGHASH transaction hashes , as described in § 4.9 ‘SIGHASH Transaction Hashing’ on p. 35,
was changed to clean up handling of an error case for SIGHASH_SINGLE, to remove the special treatment of
OP_CODESEPARATOR, and to include Zcash-speci  c   elds in the hash [ZIP-76].
8.2                                                                                                                       Memo Fields
Zcash adds a memo  eld sent from the creator of a JoinSplit description to the recipient of each output note . This
feature is described in more detail in § 5.5 ‘Encodings of Note Plaintexts and Memo Fields’ on p. 72.
91




8.3                                                                                                                       Uni  cation of Mints and Pours
In the original Zerocash protocol, there were two kinds of transaction relating to shielded notes :
•  a “Mint” transaction takes value from transparent UTXOs as input and produces a new shielded note as
output.
•  a “Pour” transaction takes up to Nold shielded notes as input, and produces up to Nnew shielded notes and a
transparent UTXO as output.
Only “Pour” transactions included a zk-SNARK proof.
[Pre-Sapling ]  In Zcash, the sequence of operations added to a transaction (see § 8.1 ‘Transaction Structure’ on
p. 91) consists only of JoinSplit transfers . A JoinSplit transfer is a Pour operation generalized to take a transpar-
ent UTXO as input, allowing JoinSplit transfers to subsume the functionality of Mints. An advantage of this is that
a Zcash transaction that takes input from an UTXO can produce up to Nnew output notes , improving the indis-
tinguishability properties of the protocol. A related change conceals the input arity of the JoinSplit transfer : an
unused (zero-value) input is indistinguishable from an input that takes value from a note .
This uni  cation also simpli  es the   x to the Faerie Gold attack described below, since no special case is needed
for Mints.
[Sapling onward]  In Sapling, there are still no “Mint” transactions. Instead of JoinSplit transfers , there are Spend
transfers and Output transfers . These make use of Pedersen value commitments to represent the shielded values
that are transferred. Because these commitments are additively homomorphic, it is possible to check that all Spend
transfers and Output transfers balance; see § 4.12 ‘Balance and Binding Signature (Sapling)’ on p. 37 for detail.
This reduces the granularity of the circuit, allowing a substantial performance improvement (orthogonal to other
Sapling circuit improvements) when the numbers of shielded inputs and outputs are signi  cantly different. This
comes at the cost of revealing the exact number of shielded inputs and outputs, but dummy (zero-valued) outputs
are still possible.
8.4                                                                                                                       Faerie Gold attack and   x
When a shielded note is created in Zerocash, the creator is supposed to choose a new ρ value at random. The nul-
li  er of the note is derived from its spending key (ask ) and ρ. The note commitment is derived from the recipient
address component apk , the value v, and the commitment trapdoor rcm, as well as ρ. However nothing prevents
creating multiple notes with different v and rcm (hence different note commitments ) but the same ρ.
An adversary can use this to mislead a note recipient, by sending two notes both of which are veri  ed as valid by
Receive (as de  ned in [BCGGMTV2014, Figure 2]), but only one of which can be spent.
We call this a “Faerie Gold” attack — referring to various Celtic legends in which faeries pay mortals in what appears
to be gold, but which soon after reveals itself to be leaves, gorse blossoms, gingerbread cakes, or other less valuable
things [LG2004].
This attack does not violate the security de  nitions given in [BCGGMTV2014].  The issue could be framed as a
problem either with the de  nition of Completeness, or the de  nition of Balance:
•  The Completeness property asserts that a validly received note can be spent provided that its nulli  er does
not appear on the ledger.  This does not take into account the possibility that distinct notes , which are
validly received, could have the same nulli  er .  That is, the security de  nition depends on a protocol de-
tail -nulli  ers - that is not part of the intended abstract security property, and that could be implemented
incorrectly.
•  The Balance property only asserts that an adversary cannot obtain more funds than they have minted or
received via payments. It does not prevent an adversary from causing others’ funds to decrease. In a Faerie
Gold attack, an adversary can cause spending of a note to reduce (to zero) the effective value of another note
for which the adversary does not know the spending key , which violates an intuitive conception of global
balance.
92




These problems with the security de  nitions need to be repaired, but doing so is outside the scope of this speci-
cation. Here we only describe how Zcash addresses the immediate attack.
It would be possible to address the attack by requiring that a recipient remember all of the ρ values for all notes they
have ever received, and reject duplicates (as proposed in [GGM2016]). However, this requirement would interfere
with the intended Zcash feature that a holder of a spending key can recover access to (and be sure that they are
able to spend) all of their funds, even if they have forgotten everything but the spending key .
[Sprout ]  Instead, Zcash enforces that an adversary must choose distinct values for each ρ, by making use of the
fact that all of the nulli  ers in JoinSplit descriptions that appear in a valid block chain must be distinct. This is true
regardless of whether the nulli  ers corresponded to real or dummy notes (see § 4.7.1 ‘Dummy Notes (Sprout)’
on p. 33). The nulli  ers are used as input to hSigCRH to derive a public value hSig which uniquely identi  es the
transaction, as described in § 4.3 ‘JoinSplit Descriptions’ on p. 29. (hSig was already used in Zerocash in a way that
requires it to be unique in order to maintain indistinguishability of JoinSplit descriptions ; adding the nulli  ers
to the input of the hash used to calculate it has the effect of making this uniqueness property robust even if the
transaction creator is an adversary.)
[Sprout]  The ρ value for each output note is then derived from a random private seed ϕ and hSig using PRFϕ . The
correct construction of ρ for each output note is enforced by § 4.15.1 ‘Uniqueness of ρiew’ on p. 41 in the JoinSplit
statement .
[Sprout ]  Now even if the creator of a JoinSplit description does not choose ϕ randomly, uniqueness of nulli  ers
and collision resistance of both hSigCRH and PRFρ will ensure that the derived ρ values are unique, at least for any
two JoinSplit descriptions that get into a valid block chain. This is suf  cient to prevent the Faerie Gold attack.
A variation on the attack attempts to cause the nulli  er of a sent note to be repeated, without repeating ρ. How-
ever, since the nulli  er is computed as PRFaf                                                                                (ρ) (or PRFnkSapling (ρ⋆) for Sapling), this is only possible if the adver-
sk
sary   nds a collision across both inputs on PRFnf  (or PRFnfSapling ), which is assumed to be infeasible — see § 4.1.2
‘Pseudo Random Functions’ on p. 18.
[Sprout ]  Crucially, “nulli  er integrity” is enforced whether or not the enforceMerklePathi    ag is set for an input
note (§ 4.15.1 ‘Nullifier integrity’ on p. 41). If this were not the case then an adversary could perform the attack by
creating a zero-valued note with a repeated nulli  er , since the nulli  er would not depend on the value.
[Sprout ]  Nulli  er integrity also prevents a “roadblock attack” in which the adversary sees a victim’s transaction,
and is able to publish another transaction that is mined  rst and blocks the victim’s transaction. This attack would
be possible if the public value(s) used to enforce uniqueness of ρ could be chosen arbitrarily by the transaction
creator: the victim’s transaction, rather than the adversary’s, would be considered to be repeating these values. In
the chosen solution that uses nulli  ers for these public values, they are enforced to be dependent on spending
keys controlled by the original transaction creator (whether or not each input note is a dummy), and so a roadblock
attack cannot be performed by another party who does not know these keys.
[Sapling onward]  In Sapling, uniqueness of ρ is ensured by making it dependent on the position of the note com-
mitment in the Sapling note commitment tree . Speci  cally, ρ = cm + [pos] J , where J is a generator independent
of the generators used in NoteCommitSapling . Therefore, ρ commits uniquely to the note and its position, and this
commitment is collision-resistant by the same argument used to prove collision resistance of Pedersen hashes .
Note that it is possible for two distinct Sapling positioned notes (having different ρ values and nulli  ers , but dif-
ferent note positions ) to have the same note commitment , but this causes no security problem. Roadblock attacks
are not possible because a given note position does not repeat for outputs of different transactions in the same
block chain.
8.5                                                                                                                           Internal hash collision attack and   x
The Zerocash security proof requires that the composition of COMMrcm and COMMs is a computationally binding
commitment to its inputs apk , v, and ρ. However, the instantiation of COMMrcm and COMMs in section 5.1 of the
paper did not meet the de  nition of a binding commitment at a 128-bit security level. Speci  cally, the internal hash
of apk and ρ is truncated to 128 bits (motivated by providing statistical hiding security). This allows an attacker, with
93




a work factor on the order of 264, to  nd distinct pairs (apk , ρ) and (apk′, ρ′ ) with colliding outputs of the truncated
hash, and therefore the same note commitment . This would have allowed such an attacker to break the Balance
property by double-spending notes , potentially creating arbitrary amounts of currency for themself [HW2016].
Zcash uses a simpler construction with a single hash evaluation for the commitment: SHA-256 for Sprout, and
PedersenHash for Sapling.  The motivation for the nested construction in Zerocash was to allow Mint transactions
to be publically veri  ed without requiring a zero-knowledge proof  ([BCGGMTV2014, section 1.3, under step 3]).
Since Zcash combines “Mint” and “Pour” transactions into generalized JoinSplit transfers (for Sprout), or Spend
transfers and Output transfers (for Sapling), and each transfer always uses a zero-knowledge proof , Zcash does
not require the nesting. A side bene  t is that this reduces the cost of computing the note commitments : for Sprout
it reduces the number of SHA256Compress evaluations needed to compute each note commitment from three to
two, saving a total of four SHA256Compress evaluations in the JoinSplit statement .
[Sprout]  Note:  Sprout note commitments are not statistically hiding, so for Sprout notes, Zcash does not support
the “everlasting anonymity” property described in [BCGGMTV2014, section 8.1], even when used as described in
that section. While it is possible to de  ne a statistically hiding, computationally binding commitment scheme for
this use at a 128-bit security level, the overhead of doing so within the JoinSplit statement was not considered to
justify the bene  ts.
[Sapling onward]  In Sapling, Pedersen commitments are used instead of SHA256Compress. These commitments
are statistically hiding, and so “everlasting anonymity” is supported for Sapling notes under the same conditions
as in Zerocash (by the protocol, not necessarily by zcashd ). Note that diversi  ed payment addresses can be linked
if the discrete logarithm problem on the Jubjub curve can be broken.
8.6                                                                                                                          Changes to PRF inputs and truncation
The format of inputs to the PRFs instantiated in § 5.4.2 ‘Pseudo Random Functions’ on p. 57 has changed relative
to Zerocash. There is also a requirement for another PRF, PRFρ, which must be domain-separated from the others.
In the Zerocash protocol, ρild is truncated from 256 to 254 bits in the input to PRFsn (which corresponds to PRFnf
in Zcash). Also, hSig is truncated from 256 to 253 bits in the input to PRFpk . These truncations are not taken into
account in the security proofs.
Both truncations affect the validity of the proof sketch for Lemma D.2 in the proof of Ledger Indistinguishability
in [BCGGMTV2014, Appendix D].
In more detail:
•  In the argument relating H and 2, it is stated that in 2, “for each i ∈ {1, 2}, sni  := PRFan                           (ρ) for a random
sk
(and not previously used) ρ”. It is also argued that “the calls to PRFan                                                     are each by de  nition unique”. The latter
sk
assertion depends on the fact that ρ is “not previously used”. However, the argument is incorrect because the
truncated input to PRFan                                                                                                     , i.e. [ρ]254, may repeat even if ρ does not.
sk
•  In the same argument, it is stated that “with overwhelming probability, hSig is unique”. In fact what is required
to be unique is the truncated input to PRFpk , i.e. [hSig ]253  = [CRH(pksig )]253. In practice this value will be unique
under a plausible assumption on CRH provided that pksig is chosen randomly, but no formal argument for
this is presented.
Note that ρ is truncated in the input to PRFsn but not in the input to COMMrcm, which further complicates the
analysis.
As further evidence that it is essential for the proofs to explicitly take any such truncations into account, consider
a slightly modi  ed protocol in which ρ is truncated in the input to COMMrcm but not in the input to PRFsn. In that
case, it would be possible to violate balance by creating two notes for which ρ differs only in the truncated bits.
These notes would have the same note commitment but different nulli  ers , so it would be possible to spend the
same value twice.
94




[Sprout ]  For resistance to Faerie Gold attacks as described in § 8.4 ‘Faerie Gold attack and fix’ on p. 92, Zcash
depends on collision resistance of hSigCRH and PRFρ  (instantiated using BLAKE2b-256 and SHA256Compress re-
spectively). Collision resistance of a truncated hash does not follow from collision resistance of the original hash,
even if the truncation is only by one bit. This motivated avoiding truncation along any path from the inputs to the
computation of hSig to the uses of ρ.
[Sprout]  Since the PRFs are instantiated using SHA256Compress which has an input block size of 512 bits (of which
256 bits are used for the PRF input and 4 bits are used for domain separation), it was necessary to reduce the size of
the PRF key to 252 bits. The key is set to ask in the case of PRFaddr , PRFnf , and PRFpk , and to ϕ (which does not exist
in Zerocash) for PRFρ, and so those values have been reduced to 252 bits. This is preferable to requiring reasoning
about truncation, and 252 bits is quite suf  cient for security of these cryptovalues.
Sapling uses Pedersen hashes and BLAKE2s where Sprout used SHA256Compress. Pedersen hashes can be ef  -
ciently instantiated for arbitrary input lengths. BLAKE2s has an input block size of 512 bits, and uses a  nalization
ag rather than padding of the last input block; it also supports domain separation via a personalization param-
eter distinct from the input. Therefore, there is no need for truncation in the inputs to any of these hashes. Note
however that the output of CRHivk is truncated, requiring a security assumption on BLAKE2s truncated to 251 bits
(see § 5.4.1.5 ‘CRHivk Hash Function’ on p. 53).
8.7                                                                                                                          In-band secret distribution
Zerocash speci  ed ECIES (referencing Certicom’s SEC 1 standard) as the encryption scheme used for the in-band
secret distribution. This has been changed to a key agreement scheme based on Curve25519 (for Sprout) or Jubjub
(for Sapling) and the authenticated encryption algorithm AEAD_CHACHA20_POLY1305. This scheme is still loosely
based on ECIES, and on the crypto_box_seal scheme de  ned in libsodium [libsodium-Seal].
The motivations for this change were as follows:
•                                                                                                                            The Zerocash paper did not specify the curve to be used. We believe that Curve25519 has signi  cant side-
channel resistance, performance, implementation complexity, and robustness advantages over most other
available curve choices, as explained in [Bernstein2006].  For Sapling, the Jubjub curve was designed ac-
cording to a similar design process following the “Safe curves” criteria [BL-SafeCurves] [Hopwood2018]. This
retains Curve25519’s advantages while keeping shielded payment address sizes short, because the same pub-
lic key material supports both encryption and spend authentication.
•                                                                                                                            ECIES permits many options, which were not speci  ed.  There are at least -counting conservatively- 576
possible combinations of options and algorithms over the four standards (ANSI X9.63, IEEE Std 1363a-2004,
ISO/IEC 18033-2, and SEC 1) that de  ne ECIES variants [MAEÁ2010].
•                                                                                                                            Although the Zerocash paper states that ECIES satis  es key privacy (as de  ned in [BBDP2001]), it is not clear
that this holds for all curve parameters and key distributions. For example, if a group of non-prime order is
used, the distribution of ciphertexts could be distinguishable depending on the order of the points repre-
senting the ephemeral and recipient public keys. Public key validity is also a concern. Curve25519 (and Jubjub)
key agreement is de  ned in a way that avoids these concerns due to the curve structure and the “clamping”
of private keys (or explicit cofactor multiplication and point validation for Sapling).
•                                                                                                                            Unlike the DHAES/DHIES proposal on which it is based [ABR1999], ECIES does not require a representation
of the sender’s ephemeral public key to be included in the input to the KDF, which may impair the secu-
rity properties of the scheme.  (The Std 1363a-2004 version of ECIES [IEEE2004] has a “DHAES mode” that
allows this, but the representation of the key input is underspeci  ed, leading to incompatible implementa-
tions.) The scheme we use for Sprout has both the ephemeral and recipient public key encodings -which
are unambiguous for Curve25519- and also hSig  and a nonce as described below, as input to the KDF. For
Sapling, it is only possible to include the ephemeral public key encoding, but this is suf  cient to retain the
original security properties of DHAES. Note that being able to break the Elliptic Curve Dif  e-Hellman Prob-
lem on Curve25519 or Jubjub (without breaking AEAD_CHACHA20_POLY1305 as an authenticated encryption
scheme or BLAKE2b-256 as a KDF) would not help to decrypt the transmitted notes ciphertext unless pkenc
is known or guessed.
95




•                                                                                                                             [Sprout ] The KDF also takes a public seed hSig as input. This can be modeled as using a different “random-
ness extractor” for each JoinSplit transfer , which limits degradation of security with the number of JoinSplit
transfers .  This facilitates security analysis as explained in [DGKM2011] — see section 7 of that paper for a
security proof that can be applied to this construction under the assumption that single-block BLAKE2b-256
is a “weak PRF”. Note that hSig is authenticated, by the zk-SNARK proof , as having been chosen with knowl-
edge of aold
sk,1..Nold , so an adversary cannot modify it in a ciphertext from someone else’s transaction for use
in a chosen-ciphertext attack without detection. (In Sapling, there is no equivalent to hSig , but the binding
signature and spend authorization signatures prevent such modi  cations.)
•                                                                                                                             [Sprout ] The scheme used by Sprout includes an optimization that reuses the same ephemeral key (with
different nonces) for the two ciphertexts encrypted in each JoinSplit description.
The security proofs of [ABR1999] can be adapted straightforwardly to the resulting scheme. Although DHAES as
de  ned in that paper does not pass the recipient public key or a public seed to the hash function H , this does not
impair the proof because we can consider H to be the specialization of our KDF to a given recipient key and seed.
(Passing the recipient public key to the KDF could in principle compromise key privacy , but not con  dentiality of
encryption.) [Sprout] It is necessary to adapt the “HDH independence” assumptions and the proof slightly to take
into account that the ephemeral key is reused for two encryptions.
Note that the 256-bit key for AEAD_CHACHA20_POLY1305 maintains a high concrete security level even under
attacks using parallel hardware [Bernstein2005] in the multi-user setting [Zaverucha2012]. This is especially nec-
essary because the privacy of Zcash transactions may need to be maintained far into the future, and upgrading
the encryption algorithm would not prevent a future adversary from attempting to decrypt ciphertexts encrypted
before the upgrade. Other cryptovalues that could be attacked to break the privacy of transactions are also suf  -
ciently long to resist parallel brute force in the multi-user setting: for Sprout, ask is 252 bits, and skenc is no shorter
than ask .
8.8                                                                                                                           Omission in Zerocash security proof
The abstract Zerocash protocol requires PRFaddr only to be a PRF; it is not speci  ed to be collision-resistant . This
reveals a  aw in the proof of the Balance property.
Suppose that an adversary  nds a collision on PRFaddr such that ask and ask are distinct spending keys for the same
apk . Because the note commitment is to apk , but the nulli  er is computed from ask (and ρ), the adversary is able to
double-spend the note, once with each ask . This is not detected because each spend reveals a different nulli  er .
The JoinSplit statements are still valid because they can only check that the ask in the witness is some preimage of
the apk used in the note commitment .
The error is in the proof of Balance in [BCGGMTV2014, Appendix D.3]. For the “A violates Condition I” case, the
proof says:
“(i)  If cm1ld                                                                                                                = cm2ld, then the fact that sn1ld  , sn2ld implies that the witness a contains two distinct openings of
                                                                                                                              k,2, ρ2ld )). This violates the
binding property of the commitment scheme COMM."
                                                                                                                              k,i; they contain apkd,i. (In Sprout cmild opens directly to (apkd,i, vild, ρild ), and
in Zerocash it opens to (vild, COMMs (apkd                                                                                    ,i, ρild ).)
A similar error occurs in the argument for the “A violates Condition II” case.
The   aw is not exploitable for the actual instantiations of PRFaddr in Zerocash and Sprout, which are collision-
resistant assuming that SHA256Compress is.
The proof can be straightforwardly repaired. The intuition is that we can rely on collision resistance of PRFaddr
k,2, together with constraint 1(b) of the JoinSplit
statement (see § 4.15.1 ‘Spend authority’ on p. 41), implies distinctness of apkd                                             ,1 and apkd,2, therefore distinct openings
of the note commitment when Condition I or II is violated.
96




8.9                                                                                                                      Miscellaneous
•  The paper de  nes a note as ((apk , pkenc ), v, ρ, rcm, s, cm), whereas this speci  cation de  nes a Sprout note as
(apk , v, ρ, rcm). The instantiation of COMMs in section 5.1 of the paper did not actually use s, and neither does
the new instantiation of NoteCommitSprout in Sprout. pkenc is also not needed as part of a note : it is not an input
to NoteCommitSprout nor is it constrained by the Zerocash POUR statement or the Zcash JoinSplit statement .
cm can be computed from the other   elds. (The de  nition of notes for Sapling is different again.)
•  The length of proof encodings given in the paper is 288 bytes. [Sprout] This differs from the 296 bytes spec-
i  ed in § 5.4.9.1 ‘BCTV14’ on p. 70, because both the x-coordinate and compressed y-coordinate of each
point need to be represented. Although it is possible to encode a proof in 288 bytes by making use of the fact
that elements of Fq can be represented in 254 bits, we prefer to use the standard formats for points de  ned
in [IEEE2004]. The fork of libsnark used by Zcash uses this standard encoding rather than the less ef  cient
(uncompressed) one used by upstream libsnark . In Sapling, a customized encoding is used for BLS12-381
points in Groth16 proofs to minimize length.
•  The range of monetary values differs.  In Zcash this range is {0 .. MAX_MONEY}, while in Zerocash it is
{0 .. 2ℓvalue −1}. (The JoinSplit statement still only directly enforces that the sum of amounts in a given Join-
Split transfer is in the latter range; this enforcement is technically redundant given that the Balance property
holds.)
9                                                                                                                        Acknowledgements
The inventors of Zerocash are Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers,
Eran Tromer, and Madars Virza. The designers of the Zcash protocol are the Zerocash inventors and also Daira
Hopwood, Sean Bowe, Jack Grigg, Simon Liu, Taylor Hornby, Nathan Wilcox, Zooko Wilcox, Jay Graber, Ariel Gabi-
zon, and George Tankersley. The Equihash proof-of-work algorithm was designed by Alex Biryukov and Dmitry
Khovratovich.
The authors would like to thank everyone with whom they have discussed the Zerocash and Zcash protocol de-
signs; in addition to the preceding, this includes Mike Perry, isis agora lovecruft, Leif Ryge, Andrew Miller, Saman-
tha Hulsey, jl777, Ben Blaxill, Alex Balducci, Jake Tarren, Solar Designer, Ling Ren, Alison Stevenson, John Tromp,
Paige Peterson, Maureen Walsh, Jack Gavigan, Filippo Valsorda, Zaki Manian, Tracy Hu, Brian Warner, Mary Maller,
Michael Dixon, Andrew Poelstra, Eirik Ogilvie-Wigley, Benjamin Winston, and no doubt others. We would also
like to thank the designers and developers of Bitcoin.
Zcash has bene  ted from security audits performed by NCC Group, Coinspect, Least Authority, Mary Maller,
Kudelski Security, and QED-it.
The Faerie Gold attack was found by Zooko Wilcox; subsequent analysis of variations on the attack was performed
by Daira Hopwood and Sean Bowe. The internal hash collision attack was found by Taylor Hornby. The error in the
Zerocash proof of Balance relating to collision resistance of PRFaddr was found by Daira Hopwood. The errors in
the proof of Ledger Indistinguishability mentioned in § 8.6 ‘Changes to PRF inputs and truncation’ on p. 94 were
also found by Daira Hopwood.
The 2015 Soundness vulnerability in BCTV14 [Parno2015] was found by Bryan Parno.  An additional condition
needed to resist this attack was documented by Ariel Gabizon [Gabizon2019, section 3]. The 2019 Soundness vul-
nerability in BCTV14 [Gabizon2019] was found by Ariel Gabizon.
The design of Sapling is primarily due to Matthew Green, Ian Miers, Daira Hopwood, Sean Bowe, and Jack Grigg. A
potential attack linking diversi  ed payment addresses , avoided in the adopted design, was found by Brian Warner.
Numerous people have contributed to the science of zero-knowledge proving systems, but we would particularly
like to acknowledge the work of Sha  Goldwasser, Silvio Micali, Oded Goldreich, Charles Rackoff, Rosario Gennaro,
Bryan Parno, Jon Howell, Craig Gentry, Mariana Raykova, Jens Groth, Rafail Ostrovsky, and Amit Sahai.
Many of the ideas used in Zcash —including the use of zero-knowledge proofs to resolve the tension between
privacy and auditability, Merkle trees over note commitments (using Pedersen hashes as in Sapling), and the use of
97




“serial numbers” or nulli  ers to detect or prevent double-spends— were  rst applied to privacy-preserving digital
currencies by Tomas Sander and Amnon Ta-Shma.  To a large extent Zcash is a re  nement of their “Auditable,
Anonymous Electronic Cash” proposal in [ST1999].
Finally, we would like to thank the Internet Archive for their scan of Peter Newell’s illustration of the Jubjub bird,
from [Carroll1902].
10                                                                                                                       Change History
2019.0-beta-36                                                                                                           2019-02-09
•  Correct isis agora lovecruft’s name.
2019.0-beta-35                                                                                                           2019-02-08
•  Cite [Gabizon2019] and acknowledge Ariel Gabizon.
•  Correct [SBB2019] to [SWB2019].
•  The [Gabizon2019] vulnerability affected Soundness of BCTV14 as well as Knowledge Soundness.
•  Clarify the history of the [Parno2015] vulnerability and acknowledge Bryan Parno.
•  Specify the dif  culty adjustment change that occurred on the test network at block height 299188.
•  Add Eirik Ogilvie-Wigley and Benjamin Winston to acknowledgements.
•  Rename zk-SNARK Parameters sections to be named according to the proving system (BCTV14 or Groth16),
not the shielded protocol construction (Sprout or Sapling).
•  In § 6 ‘Network Upgrades’ on p. 78, say when Sapling activated.
2019.0-beta-34                                                                                                           2019-02-05
•  Disclose a security vulnerability in BCTV14 that affected Sprout before activation of the Sapling network
upgrade (see § 5.4.9.1 ‘BCTV14’ on p. 70).
•  Rename PHGR13 to BCTV2014.
•  Rename reference [BCTV2015] to [BCTV2014a], and [BCTV2014] to [BCTV2014b].
2018.0-beta-33                                                                                                           2018-11-14
•  No changes to Sprout.
•  Complete §A.4 ‘The Sapling Spend circuit’ on p. 138.
•  Add §A.5 ‘The Sapling Output circuit’ on p. 140.
•  Change the description of window lookup in §A.3.3.7 ‘Fixed-base affine-Edwards scalar multiplication’ on
p. 130 to match sapling-crypto.
•  Describe 2-bit window lookup with conditional negation in §A.3.3.9 ‘Pedersen hash’ on p. 131.
•  Fix or complete various calculations of constraint costs.
•  Adjust the notation used for scalar multiplication in Appendix A to allow bit sequences as scalars.
98




2018.0-beta-32                                                                                                        2018-10-24
•  No changes to Sprout.
•  Correct the input to H⊛ used to derive the nonce r in RedDSA.Sign, from T || M to T || vk || M . This matches
the sapling-crypto implementation; the speci  cation of this input was unintentionally changed in version
2018.0-beta-20.
•  Clarify the description of the Merkle path check in §A.3.4 ‘Merkle path check’ on p. 134.
2018.0-beta-31                                                                                                        2018-09-30
•  No changes to Sprout.
•  Correct some uses of rJ that should have been rS or q.
•  Correct uses of LEOS2IPℓ in RedDSA.Verify and RedDSA.BatchVerify to ensure that ℓ is a multiple of 8 as re-
quired.
•  Minor changes to avoid clashing notation for Edwards curves EEdwards(a,d) , Montgomery curves EMont(A,B) ,
and extractors EA.
•  Correct a use of J that should have been M in the proof of Theorem A.3.4 on p. 128, and make a minor tweak
to the theorem statement (k2  ,  ±k1  instead of k1  ,  ±k2) to make the contradiction derived by the proof
clearer.
•  Clarify notation in the proof of Theorem A.3.3 on p. 127.
•  Address some of the   ndings of the QED-it report:
-  Improved cross-referencing in § 5.4.1.7 ‘Pedersen Hash Function’ on p. 54.
-  Clarify the notes concerning domain separation of pre  xes in § 5.4.1.3 ‘MerkleCRHSapling Hash Function’
on p. 52 and § 5.4.7.2 ‘Windowed Pedersen commitments’ on p. 64.
-  Correct the statement and proof of Theorem A.3.2 on p. 127.
•  Add the QED-it report to the acknowledgements.
2018.0-beta-30                                                                                                        2018-09-02
•  No changes to Sprout.
•  Give an informal security argument for Unlinkability of diversi  ed payment addresses based on reduction
to key privacy of ElGamal encryption, for which a security proof is given in [BBDP2001]. (This argument has
gaps which will be addressed in a future version.)
•  Add a reference to [BGM2018] for the Sapling zk-SNARK parameters.
•  Write §A.4 ‘The Sapling Spend circuit’ on p. 138 (draft).
•  Add a reference to the ristretto_bulletproofs design notes [Dalek-notes] for the synthetic blinding factor tech-
nique.
•  Ensure that the constraint costs in §A.3.3.1 ‘Checking that affine Edwards coordinates are on the curve’ on
p. 126 and §A.3.3.6 ‘Affine-Edwards nonsmall-order check’ on p. 129 accurately re  ect the sapling-crypto
implementation.
•  Minor correction to the non-normative note in §A.3.2.2 ‘Range check’ on p. 124.
•  Clarify the non-normative note in § 4.1.7 ‘Commitment’ on p. 23 about the de  nitions of ValueCommit.Output
and NoteCommitSapling .Output.
•  Clarify that the signer of a spend authorization signature is supposed to choose the spend authorization
randomizer , α, itself. Only step 4 in the procedure in § 4.13 ‘Spend Authorization Signature’ on p. 39 may
securely be delegated.
99




•  Add a non-normative note to § 5.4.6 ‘RedDSA and RedJubjub’ on p. 60 explaining that RedDSA key random-
ization may interact with other uses of additive properties of Schnorr keys.
•  Add dates to Change History entries. (These are the dates of the git tags in local, i.e. UK, time.)
2018.0-beta-29                                                                                                    2018-08-15
•  No changes to Sprout.
•  Finish §A.3.2.2 ‘Range check’ on p. 124.
•  Change §A.3.7 ‘BLAKE2s hashes’ on p. 135 to correct the constraint count and to describe batched equality
checks performed by the sapling-crypto implementation.
2018.0-beta-28                                                                                                    2018-08-14
•  No changes to Sprout.
•  Finish §A.3.7 ‘BLAKE2s hashes’ on p. 135.
•  Minor corrections to §A.3.3.8 ‘Variable-base affine-Edwards scalar multiplication’ on p. 131.
2018.0-beta-27                                                                                                    2018-08-12
•  Notational changes:
-  Use a superscript (r) to mark the subgroup order, instead of a subscript.
-  Use G(r)∗ for the set of rG-order points in G.
-  Mark the subgroup order in pairing groups, e.g. use G1r) instead of G1.
-  Make the bit-representation indicator ⋆ an af  x instead of a superscript.
•  Clarify that when validating a Groth16 proof, it is necessary to perform a subgroup check for πA and πC  as
well as for πB .
•  Correct the description of Groth16 batch veri  cation to explicitly take account of how veri  cation depends
on primary inputs .
•  Add Charles Rackoff, Rafail Ostrovsky, and Amit Sahai to the acknowledgements section for their work on
zero-knowledge proofs .
2018.0-beta-26                                                                                                    2018-08-05
•  No changes to Sprout.
•  Add §B.2 ‘Groth16 batch verification’ on p. 142.
2018.0-beta-25                                                                                                    2018-08-05
•  No changes to Sprout.
•  Add the hashes of parameter   les for Sapling.
•  Add cross references for parameters and functions used in RedDSA batch veri  cation.
•  Makefile changes: name the PDF   le for the Sprout version of the speci  cation as sprout.pdf, and make
protocol.pdf link to the Sapling version.
100




2018.0-beta-24                                                                                                     2018-07-31
•  No changes to Sprout.
•  Add a missing consensus rule for version 4 transactions : if there are no Sapling spends or outputs, then
valueBalance MUST be 0.
2018.0-beta-23                                                                                                     2018-07-27
•  No changes to Sprout.
•  Update RedDSA veri  cation to use cofactor multiplication. This is necessary in order for the output of batch
veri  cation to match that of unbatched veri  cation in all cases.
•  Add §B.1 ‘RedDSA batch verification’ on p. 141.
2018.0-beta-22                                                                                                     2018-07-18
•  No changes to Sprout.
•  Update § 6 ‘Network Upgrades’ on p. 78 to take account that Overwinter has activated.
•  The recommendation for transactions without JoinSplit descriptions to be version 1 applies only before
Overwinter, not before Sapling.
•  Complete the proof of Theorem A.3.5 on p. 132.
•  Add a note about redundancy in the nonsmall-order checking of rk.
•  Clarify the use of cvnew and cmnew , and the selection of outgoing viewing key , in sending Sapling notes.
•  Delete the description of optimizations for the af  ne-Edwards nonsmall-order check, since the Sapling cir-
cuit does not use them. Also clarify that some other optimizations are not used.
2018.0-beta-21                                                                                                     2018-06-22
•  Remove the consensus rule “If nJoinSplit > 0, the transaction MUST NOT use SIGHASH types other than
SIGHASH_ALL.”, which was never implemented.
•  Add section on signature hashing.
•  Brie  y describe the changes to computation of SIGHASH transaction hashes in Sprout.
•  Clarify that interstitial treestates form a tree for each transaction containing JoinSplit descriptions .
•  Correct the description of P2PKH addresses in § 5.6.1 ‘Transparent Addresses’ on p. 73 — they use a hash of
a compressed, not an uncompressed ECDSA key representation.
•  Clarify the wording of the caveat 3 about the claimed security of shielded transactions .
•  Correct the de  nition of set difference (S \ T ).
•  Add a note concerning malleability of zero-knowledge proofs .
•  Clarify attribution of the Zcash protocol design.
•  Acknowledge Alex Biryukov and Dmitry Khovratovich as the designers of Equihash.
•  Acknowledge Sha   Goldwasser, Silvio Micali, Oded Goldreich, Rosario Gennaro, Bryan Parno, Jon Howell,
Craig Gentry, Mariana Raykova, and Jens Groth for their work on zero-knowledge proving systems.
•  Acknowledge Tomas Sander and Amnon Ta-Shma for [ST1999].
•  Acknowledge Kudelski Security’s audit.
•  Use the more precise subgroup types G(r) and J(r) in preference to G and J where applicable.
101




•                                                                                                                                                                                                                         Change the types of auxiliary inputs to the Spend statement and Output statement , to be more faithful to
                                                                                                              the implementation.
•                                                                                                                                                                                                                         Rename the cm  eld of an Output description to cmu, re  ecting the fact that it is a Jubjub curve u-coordinate.
•                                                                                                                                                                                                                         Add explicit consensus rules that the anchor  eld of a Spend description and the cmu  eld of an Output
                                                                                                              description must be canonical encodings.
•                                                                                                             Enforce that esk in outCiphertext is a canonical encoding.
•                                                                                                                                                                                                                         Add consensus rules that cv in a Spend description, and cv and epk in an Output description, are not of small
                                                                                                              order. Exclude 0 from the range of esk when encrypting Sapling notes.
•                                                                                                             Add a consensus rule that valueBalance is in the range {−MAX_MONEY .. MAX_MONEY}.
•                                                                                                             Enforce stronger constraints on the types of key components pkd, ak, and nk.
•                                                                                                                                                                                                                         Correct the conformance rule for fOverwintered (it must not be set before Overwinter has activated, not
                                                                                                              before Sapling has activated).
•                                                                                                                                                                                                                         Correct the argument that v∗ is in range in § 4.12 ‘Balance and Binding Signature (Sapling)’ on p. 37.
•                                                                                                                                                                                                                         Correct an error in the algorithm for RedDSA.Verify: the public key vk is given directly to this algorithm and
                                                                                                              should not be computed from the unknown private key sk.
•                                                                                                                                                                                                                         Correct or improve the types of GroupHashJ(r)∗ , FindGroupHashJ(r)∗ , ExtractJ(r) , PRFexpand, PRFock , and CRHivk .
•                                                                                                             Instantiate PRFock using BLAKE2b-256.
•                                                                                                                                                                                                                         Change the syntax of a commitment scheme to add COMM.GenTrapdoor. This is necessary because the in-
                                                                                                                                                                                                                          tended distribution of commitment trapdoors may not be uniform on all values that are acceptable trapdoor
inputs.
•                                                                                                             Add notes on the purpose of outgoing viewing keys .
•                                                                                                             Correct the encoding of a full viewing key (ovk was missing).
•                                                                                                             Ensure that Sprout functions and values are given Sprout-speci  c types where appropriate.
•                                                                                                             Improve cross-referencing.
•                                                                                                             Clarify the use of BCTV14 vs Groth16 proofs in JoinSplit statements .
•                                                                                                             Clarify that the                                                                                            √a notation refers to the positive square root.  (This matters for the conversion in §A.3.3.3
                                                                                                              ‘Edwards ↔ Montgomery conversion’ on p. 127.)
•                                                                                                             Model the group hash as a random oracle. This appears to be unavoidable in order to allow proving unlink-
ability of DiversifyHash. Explain how this relates to the Discrete Logarithm Independence assumption used
previously, and justify this modelling by showing that it follows from treating BLAKE2s-256 as a random or-
acle in the instantiation of GroupHashJ(r)∗ .
•                                                                                                             Rename CRS (Common Random String) to URS (Uniform Random String ), to match the terminology adopted
at the   rst zkproof workshop held in Boston, Massachusetts on May 10-11, 2018.
•                                                                                                                                                                                                                         Generalize PRFexpand to accept an arbitrary-length input. (This speci  cation does not use that generalization,
but [ZIP-32] does.)
•                                                                                                                                                                                                                         Change the notation for a multiplication constraint in Appendix A ‘Circuit Design’ on p. 121 to avoid potential
confusion with cartesian product.
• Clarify the wording of the abstract.
•                                                                                                             Correct statements about which algorithms are instantiated by BLAKE2s and BLAKE2b.
•                                                                                                             Add a note explaining which conformance requirements of [BIP-173] (de  ning Bech32) apply.
•                                                                                                                                                                                                                         Add the Jubjub bird image to the title page. This image has been edited from a scan of Peter Newell’s original
                                                                                                                                                                                                                          illustration (as it appeared in [Carroll1902]) to remove the background and Bandersnatch, and to restore the
bird’s clipped right wing.
102




•  Change the light yellow background to white (indicating that this Overwinter and Sapling speci  cation is no
longer a draft).
2018.0-beta-20                                                                                                                                                          2018-05-22
•                                                                                                                                                                       Add Michael Dixon and Andrew Poelstra to acknowledgements.
•                                                                                                                   Minor improvements to cross-references.
•                                                                                                                                                                                                                                                              Correct the order of arguments to RedDSA.RandomizePrivate and RedDSA.RandomizePublic.
•                                                                                                                                                                                                                                                              Correct a reference to RedDSA.RandomizePrivate that was intended to be RedDSA.RandomizePublic.
•                                                                                                                                                                                                                                                              Fix the description of the balancing value in § 4.12 ‘Balance and Binding Signature (Sapling)’ on p. 37.
•                                                                                                                                                                       Correct a type error in § 5.4.8.5 ‘Group Hash into Jubjub’ on p. 70.
•                                                                                                                                                                       Correct a type error in RedDSA.Sign in § 5.4.6 ‘RedDSA and RedJubjub’ on p. 60.
•                                                                                                                                                                       Ensure G is de  ned in § 5.4.6.1 ‘Spend Authorization Signature’ on p. 63.
•                                                                                                                                                                                                                                                              Make the public key pre  x part of the input to the hash function in RedDSA, not part of the message.
•                                                                                                                                                                       Correct the statement about FindGroupHashJ(r)∗  never returning ⊥.
•                                                                                                                                                                       Correct an error in the computation of generators for Pedersen hashes .
•                                                                                                                                                                                                                                                              Change the order in which NoteCommitSapling commits to its inputs, to match the sapling-crypto implemen-
tation.
•                                                                                                                                                                       Fail Sapling key generation if ivk = 0. (This has negligible probability.)
•                                                                                                                                                                                                                                                              Change the notation H⋆ to H⊛ in § 5.4.6 ‘RedDSA and RedJubjub’ on p. 60, to avoid confusion with the ⋆ con-
                                                                                                                    vention for representations of group elements.
•                                                                                                                                                                       cmu encodes only the u-coordinate of the note commitment , not the full curve point.
•                                                                                                                                                                                                                                                              rk is checked to be not of small order outside the Spend statement , not in the Spend statement .
•                                                                                                                   Change terminology describing constraint systems.
2018.0-beta-19                                                                                                      2018-04-23
•  No changes to Sprout.
•  Minor clari  cations.
2018.0-beta-18                                                                                                      2018-04-23
•  No changes to Sprout.
•  Clarify the security argument for balance in Sapling.
•  Correct a subtle problem with the type of the value input to ValueCommit: although it is only directly used to
com{mit to values}in {0 .. 2ℓvalue −1}, the security argument depends on a sum of commitments being binding
on                                                                                                                  −rJ 21 .. rJ 21
•  Fix the loss of tightness in the use of PRFnfSapling by specifying the keyspace more precisely.
•  Correct type ambiguities for ρ.
•  Specify the representation of i in group G2 of BLS12-381.
103




2018.0-beta-17                                                                     2018-04-21
•  No changes to Sprout.
                                                                                   •  Correct an error in the de  nition of DefaultDiversifier.
2018.0-beta-16                                                                     2018-04-21
•                                                                                  Explicitly note that outputs from coinbase transactions include Founders’ Reward outputs.
•                                                                                  The point represented by R in an Ed25519 signature is checked to not be of small order; this is not the same
                                                                                   as checking that it is of prime order ℓ.
•                                                                                  Specify support for [BIP-111] (the NODE_BLOOM service bit) in network protocol version 170004.
•                                                                                  Give references [Vercauter2009] and [AKLGL2010] for the optimal ate pairing.
•                                                                                  Give references for BLS [BLS2002] and BN [BN2005] curves.
•                                                                                  De  ne KASprout.DerivePublic for Curve25519.
•                                                                                  Caveat the claim about note traceability set in § 1.2 ‘High-level Overview’ on p. 7 and link to [Peterson2017]
and [Quesnelle2017].
•                                                                                  Do not require a generator as part of the speci  cation of a represented group; instead, de  ne it in the rep-
                                                                                   resented pairing or scheme using the group.
•                                                                                  Refactor the abstract de  nition of a signature scheme to allow derivation of verifying keys independent of
key pair generation.
•                                                                                  Correct the explanation in § 1.2 ‘High-level Overview’ on p. 7 to apply to Sapling.
•                                                                                  Add the de  nition of a private key to public key homomorphism for signature schemes .
•                                                                                  Remove the output index as an input to KDFSapling .
•                                                                                  Allow dummy Sapling input notes .
•                                                                                  Specify RedDSA and RedJubjub.
•                                                                                  Specify binding signatures and spend authorization signatures .
•                                                                                  Specify the randomness beacon.
•                                                                                  Add output ciphertexts and ock.
•                                                                                  De  ne DefaultDiversifier.
•                                                                                  Change the Spend circuit and Output circuit speci  cations to remove unintended differences from sapling-
crypto.
•                                                                                  Use hJ to refer to the Jubjub curve cofactor, rather than 8.
•                                                                                  Correct an error in the y-coordinate formula for addition in §A.3.3.4 ‘Affine-Montgomery arithmetic’ on
                                                                                   p. 128 (the constraints were correct).
•                                                                                  Add acknowledgements for Brian Warner, Mary Maller, and the Least Authority audit.
•                                                                                  Makefile improvements.
2018.0-beta-15                                                                     2018-03-19
•  Clarify the bit ordering of SHA-256.
•  Drop _t from the names of representation types.
•  Remove functions from the Sprout speci  cation that it does not use.
•  Updates to transaction format and consensus rules for Overwinter and Sapling.
104




•  Add speci  cation of the Output statement .
•  Change MerkleDepthSapling from 29 to 32.
•  Updates to Sapling construction, changing how the nulli  er is computed and separating it from the ran-
domized spend verifying key (rk).
•  Clarify conversions between bit and byte sequences for sk, reprJ (ak), and reprJ (nk).
•  Change the Makefile to avoid multiple reloads in PDF readers while rebuilding the PDF.
•  Spacing and pagination improvements.
2018.0-beta-14                                                                                                2018-03-11
•  Only cosmetic changes to Sprout.
•  Simplify FindGroupHashJ(r)∗  to use a single-byte index.
•  Changes to diversi  cation for Pedersen hashes and Pedersen commitments .
•  Improve security de  nitions for signatures.
2018.0-beta-13                                                                                                2018-03-11
•  Only cosmetic changes to Sprout.
•  Change how (ask, nsk) are derived from the spending key sk to ensure they are on the full range of FrJ .
•  Change PRFnr to produce output computationally indistinguishable from uniform on Fr
J
•  Change UncommittedSapling to be a u-coordinate for which there is no point on the curve.
•  Appendix A updates:
-  categorize components into larger sections
-   ll in the [de]compression and validation algorithm
-  more precisely state the assumptions for inputs and outputs
-  delete not-all-one component which is no longer needed
-  factor out xor into its own component
-  specify [un]packing more precisely; separate it from boolean constraints
-  optimize checking for non-small order
-  notation in variable-base multiplication algorithm.
2018.0-beta-12                                                                                                2018-03-06
•  No changes to Sprout.
•  Add references to Overwinter ZIPs and update the section on Overwinter/Sapling transitions.
•  Add a section on re-randomizable signatures.
•  Add de  nition of PRFnr .
•  Work-in-progress on Sapling statements .
•  Rename “raw ” to “homomorphic ” Pedersen commitments .
•  Add packing modulo the   eld size and range checks to Appendix A.
•  Update the algorithm for variable-base scalar multiplication to what is implemented by sapling-crypto.
105




2018.0-beta-11                                                                                                      2018-02-26
•  No changes to Sprout.
•  Add sections on Spend descriptions and Output descriptions .
•  Swap order of cv and rt in a Spend description for consistency.
•  Fix off-by-one error in the range of ivk.
2018.0-beta-10                                                                                                      2018-02-26
•  Split the descriptions of SHA-256 and SHA256Compress, and of BLAKE2, into their own sections.  Specify
SHA256Compress more precisely.
•  Add Tracy Hu to acknowledgements (for the idea of explicitly encoding the root of the Sapling note com-
mitment tree in block headers ).
•  Move bit/byte/integer conversion primitives into § 5.2 ‘Integers, Bit Sequences, and Endianness’ on p. 49.
•  Refer to Overwinter and Sapling just as “upgrades” in the abstract, not as the next “minor version” and “major
version”.
•  PRFnr must be collision-resistant .
•  Correct an error in the Pedersen hash speci  cation.
•  Use a named variable, c, for chunks per segment in the Pedersen hash speci  cation, and change its value
from 61 to 63. Add a proof justifying this value of c.
•  Specify Pedersen commitments .
•  Notation changes.
•  Generalize the distinct-x criterion (Theorem A.3.4 on p. 128) to allow negative indices.
2018.0-beta-9                                                                                                       2018-02-10
•  Specify the coinbase maturity rule, and the rule that coinbase transactions cannot contain JoinSplit descrip-
tions , Spend descriptions , or Output descriptions .
•  Delay lifting the 100000-byte transaction size limit from Overwinter to Sapling.
•  Improve presentation of the proof of injectivity for ExtractJ(r) .
•  Specify GroupHashJ(r)∗ .
•  Specify Pedersen hashes .
2018.0-beta-8                                                                                                       2018-02-08
•  No changes to Sprout.
•  Add instantiation of CRHivk .
•  Add instantiation of a hash extractor for Jubjub.
•  Make the background lighter and the Sapling green darker, for contrast.
106




2018.0-beta-7                                                                                                         2018-02-07
•  Specify the 100000-byte limit on transaction size. (The implementation in zcashd was as intended.)
•  Specify that 0xF6 followed by 511 zero bytes encodes an empty memo   eld .
•  Reference security de  nitions for Pseudo Random Functions and Pseudo Random Generators .
•  Rename clamp to bound and ActualTimespanClamped to ActualTimespanBounded in the dif  culty adjustment
algorithm, to avoid a name collision with Curve25519 scalar “clamping”.
•  Change uses of the term full node to full validator . A full node by de  nition participates in the peer-to-peer
network, whereas a full validator just needs a copy of the block chain from somewhere. The latter is what
was meant.
•  Add an explanation of how Sapling prevents Faerie Gold and roadblock attacks.
•  Sapling work in progress.
2018.0-beta-6                                                                                                         2018-01-31
•  No changes to Sprout.
•  Sapling work in progress, mainly on Appendix A ‘Circuit Design’ on p. 121.
2018.0-beta-5                                                                                                         2018-01-30
•  Specify more precisely the requirements on Ed25519 public keys and signatures.
•  Sapling work in progress.
2018.0-beta-4                                                                                                         2018-01-25
•  No changes to Sprout.
•  Update key components diagram for Sapling.
2018.0-beta-3                                                                                                         2018-01-22
•  Explain how the chosen   x to Faerie Gold avoids a potential “roadblock” attack.
•  Update some explanations of changes from Zerocash for Sapling.
•  Add a description of the Jubjub curve .
•  Add an acknowledgement to George Tankersley.
•  Add an appendix on the design of the Sapling circuits at the quadratic constraint program level.
2017.0-beta-2.9                                                                                                       2017-12-17
•  Refer to skenc as a receiving key rather than as a viewing key.
•  Updates for incoming viewing key support.
•  Refer to Network Upgrade 0 as Overwinter.
107




2017.0-beta-2.8                                                                                                       2017-12-02
•  Correct the non-normative note describing how to check the order of πB .
•  Initial version of draft Sapling protocol speci  cation.
2017.0-beta-2.7                                                                                                       2017-07-10
•  Fix an off-by-one error in the speci  cation of the Equihash algorithm binding condition. (The implementa-
tion in zcashd was as intended.)
•  Correct the types and consensus rules for transaction version numbers and block version numbers . (Again,
the implementation in zcashd was as intended.)
•  Clarify the computation of hi in a JoinSplit statement .
2017.0-beta-2.6                                                                                                       2017-05-09
•  Be more precise when talking about curve points and pairing groups.
2017.0-beta-2.5                                                                                                       2017-03-07
•  Clarify the consensus rule preventing double-spends.
•  Clarify what a note commitment opens to in § 8.8 ‘Omission in Zerocash security proof’ on p. 96.
•  Correct the order of arguments to COMM in § 5.4.7.1 ‘Sprout Note Commitments’ on p. 63.
•  Correct a statement about indistinguishability of JoinSplit descriptions .
•  Change the Founders’ Reward addresses, for the test network only, to re  ect the hard-fork upgrade de-
scribed in [Zcash-Issue2113].
2017.0-beta-2.4                                                                                                       2017-02-25
•  Explain a variation on the Faerie Gold attack and why it is prevented.
•  Generalize the description of the InternalH attack to include  nding collisions on (apk , ρ) rather than just on
ρ.
•  Rename enforcei to enforceMerklePathi.
2017.0-beta-2.3                                                                                                       2017-02-12
•  Specify the security requirements on the SHA-256 compression function in order for the scheme in § 5.4.7.1
‘Sprout Note Commitments’ on p. 63 to be a secure commitment.
•  Specify G2 more precisely.
•  Explain the use of interstitial treestates in chained JoinSplit transfers .
108




2017.0-beta-2.2                                                                                              2017-02-11
•  Give de  nitions of computational binding and computational hiding for commitment schemes.
•  Give a de  nition of statistical zero knowledge.
•  Reference the white paper on MPC parameter generation [BGG2016].
2017.0-beta-2.1                                                                                              2017-02-06
•  ℓMerkle is a bit length, not a byte length.
•  Specify the maximum block size.
2017.0-beta-2                                                                                                2017-02-04
•  Add abstract and keywords.
•  Fix a typo in the de  nition of nulli  er integrity.
•  Make the description of block chains more consistent with upstream Bitcoin documentation (referring to
“best“ chains rather than using the concept of a block chain view ).
•  De  ne how nodes select a best chain.
2016.0-beta-1.13                                                                                             2017-01-20
•  Specify the dif  culty adjustment algorithm.
•  Clarify some de  nitions of   elds in a block header .
•  De  ne PRFaddr in § 4.2.1 ‘Sprout Key Components’ on p. 27.
2016.0-beta-1.12                                                                                             2017-01-09
•  Update the hashes of proving and verifying keys for the   nal Sprout parameters.
•  Add cross references from shielded payment address and spending key encoding sections to where the key
components are speci  ed.
•  Add acknowledgements for Filippo Valsorda and Zaki Manian.
2016.0-beta-1.11                                                                                             2016-12-19
•  Specify a check on the order of πB in a zero-knowledge proof .
•  Note that due to an oversight, the Zcash genesis block does not follow [BIP-34].
2016.0-beta-1.10                                                                                             2016-10-30
•  Update reference to the Equihash paper [BK2016]. (The newer version has no algorithmic changes, but the
section discussing potential ASIC implementations is substantially expanded.)
•  Clarify the discussion of proof size in “Differences from the Zerocash paper”.
109




2016.0-beta-1.9                                                                                                       2016-10-28
•  Add Founders’ Reward addresses for the production network.
•  Change “protected ” terminology to “shielded ”.
2016.0-beta-1.8                                                                                                       2016-10-04
•  Revise the lead bytes for transparent P2SH and P2PKH addresses, and reencode the testnet Founders’ Reward
addresses.
•  Add a section on which BIPs apply to Zcash.
•  Specify that OP_CODESEPARATOR has been disabled, and no longer affects SIGHASH transaction hashes .
•  Change the representation type of vpub_old and vpub_new to uint64. (This is not a consensus change because
the type of vpudb and vpub was already speci  ed to be {0 .. MAX_MONEY}; it just better re  ects the implemen-
tation.)
•  Correct the representation type of the block nVersion  eld to uint32.
2016.0-beta-1.7                                                                                                       2016-10-02
•  Clarify the consensus rule for payment of the Founders’ Reward , in response to an issue raised by the NCC
audit.
2016.0-beta-1.6                                                                                                       2016-09-26
•  Fix an error in the de  nition of the sortedness condition for Equihash: it is the sequences of indices that are
sorted, not the sequences of hashes.
•  Correct the number of bytes in the encoding of solutionSize.
•  Update the section on encoding of transparent addresses. (The precise pre  xes are not decided yet.)
•  Clarify why BLAKE2b-ℓ is different from truncated BLAKE2b-512.
•  Clarify a note about SU-CMA security for signatures.
•  Add a note about PRFnf corresponding to PRFsn in Zerocash.
•  Add a paragraph about key length in § 8.7 ‘In-band secret distribution’ on p. 95.
•  Add acknowledgements for John Tromp, Paige Peterson, Maureen Walsh, Jay Graber, and Jack Gavigan.
2016.0-beta-1.5                                                                                                       2016-09-22
•  Update the Founders’ Reward address list.
•  Add some clari  cations based on Eli Ben-Sasson’s review.
2016.0-beta-1.4                                                                                                       2016-09-19
•  Specify the block subsidy , miner subsidy , and the Founders’ Reward .
•  Specify coinbase transaction outputs to Founders’ Reward addresses.
•  Improve notation (for example “·” for multiplication and “T [ℓ]” for sequence types) to avoid ambiguity.
110




2016.0-beta-1.3                                                                                               2016-09-16
•  Correct the omission of solutionSize from the block header format.
•  Document that compactSize uint encodings must be canonical.
•  Add a note about conformance language in the introduction.
•  Add acknowledgements for Solar Designer, Ling Ren and Alison Stevenson, and for the NCC Group and
Coinspect security audits.
2016.0-beta-1.2                                                                                               2016-09-11
•  Remove GeneralCRH in favour of specifying hSigCRH and EquihashGen directly in terms of BLAKE2b-ℓ.
•  Correct the security requirement for EquihashGen.
2016.0-beta-1.1                                                                                               2016-09-05
•  Add a speci  cation of abstract signatures.
•  Clarify what is signed in the “Sending Notes” section.
                                                                                                              •  Specify ZK parameter generation as a randomized algorithm, rather than as a distribution of parameters.
2016.0-beta-1                                                                                                 2016-09-04
•                                                                                                             Major reorganization to separate the abstract cryptographic protocol from the algorithm instantiations.
•                                                                                                             Add type declarations.
•                                                                                                             Add a “High-level Overview” section.
•                                                                                                             Add a section specifying the zero-knowledge proving system and the encoding of proofs. Change the en-
                                                                                                              coding of points in proofs to follow IEEE Std 1363[a].
•                                                                                                             Add a section on consensus changes from Bitcoin, and the speci  cation of Equihash.
•                                                                                                             Complete the “Differences from the Zerocash paper” section.
•                                                                                                             Correct the Merkle tree depth to 29.
•                                                                                                             Change the length of memo   elds to 512 bytes.
•                                                                                                             Switch the JoinSplit signature scheme to Ed25519, with consequent changes to the computation of hSig .
•                                                                                                             Fix the lead bytes in shielded payment address and spending key  encodings to match the implemented
protocol.
•                                                                                                             Add a consensus rule about the ranges of vpudb and vpub .
•                                                                                                             Clarify cryptographic security requirements and added de  nitions relating to the in-band secret distribution.
•                                                                                                             Add various citations: the “Fixing Vulnerabilities in the Zcash Protocol” and “Why Equihash?” blog posts, sev-
eral crypto papers for security de  nitions, the Bitcoin whitepaper, the CryptoNote whitepaper, and several
references to Bitcoin documentation.
•                                                                                                             Reference the extended version of the Zerocash paper rather than the Oakland proceedings version.
•                                                                                                             Add JoinSplit transfers to the Concepts section.
•                                                                                                             Add a section on Coinbase Transactions.
•                                                                                                             Add acknowledgements for Jack Grigg, Simon Liu, Ariel Gabizon, jl777, Ben Blaxill, Alex Balducci, and Jake
Tarren.
•                                                                                                             Fix a Makefile compatibility problem with the escaping behaviour of echo.
111




•  Switch to biber for the bibliography generation, and add backreferences.
•  Make the date format in references more consistent.
•  Add visited dates to all URLs in references.
•  Terminology changes.
2016.0-alpha-3.1                                                                                                  2016-05-20
•  Change main font to Quattrocento.
2016.0-alpha-3                                                                                                    2016-05-09
•  Change version numbering convention (no other changes).
2.0-alpha-3                                                                                                       2016-05-06
•  Allow anchoring to any previous output treestate in the same transaction, rather than just the immediately
preceding output treestate .
•  Add change history.
2.0-alpha-2                                                                                                       2016-04-21
•  Change from truncated BLAKE2b-512 to BLAKE2b-256.
•  Clarify endianness, and that uses of BLAKE2b are unkeyed.
•  Minor correction to what SIGHASH types cover.
•  Add “as intended for the Zcash release of summer 2016" to title page.
•  Require PRFaddr to be collision-resistant (see § 8.8 ‘Omission in Zerocash security proof’ on p. 96).
•  Add speci  cation of path computation for the incremental Merkle tree .
•  Add a note in § 4.15.1 ‘Merkle path validity’ on p. 41 about how this condition corresponds to conditions in
the Zerocash paper.
•  Changes to terminology around keys.
2.0-alpha-1                                                                                                       2016-03-30
•  First version intended for public review.
112




11                                                                                                      References
[ABR1999]                                                                                               Michel Abdalla, Mihir Bellare, and Phillip Rogaway. DHAES: An Encryption Scheme Based on
the Dif  e-Hellman Problem. Cryptology ePrint Archive: Report 1999/007. Received March 17,
1999. September 1998. URL: https : / / eprint . iacr . org / 1999 / 007 (visited on 2016-08-21)
(↑ p 19, 95, 96).
[AGRRT2017]                                                                                             Martin Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. MiMC: Ef-
cient Encryption and Cryptographic Hashing with Minimal Multiplicative Complexity. Cryp-
tology ePrint Archive: Report 2016/492. Received May 21, 2016. January 5, 2017. URL: https :
//eprint.iacr.org/2016/492 (visited on 2018-01-12) (↑ p 137).
[AKLGL2010]                                                                                             Diego Aranha, Koray Karabina, Patrick Longa, Catherine Gebotys, and Julio López. Faster Ex-
plicit Formulas for Computing Pairings over Ordinary Curves. Cryptology ePrint Archive: Re-
port 2010/526. Last revised September 12, 2011. URL: https : / /eprint .iacr .org / 2010 / 526
(visited on 2018-04-03) (↑ p 65, 104).
[ANWW2013]                                                                                              Jean-Philippe Aumasson,  Samuel Neves,  Zooko Wilcox-O’Hearn, and  Christian Winnerlein.
BLAKE2: simpler, smaller, fast as MD5. January 29, 2013. URL: https://blake2.net/#sp (visited
on 2016-08-14) (↑ p 52, 135).
[BBDP2001]                                                                                              Mihir Bellare, Alexandra Boldyreva, Anand Desai, and David Pointcheval. Key-Privacy in Public-
Key Encryption. September 2001. URL: https://cseweb.ucsd.edu/~mihir/papers/anonenc.
html (visited on 2016-08-14). Full version. (↑ p 20, 54, 95, 99).
[BBJLP2008]                                                                                             Daniel Bernstein, Peter Birkner, Marc Joye, Tanja Lange, and Christiane Peters. Twisted Edwards
Curves. Cryptology ePrint Archive: Report 2008/013. Received January 8, 2008. March 13, 2008.
URL: https://eprint.iacr.org/2008/013 (visited on 2018-01-12) (↑ p 127, 128).
[BCGGMTV2014]                                                                                           Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer,
and Madars Virza. Zerocash: Decentralized Anonymous Payments from Bitcoin (extended ver-
sion). URL: http://zerocash-project.org/media/pdf/zerocash-extended- 20140518.pdf
(visited on 2016-08-06). A condensed version appeared in Proceedings of the IEEE Symposium
on Security and Privacy (Oakland) 2014, pages 459-474; IEEE, 2014. (↑ p 7, 8, 10, 18, 36, 41, 45, 92,
94,96).
[BCGTV2013]                                                                                             Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for
C: Verifying Program Executions Succinctly and in Zero Knowledge. Cryptology ePrint Archive:
Report 2013/507. Last revised October 7, 2013. URL: https : / /eprint .iacr .org / 2013 / 507
(visited on 2016-08-31). An earlier version appeared in Proceedings of the 33rd Annual Inter-
national Cryptology Conference, CRYPTO 2013, pages 90-108; IACR, 2013. (↑ p 70).
[BCP1988]                                                                                               Jurgen Bos, David Chaum, and George Purdy. “A Voting Scheme”. Unpublished. Presented at
the rump session of CRYPTO ’88 (Santa Barbara, California, USA, August 21-25, 1988); does not
appear in the proceedings. (↑ p 54).
[BCTV2014a]                                                                                             Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct  Non-Interac-
tive Zero Knowledge for a von Neumann Architecture. Cryptology ePrint Archive: Report
2013/879. Last revised February 5, 2019. URL: https://eprint.iacr.org/2013/879 (visited on
2019-02-08) (↑ p 70, 71, 98, 121).
[BCTV2014a-old]                                                                                         Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct Non-Interactive
Zero Knowledge for a von Neumann Architecture (May 19, 2015 version). Cryptology ePrint
Archive: Report 2013/879. Version: 20150519:172604. URL: https://eprint.iacr.org/2013/
879/20150519:172604 (visited on 2019-02-08) (↑ p 71).
[BCTV2014b]                                                                                             Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. “Scalable Zero Knowledge
via Cycles of Elliptic Curves (extended version)”. In: Advances in Cryptology - CRYPTO 2014.
Vol. 8617. Lecture Notes in Computer Science. Springer, 2014, pages 276-294. URL: https : / /
www .cs .tau .ac .il / ~tromer /papers /scalablezk - 20140803 .pdf (visited on 2016-09-01)
(↑ p 26, 98).
113




[BDEHR2011]                                                                                        Johannes Buchmann, Erik Dahmen, Sarah Ereth, Andreas Hülsing, and Markus Rückert. On
the Security of the Winternitz One-Time Signature Scheme (full version). Cryptology ePrint
Archive: Report 2011/191. Received April 13, 2011. URL: https://eprint.iacr.org/2011/191
(visited on 2016-09-05) (↑ p 20).
[BDJR2000]                                                                                         Mihir Bellare, Anand Desai, Eric Jokipii, and Phillip Rogaway. A Concrete Security Treatment of
Symmetric Encryption: Analysis of the DES Modes of Operation. September 2000. URL: https:
//cseweb.ucsd.edu/~mihir/papers/sym-enc.html (visited on 2018-02-07). An extended ab-
stract appeared in Proceedings of the 38th Annual Symposium on Foundations of Computer
Science (Miami Beach, Florida, USA, October 20-22, 1997), pages 394-403; IEEE Computer So-
ciety Press, 1997; ISBN 0-8186-8197-7. (↑ p 18).
[BDLSY2012]                                                                                        Daniel Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang. “High-speed high-
security signatures”. In: Journal of Cryptographic Engineering 2 (September 26, 2011), pages 77-
89. URL: http : / / cr . yp . to / papers . html # ed25519 (visited on 2016-08-14). Document ID:
a1a62a2f76d23f65d622484ddd09caf8. (↑ p 60, 142).
[Bernstein2001]                                                                                    Daniel Bernstein. Pippenger’s exponentiation algorithm. December 18, 2001. URL: https://cr.
yp .to /papers .html #pippenger (visited on 2018-07-27). Draft. To be incorporated into the
author’s High-speed cryptography book. Error pointed out by Sam Hocevar: the example in
Figure 4 needs 2 and is thus of length 18. (↑ p 142, 143).
[Bernstein2005]                                                                                    Daniel Bernstein. “Understanding brute force”. In: ECRYPT STVL Workshop on Symmetric Key
Encryption, eSTREAM report 2005/036. April 25, 2005. URL: https : / /cr .yp .to /papers .
html#bruteforce (visited on 2016-09-24). Document ID: 73e92f5b71793b498288efe81fe55dee.
(↑ p 96).
[Bernstein2006]                                                                                    Daniel Bernstein. “Curve25519: new Dif  e-Hellman speed records”. In: Public Key Cryptography
- PKC 2006. Proceedings of the 9th International Conference on Theory and Practice in Public-
Key Cryptography (New York, NY, USA, April 24-26, 2006). Springer-Verlag, February 9, 2006.
URL: http : / / cr . yp . to / papers . html # curve25519 (visited on 2016-08-14). Document ID:
4230efdfa673480fc079449d90f322c0. (↑ p 19, 59, 74, 75, 95).
[BGG-mpc]                                                                                          Sean Bowe, Ariel Gabizon, and Matthew Green. GitHub repository ‘zcash/mpc’: zk-SNARK pa-
                                                                                                   rameter multi-party computation protocol. URL: https://github.com/zcash/mpc (visited on
2017-01-06) (↑ p 77).
[BGG1995]                                                                                          Mihir Bellare, Oded Goldreich, and Sha   Goldwasser. “Incremental Cryptography: The Case of
Hashing and Signing”. In: Advances in Cryptology - CRYPTO ’94. Proceedings of the 14th An-
nual International Cryptology Conference (Santa Barbara, California, USA, August 21-25, 1994).
Ed. by Yvo Desmedt. Vol. 839. Lecture Notes in Computer Science. Springer, October 20, 1995,
pages 216-233. ISBN: 978-3-540-48658-9. DOI: 10 . 1007 / 3 - 540 - 48658 - 5 _ 22. URL: https :
//cseweb.ucsd.edu/~mihir/papers/inc1.pdf (visited on 2018-02-09) (↑ p 54, 56, 131).
[BGG2016]                                                                                          Sean Bowe, Ariel Gabizon, and Matthew Green. A multi-party protocol for constructing the
public parameters of the Pinocchio zk-SNARK. November 24, 2016. URL: https : / / github .
com/zcash/mpc/blob/master/whitepaper.pdf (visited on 2017-02-11) (↑ p 71, 77, 109).
[BGM2018]                                                                                          Sean Bowe, Ariel Gabizon, and Ian Miers. Scalable Multi-party Computation for zk-SNARK Pa-
rameters in the Random Beacon Model. Cryptology ePrint Archive: Report 2017/1050. Last re-
vised November 5, 2017. URL: https://eprint.iacr.org/2017/1050 (visited on 2018-08-31)
(↑ p 77, 99).
[BIP-11]                                                                                           Gavin Andresen. M-of-N Standard Transactions. Bitcoin Improvement Proposal 11. Created Oc-
tober 18, 2011. URL: https://github.com/bitcoin/bips/blob/master/bip- 0011.mediawiki
(visited on 2016-10-02) (↑ p 91).
[BIP-13]                                                                                           Gavin Andresen. Address Format for pay-to-script-hash. Bitcoin Improvement Proposal 13.
Created October 18, 2011. URL: https : / / github . com / bitcoin / bips / blob / master / bip -
0013.mediawiki (visited on 2016-09-24) (↑ p 73, 91).
114




[BIP-14]                                                                                           Amir Taaki and Patrick Strateman. Protocol Version and User Agent. Bitcoin Improvement Pro-
posal 14. Created November 10, 2011. URL: https://github.com/bitcoin/bips/blob/master/
bip-0014.mediawiki (visited on 2016-10-02) (↑ p 91).
[BIP-16]                                                                                           Gavin Andresen. Pay to Script Hash. Bitcoin Improvement Proposal 16. Created January 3, 2012.
                                                                                                   URL: https : / /github .com /bitcoin /bips /blob /master /bip - 0016 .mediawiki (visited on
2016-10-02) (↑ p 91).
[BIP-30]                                                                                           Pieter Wuille. Duplicate transactions. Bitcoin Improvement Proposal 30. Created February 22,
                                                                                                   2012. URL: https://github.com/bitcoin/bips/blob/master/bip- 0030.mediawiki (visited
on 2016-10-02) (↑ p 91).
[BIP-31]                                                                                           Mike Hearn. Pong message. Bitcoin Improvement Proposal 31. Created April 11, 2012. URL: https:
/ /github .com /bitcoin /bips /blob /master /bip - 0031 .mediawiki (visited on 2016-10-02)
(↑ p 91).
[BIP-32]                                                                                           Pieter Wuille. Hierarchical Deterministic Wallets. Bitcoin Improvement Proposal 32. Created
February 11, 2012. Last updated January 15, 2014. URL: https : / /github .com /bitcoin /bips /
blob/master/bip-0032.mediawiki (visited on 2016-09-24) (↑ p 74).
[BIP-34]                                                                                           Gavin Andresen. Block v2, Height in Coinbase. Bitcoin Improvement Proposal 34. Created July 6,
                                                                                                   2012. URL: https://github.com/bitcoin/bips/blob/master/bip- 0034.mediawiki (visited
on 2016-10-02) (↑ p 91, 109).
[BIP-35]                                                                                           Jeff Garzik. mempool message. Bitcoin Improvement Proposal  35. Created August  16,  2012.
                                                                                                   URL: https : / /github .com /bitcoin /bips /blob /master /bip - 0035 .mediawiki (visited on
2016-10-02) (↑ p 91).
[BIP-37]                                                                                           Mike Hearn and Matt Corallo. Connection Bloom   ltering. Bitcoin Improvement Proposal 37.
Created October 24, 2012. URL: https : / / github . com / bitcoin / bips / blob / master / bip -
0037.mediawiki (visited on 2016-10-02) (↑ p 91).
[BIP-61]                                                                                           Gavin Andresen. Reject P2P message. Bitcoin Improvement Proposal 61. Created June 18, 2014.
URL: https : / /github .com /bitcoin /bips /blob /master /bip - 0061 .mediawiki (visited on
2016-10-02) (↑ p 91).
[BIP-62]                                                                                           Pieter Wuille. Dealing with malleability. Bitcoin Improvement Proposal 62. Withdrawn Novem-
ber 17, 2015. URL: https : / /github .com /bitcoin /bips /blob /master /bip - 0062 .mediawiki
(visited on 2016-09-05) (↑ p 21).
[BIP-65]                                                                                           Peter Todd. OP_CHECKLOCKTIMEVERIFY. Bitcoin Improvement Proposal 65. Created October 10,
                                                                                                   2014. URL: https://github.com/bitcoin/bips/blob/master/bip- 0065.mediawiki (visited
on 2016-10-02) (↑ p 91).
[BIP-66]                                                                                           Pieter Wuille. Strict DER signatures. Bitcoin Improvement Proposal 66. Created January 10, 2015.
                                                                                                   URL: https : / /github .com /bitcoin /bips /blob /master /bip - 0066 .mediawiki (visited on
2016-10-02) (↑ p 91).
[BIP-68]                                                                                           Mark Friedenbach, BtcDrak, Nicolas Dorier, and kinoshitajona. Relative lock-time using con-
sensus-enforced sequence numbers. Bitcoin Improvement Proposal 68. Last revised Novem-
ber 21, 2015. URL: https://github.com/bitcoin/bips/blob/master/bip- 0068.mediawiki
(visited on 2016-09-02) (↑ p 81).
[BIP-111]                                                                                          Matt Corallo and Peter Todd. NODE_BLOOM service bit. Bitcoin Improvement Proposal 111. Cre-
ated August 20, 2015. URL: https : / /github .com /bitcoin /bips /blob /master /bip - 0111 .
mediawiki (visited on 2018-04-02) (↑ p 91, 104).
[BIP-173]                                                                                          Pieter Wuille and Greg Maxwell. Base32 address format for native v0-16 witness outputs. Bit-
coin Improvement Proposal 173. Last revised September 24, 2017. URL: https://github.com/
bitcoin/bips/blob/master/bip-0173.mediawiki (visited on 2018-01-22) (↑ p 73, 102).
[Bitcoin-Base58]                                                                                   Base58Check encoding — Bitcoin Wiki. URL: https : / /en .bitcoin .it /wiki /Base58Check _
encoding (visited on 2016-01-26) (↑ p 73, 74).
115




[Bitcoin-Block]                                                                                    Block Headers — Bitcoin Developer Reference. URL: https : / /bitcoin .org /en /developer -
reference#block-headers (visited on 2017-04-25) (↑ p 85).
[Bitcoin-CoinJoin]                                                                                 CoinJoin — Bitcoin Wiki. URL: https://en.bitcoin.it/wiki/CoinJoin (visited on 2016-08-17)
(↑ p 9).
[Bitcoin-Format]                                                                                   Raw Transaction Format — Bitcoin Developer Reference. URL: https : / / bitcoin . org / en /
developer-reference#raw-transaction-format (visited on 2016-03-15) (↑ p 81).
[Bitcoin-Multisig]                                                                                 P2SH  multisig  (de  nition)  —  Bitcoin  Developer  Guide. URL: https : / / bitcoin . org / en /
developer-guide#term-p2sh-multisig (visited on 2016-08-19) (↑ p 90).
[Bitcoin-nBits]                                                                                    Target nBits — Bitcoin Developer Reference. URL: https : / / bitcoin . org / en / developer -
                                                                                                   reference#target-nbits (visited on 2016-08-13) (↑ p 84, 88).
[Bitcoin-Order]                                                                                    Hash Byte Order — Bitcoin Developer Reference. URL: https://bitcoin.org/en/developer-
                                                                                                   reference#hash-byte-order (visited on 2018-02-09) (↑ p 78).
[Bitcoin-P2PKH]                                                                                    P2PKH (de  nition) — Bitcoin Developer Guide. URL: https : / /bitcoin .org /en /developer -
                                                                                                   guide#term-p2pkh (visited on 2016-08-24) (↑ p 73).
[Bitcoin-P2SH]                                                                                     P2SH (de  nition) — Bitcoin Developer Guide. URL: https : / / bitcoin . org / en / developer -
                                                                                                   guide#term-p2sh (visited on 2016-08-24) (↑ p 73).
[Bitcoin-Protocol]                                                                                 Protocol documentation — Bitcoin Wiki. URL: https : / / en . bitcoin . it / wiki / Protocol _
                                                                                                   documentation (visited on 2016-10-02) (↑ p 8).
[Bitcoin-SigHash]                                                                                  Signature Types — Bitcoin Developer Guide. URL: https : / / bitcoin . org / en / developer -
guide#signature-hash-types (visited on 2018-06-10) (↑ p 35).
[BJLSY2015]                                                                                        Daniel Bernstein, Simon Josefsson, Tanja Lange, Peter Schwabe, and Bo-Yin Yang. EdDSA for
more curves. Technical Report. July 4, 2015. URL: https : / /cr .yp .to /papers .html #eddsa
(visited on 2018-01-22) (↑ p 60, 69).
[BK2016]                                                                                           Alex Biryukov and Dmitry Khovratovich. Equihash: Asymmetric Proof-of-Work Based on the
Generalized Birthday Problem (full version). Cryptology ePrint Archive: Report 2015/946. Last
revised October 27, 2016. URL: https://eprint.iacr.org/2015/946 (visited on 2016-10-30)
(↑ p 10, 86, 109).
[BL-SafeCurves]                                                                                    Daniel Bernstein and Tanja Lange. SafeCurves: choosing safe curves for elliptic-curve cryptog-
raphy. URL: https://safecurves.cr.yp.to (visited on 2018-01-29) (↑ p 95, 118).
[BL2017]                                                                                           Daniel Bernstein and Tanja Lange. Montgomery curves and the Montgomery ladder. Cryptology
ePrint Archive: Report 2017/293. Received March 30, 2017. URL: https://eprint.iacr.org/
2017/293 (visited on 2017-11-26) (↑ p 121, 127, 128, 129).
[BLS2002]                                                                                          Paulo Barreto, Ben Lynn, and Michael Scott. Constructing Elliptic Curves with Prescribed Em-
bedding Degrees. Cryptology ePrint Archive: Report 2002/088. Last revised February 22, 2005.
URL: https://eprint.iacr.org/2002/088 (visited on 2018-04-20) (↑ p 67, 104).
[BN2005]                                                                                           Paulo Barreto and Michael Naehrig. Pairing-Friendly Elliptic Curves of Prime Order. Cryptology
ePrint Archive: Report 2005/133. Last revised February 28, 2006. URL: https://eprint.iacr.
org/2005/133 (visited on 2018-04-20) (↑ p 65, 104).
[BN2007]                                                                                           Mihir Bellare and Chanathip Namprempre. Authenticated Encryption: Relations among no-
tions and analysis of the generic composition paradigm. Cryptology ePrint Archive: Report
2000/025. Last revised July 14, 2007. URL: https : / /eprint .iacr .org / 2000 / 025 (visited on
2016-09-02) (↑ p 19).
[Bowe-bellman]                                                                                     Sean Bowe. bellman: zk-SNARK library. URL: https://github.com/ebfull/bellman (visited
on 2018-04-03) (↑ p 71, 77).
[Bowe2017]                                                                                         Sean Bowe. ebfull/pairing source code, BLS12-381 - README.md as of commit e726600. URL:
https://github.com/ebfull/pairing/tree/e72660056e00c93d6b054dfb08ff34a1c67cb799/
src/bls12_381 (visited on 2017-07-16) (↑ p 67).
116




[Bowe2018]                                                                                         Sean Bowe. Random Beacon. March 22, 2018. URL: https://github.com/ZcashFoundation/
powersoftau-attestations/tree/master/0088 (visited on 2018-04-08) (↑ p 78).
[Carroll1876]                                                                                      Lewis Carroll. The Hunting of the Snark. With illustrations by Henry Holiday. MacMillan and Co.
London. March 29, 1876. URL: https://www.gutenberg.org/files/29888/29888-h/29888-
h.htm (visited on 2018-05-23) (↑ p 68).
[Carroll1902]                                                                                      Lewis Carroll. Through the Looking-Glass, and What Alice Found There (1902 edition). Illus-
trated by Peter Newell and Robert Murray Wright. Harper and Brothers Publishers. New York.
October 1902. URL: https : / /archive .org /details /throughlookinggl00carr4 (visited on
2018-06-20) (↑ p 98, 102).
[CDvdG1987]                                                                                        David Chaum, Ivan Damgård, and Jeroen van de Graaf. “Multiparty  computations  ensuring
privacy of each party’s input and correctness of the result”. In: Advances in Cryptology -
CRYPTO ’87. Proceedings of the 14th Annual International Cryptology Conference (Santa Bar-
bara, California, USA, August 16-20, 1987). Ed. by Carl Pomerance. Vol. 293. Lecture Notes in
Computer Science. Springer, January 1988, pages 87-119. ISBN: 978-3-540-48184-3. DOI: 10 .
1007/3- 540- 48184- 2_7. URL: https://www.researchgate.net/profile/Jeroen_Van_de_
Graaf /publication / 242379939 _Multiparty _computations _ensuring _secrecy _of _each _
party%27s_input_and_correctness_of_the_output (visited on 2018-03-01) (↑ p 54).
[CVE-2019-7167]                                                                                    Common Vulnerabilities and Exposures. CVE-2019-7167. URL: https://cve.mitre.org/cgi-
bin/cvename.cgi?name=CVE-2019-7167 (visited on 2019-02-05) (↑ p 71).
[CvHP1991]                                                                                         David Chaum, Eugène van Heijst, and Birgit P  tzmann. Cryptographically Strong Undeniable
Signatures, Unconditionally Secure for the Signer. February 1991. URL: http : / / citeseerx .
ist.psu.edu/viewdoc/summary?doi=10.1.1.34.8570 (visited on 2018-02-17). An extended
abstract appeared in Advances in Cryptology - CRYPTO ’91: Proceedings of the 11th Annual In-
ternational Cryptology Conference (Santa Barbara, California, USA, August 11-15, 1991); Ed. by
Joan Feigenbaum; Vol. 576, Lecture Notes in Computer Science, pages 470-484; Springer, 1992;
ISBN 978-3-540-55188-1. (↑ p 54, 131).
[Dalek-notes]                                                                                      Cathie Yun, Henry de Valence, Oleg Andreev, and Dimitris Apostolou. ristretto_bulletproofs
notes. URL: https://doc-internal.dalek.rs/ristretto_bulletproofs/notes/index.html
(visited on 2018-08-17) (↑ p 39, 99).
[deRooij1995]                                                                                      Peter de Rooij. “Ef  cient exponentiation using precomputation and vector addition chains”.
In: Advances in Cryptology - EUROCRYPT ’94. Proceedings, Workshop on the Theory and Ap-
plication of Cryptographic Techniques (Perugia, Italy, May 9-12, 1994). Ed. by Alfredo De San-
tis. Vol. 950. Lecture Notes in Computer Science. Springer, pages 389-399. ISBN: 978-3-540-
60176-0. DOI: 10.1007/BFb0053453. URL: https://link.springer.com/chapter/10.1007/
BFb0053453 (visited on 2018-07-27) (↑ p 142, 143).
[DGKM2011]                                                                                         Dana Dachman-Soled, Rosario Gennaro, Hugo Krawczyk, and Tal Malkin. Computational Ex-
tractors and Pseudorandomness. Cryptology ePrint Archive: Report 2011/708. December 28,
2011. URL: https://eprint.iacr.org/2011/708 (visited on 2016-09-02) (↑ p 96).
[DigiByte-PoW]                                                                                     DigiByte Core Developers. DigiSpeed 4.0.0 source code, functions GetNextWorkRequiredV3/4
in src/main.cpp as of commit 178e134. URL: https://github.com/digibyte/digibyte/blob/
178e1348a67d9624db328062397fde0de03fe388/src/main.cpp#L1587 (visited on 2017-01-20)
(↑ p 87).
[DS2016]                                                                                           David Derler and Daniel Slamanig. Key-Homomorphic Signatures and Applications to Mul-
tiparty Signatures and Non-Interactive Zero-Knowledge. Cryptology ePrint Archive: Report
2016/792. Last revised February 6, 2017. URL: https : / /eprint .iacr .org / 2016 / 792 (visited
on 2018-04-09) (↑ p 22).
117




[DSDCOPS2001]                                                                                     Alfredo De Santis, Giovanni Di Crescenzo, Rafail Ostrovsky, Guiseppe Persiano, and Amit Sa-
hai. “Robust Non-Interactive Zero Knowledge”. In: Advances in Cryptology - CRYPTO 2001.
Proceedings of the 21st Annual International Cryptology Conference (Santa Barbara, Califor-
nia, USA, August 19-23, 2001). Ed. by Joe Kilian. Vol. 2139. Lecture Notes in Computer Science.
Springer, 2001, pages 566-598. ISBN: 978-3-540-42456-7. DOI: 10.1007/3- 540- 44647- 8_33.
URL: https : / /www .iacr .org /archive /crypto2001 / 21390566 .pdf (visited on 2018-05-28)
(↑ p 26, 35).
[ElGamal1985]                                                                                     Taher ElGamal. “A public key cryptosystem and a signature scheme based on discrete log-
arithms”. In: IEEE Transactions on Information Theory  31.4 (July 1985), pages 469-472. ISSN:
0018-9448. DOI: 10.1109/TIT.1985.1057074. URL: https://people.csail.mit.edu/alinush/
6.857-spring-2015/papers/elgamal.pdf (visited on 2018-08-17) (↑ p 54).
[EWD-831]                                                                                         Edsger W. Dijkstra. Why numbering should start at zero.  Manuscript. August 11, 1982. URL:
                                                                                                  https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html (visited on
2016-08-09) (↑ p 10).
[FKMSSS2016]                                                                                      Nils Fleischhacker, Johannes Krupp, Giulio Malavolta, Jonas Schneider, Dominique Schröder,
and Mark Simkin. Ef  cient  Unlinkable  Sanitizable  Signatures  from  Signatures  with  Re-
Randomizable Keys. Cryptology ePrint Archive: Report 2012/159. Last revised February 11, 2016.
URL: https://eprint.iacr.org/2015/395 (visited on 2018-03-03). An extended abstract ap-
peared in Public Key Cryptography - PKC 2016: 19th IACR International Conference on Prac-
tice and Theory in Public-Key Cryptography (Taipei, Taiwan, March 6-9, 2016), Proceedings,
Part 1; Ed. by Chen-Mou Cheng, Kai-Min Chung, Giuseppe Persiano, and Bo-Yin Yang; Vol. 9614,
Lecture Notes in Computer Science, pages 301-330; Springer, 2016; ISBN 978-3-662-49384-7.
(↑ p 21, 22, 60).
[Gabizon2019]                                                                                     Ariel Gabizon. On the security of the BCTV Pinocchio zk-SNARK variant. Draft. February 5,
2019. URL: https : / /github .com /arielgabizon /bctv /blob /master /bctv .pdf (visited on
2019-02-07) (↑ p 71, 97, 98).
[GGM2016]                                                                                         Christina Garman,  Matthew Green, and  Ian Miers. Accountable  Privacy  for  Decentralized
Anonymous  Payments. Cryptology ePrint Archive: Report 2016/061. Last revised January 24,
2016. URL: https://eprint.iacr.org/2016/061 (visited on 2016-09-02) (↑ p 93).
[Groth2016]                                                                                       Jens Groth. On the Size of Pairing-based Non-interactive Arguments. Cryptology ePrint Archive:
Report 2016/260. Last revised May 31, 2016. URL: https://eprint.iacr.org/2016/260 (visited
on 2017-08-03) (↑ p 71, 72, 142).
[Hamdon2018]                                                                                      Elise Hamdon. Sapling Activation Complete. Zcash blog. June 28, 2018. URL: https://z.cash/
blog/sapling-activation-complete/ (visited on 2019-02-08) (↑ p 78).
[Hopwood2018]                                                                                     Daira Hopwood. GitHub repository ‘daira/jubjub’: Supporting evidence for security of the Jub-
jub curve to be used in Zcash. URL: https://github.com/daira/jubjub (visited on 2018-02-18).
Based on code written for SafeCurves [BL-SafeCurves] by Daniel Bernstein and Tanja Lange.
(↑ p 95).
[HW2016]                                                                                          Taylor Hornby  and  Zooko Wilcox. Fixing Vulnerabilities in the Zcash Protocol. Zcash blog.
April 26, 2016. URL: https : / /blog .z .cash /fixing - zcash - vulns/ (visited on 2018-04-15).
Updated December 26, 2017. (↑ p 94).
[IEEE2000]                                                                                        IEEE Computer Society. IEEE Std 1363-2000: Standard Speci  cations for Public-Key Cryptog-
raphy. IEEE, August 29, 2000. DOI: 10.1109/IEEESTD.2000.92292. URL: http://ieeexplore.
ieee.org/servlet/opac?punumber=7168 (visited on 2016-08-03) (↑ p 66).
[IEEE2004]                                                                                        IEEE Computer Society. IEEE Std 1363a-2004: Standard Speci  cations for Public-Key Cryp-
tography - Amendment 1: Additional Techniques. IEEE, September 2, 2004. DOI: 10 . 1109 /
IEEESTD . 2004 . 94612. URL: http : / /ieeexplore .ieee .org /servlet /opac ?punumber = 9276
(visited on 2016-08-03) (↑ p 66, 95, 97).
[Jedusor2016]                                                                                     Tom Elvis Jedusor. Mimblewimble. July 19, 2016. URL: http : / /diyhpl .us / ~bryan /papers2 /
bitcoin/mimblewimble.txt (visited on 2018-04-03) (↑ p 39).
118




[KvE2013]                                                                                         Kaa1el and Hagen von Eitzen. If a group G has odd order, then the square function is injective
(answer). Mathematics Stack Exchange. URL: https://math.stackexchange.com/a/522277/
185422                                                                                            (visited on 2018-02-08). Version: 2013-10-11. (↑ p 69).
[KYMM2018]                                                                                        George Kappos, Haaroon Yousaf, Mary Maller, and Sarah Meiklejohn. An Empirical Analysis
of Anonymity in Zcash. Preprint, to be presented at the 27th Usenix Security Syposium (Balti-
more, Maryland, USA, August 15-17, 2018). May 8, 2018. URL: https://smeiklej.com/files/
usenix18.pdf (visited on 2018-06-05) (↑ p 9).
[LG2004]                                                                                          Eddie Lenihan and Carolyn Eve Green. Meeting the Other Crowd: The Fairy Stories of Hidden
Ireland. TarcherPerigee, February 2004, pages 109-110. ISBN: 1-58542-206-1 (↑ p 92).
[libsodium-Seal]                                                                                  Sealed boxes  —  libsodium. URL: https : / / download . libsodium . org / doc / public - key _
cryptography/sealed_boxes.html (visited on 2016-02-01) (↑ p 95).
[LM2017]                                                                                          Philip Lafrance and Alfred Menezes. On the security of the WOTS-PRF signature scheme. Cryp-
tology ePrint Archive: Report 2017/938. Last revised February 5, 2018. URL: https://eprint.
iacr.org/2017/938 (visited on 2018-04-16) (↑ p 20).
[MAEÁ2010]                                                                                        V. Gayoso Martínez, F. Hernández Alvarez, L. Hernández Encinas, and C. Sánchez Ávila. “A Com-
parison of the Standardized Versions of ECIES”. In: Proceedings of Sixth International Confer-
ence on Information Assurance and Security  (Atlanta, Georgia, USA, August 23-25,  2010).
IEEE, 2010, pages 1-4. ISBN: 978-1-4244-7407-3. DOI: 10 . 1109 / ISIAS . 2010 . 5604194. URL:
https : / /digital .csic .es /bitstream / 10261 / 32674 / 1 /Gayoso _A % 20Comparison % 20of %
20the%20Standardized%20Versions%20of%20ECIES.pdf (visited on 2016-08-14) (↑ p 95).
[Nakamoto2008]                                                                                    Satoshi Nakamoto. Bitcoin: A Peer-to-Peer Electronic Cash System. October 31, 2008. URL:
https://bitcoin.org/en/bitcoin-paper (visited on 2016-08-14) (↑ p 7).
[NIST2015]                                                                                        NIST. FIPS 180-4: Secure Hash Standard (SHS). August 2015. DOI: 10 . 6028 /NIST .FIPS . 180 -
                                                                                                  4. URL: https : / / csrc . nist . gov / publications / detail / fips / 180 / 4 / final (visited on
                                                                                                  2018-02-14) (↑ p 51, 74).
[Parno2015]                                                                                       Bryan Parno. A Note on the Unsoundness of vnTinyRAM’s SNARK. Cryptology ePrint Archive:
                                                                                                  Report 2015/437. Received May 6, 2015. URL: https://eprint.iacr.org/2015/437 (visited on
                                                                                                  2019-02-08) (↑ p 71, 97, 98).
[Peterson2017]                                                                                    Paige Peterson. Transaction Linkability. Zcash blog. January 25, 2017. URL: https : / /blog .z .
cash/transaction-linkability/ (visited on 2018-04-15) (↑ p 9, 104).
[PHGR2013]                                                                                        Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly Practical Veri  -
able Computation. Cryptology ePrint Archive: Report 2013/279. Last revised May 13, 2013. URL:
https://eprint.iacr.org/2013/279 (visited on 2016-08-31) (↑ p 70).
[Quesnelle2017]                                                                                   Jeffrey Quesnelle. On the linkability of Zcash transactions. arXiv:1712.01210 [cs.CR]. December 4,
2017. URL: https://arxiv.org/abs/1712.01210 (visited on 2018-04-15) (↑ p 9, 104).
[RFC-2119]                                                                                        Scott Bradner. Request for Comments 7693: Key words for use in RFCs to Indicate Requirement
Levels. Internet Engineering Task Force (IETF). March 1997. URL: https : / /tools .ietf .org /
html/rfc2119 (visited on 2016-09-14) (↑ p 7).
[RFC-7539]                                                                                        Yoav Nir and Adam Langley. Request for Comments 7539: ChaCha20 and Poly1305 for IETF
Protocols. Internet Research Task Force (IRTF). May 2015. URL: https : / / tools . ietf . org /
html /rfc7539 (visited on 2016-09-02). As modi  ed by veri  ed errata at https : / /www .rfc -
editor.org/errata_search.php?rfc=7539 (visited on 2016-09-02). (↑ p 58, 59).
[RIPEMD160]                                                                                       Hans Dobbertin, Antoon Bosselaers, and Bart Preneel. RIPEMD-160, a strengthened version of
                                                                                                  RIPEMD. URL: http : / /homes .esat .kuleuven .be / ~bosselae /ripemd160 .html (visited on
2016-09-24) (↑ p 74).
119




[ST1999]                                                                                          Tomas Sander and Amnon Ta-Shma. “Auditable, Anonymous Electronic Cash”. In: Advances in
Cryptology - CRYPTO ’99. Proceedings of the 19th Annual International Cryptology Conference
(Santa Barbara, California, USA, August 15-19, 1999). Ed. by Michael Wiener. Vol. 1666. Lecture
Notes in Computer Science. Springer, 1999, pages 555-572. ISBN: 978-3-540-66347-8. DOI: 10.
1007/3- 540- 48405- 1_35. URL: https://link.springer.com/content/pdf/10.1007/3- 540-
48405-1_35.pdf (visited on 2018-06-05) (↑ p 98, 101).
[SWB2019]                                                                                         Josh Swihart, Benjamin Winston, and Sean Bowe. Zcash Counterfeiting Vulnerability Success-
fully Remediated. February 5, 2019. URL: https : / /z .cash /blog /zcash - counterfeiting -
vulnerability-successfully-remediated/ (visited on 2019-02-05) (↑ p 71, 98).
[Swihart2018]                                                                                     Josh Swihart. Overwinter Activated Successfully. Zcash blog. June 26, 2018. URL: https://blog.
z.cash/overwinter-activated-successfully/ (visited on 2018-07-18) (↑ p 78).
[Unicode]                                                                                         The Unicode Consortium. The Unicode Standard. The Unicode Consortium, 2016. URL: http:
//www.unicode.org/versions/latest/ (visited on 2016-08-31) (↑ p 72).
[vanSaberh2014]                                                                                   Nicolas van Saberhagen. CryptoNote v 2.0. Date disputed. URL: https : / /cryptonote .org /
whitepaper.pdf (visited on 2016-08-17) (↑ p 9).
[Vercauter2009]                                                                                   Frederik Vercauteren. Optimal pairings. Cryptology ePrint Archive: Report 2008/096. Last re-
vised March 7, 2008. URL: https : / / eprint . iacr . org / 2008 / 096 (visited on 2018-04-06).
A version of this paper appeared in IEEE Transactions of Information Theory, Vol. 56, pages
455-461; IEEE, 2009. (↑ p 65, 104).
[WCBTV2015]                                                                                       Zooko Wilcox, Alessandro Chiesa, Eli Ben-Sasson, Eran Tromer, and Madars Virza. A Bug in
libsnark. Least Authority blog. May 16, 2015. URL: https://leastauthority.com/blog/a_bug_
in_libsnark/ (visited on 2018-05-22) (↑ p 71, 121).
[WG2016]                                                                                          Zooko Wilcox and Jack Grigg. Why Equihash? Zcash blog. April 15, 2016. URL: https://blog.
z.cash/why-equihash/ (visited on 2018-04-15). Updated December 14, 2017. (↑ p 86).
[Zaverucha2012]                                                                                   Gregory M. Zaverucha. Hybrid Encryption in the Multi-User Setting. Cryptology ePrint Archive:
Report 2012/159. Received March 20, 2012. URL: https://eprint.iacr.org/2012/159 (visited
on 2016-09-24) (↑ p 96).
[Zcash-Issue2113]                                                                                 Simon Liu. GitHub repository ‘ zcash/zcash’ : Issue 2113. URL: https : / /github .com /zcash /
zcash/issues/2113 (visited on 2017-02-20) (↑ p 90, 108).
[Zcash-libsnark]                                                                                  libsnark: C++ library for zkSNARK proofs (Zcash fork). URL: https : / / github . com / zcash /
zcash/tree/master/src/snark (visited on 2018-02-04) (↑ p 70).
[ZIP-32]                                                                                          Jack Grigg and Daira Hopwood. Shielded Hierarchical Deterministic Wallets. Zcash Improve-
ment Proposal 32 (in progress). (↑ p 29, 32, 46, 54, 62, 102).
[ZIP-76]                                                                                          Jack Grigg and Daira Hopwood. Transaction Signature Veri  cation before Overwinter. Zcash
Improvement Proposal 76 (in progress). (↑ p 35, 91).
[ZIP-143]                                                                                         Jack Grigg and Daira Hopwood. Transaction Signature Veri  cation for Overwinter. Zcash Im-
provement Proposal 143. Created December 27, 2017. URL: https://github.com/zcash/zips/
blob/master/zip-0143.rst (visited on 2018-03-01) (↑ p 35, 52, 78).
[ZIP-200]                                                                                         Jack Grigg. Network Upgrade Mechanism. Zcash Improvement Proposal 200. Created January 8,
                                                                                                  2018. URL: https : / / github . com / zcash / zips / blob / master / zip - 0200 . rst (visited on
2018-03-01) (↑ p 78, 81).
[ZIP-201]                                                                                         Simon Liu. Network Peer Management for Overwinter. Zcash Improvement Proposal 201. Cre-
ated January 15, 2018. URL: https://github.com/zcash/zips/blob/master/zip- 0201.rst
(visited on 2018-03-01) (↑ p 78).
[ZIP-202]                                                                                         Simon Liu. Version 3 Transaction Format for Overwinter. Zcash Improvement Proposal 202.
Created January 10, 2018. URL: https://github.com/zcash/zips/blob/master/zip-0202.rst
(visited on 2018-03-01) (↑ p 78).
120




[ZIP-203]                                                                                                               Jay Graber. Transaction Expiry. Zcash Improvement Proposal 203. Created January 9, 2018. URL:
https://github.com/zcash/zips/blob/master/zip-0203.rst (visited on 2018-03-01) (↑ p78,
79).
[ZIP-205]                                                                                                               Daira Hopwood. Deployment of the Sapling Network Upgrade. Zcash Improvement Proposal
205. Created October 8, 2018. URL: https : / /github .com /zcash /zips /blob /master /zip -
0205.rst (visited on 2019-02-08) (↑ p 78, 88).
[ZIP-243]                                                                                                               Jack Grigg and Daira Hopwood. Transaction Signature Veri  cation for Sapling. Zcash Improve-
ment Proposal 243. Created April 10, 2018. URL: https : / /github .com /zcash /zips /blob /
master/zip-0243.rst (visited on 2018-04-15) (↑ p 35, 38, 39, 52, 78).
Appendices
A   Circuit Design
A.1                                                                                                                     Quadratic Constraint Programs
Sapling de  nes two circuits, Spend and Output, each implementing an abstract statement described in § 4.15.2
‘Spend Statement (Sapling)’ on p. 42 and § 4.15.3 ‘Output Statement (Sapling)’ on p. 43 respectively.  It also
adds a Groth16 circuit for the JoinSplit statement described in § 4.15.1 ‘JoinSplit Statement (Sprout)’ on p. 41.
At the next lower level, each circuit is de  ned in terms of a quadratic constraint program (specifying a Rank 1
Constraint System), as detailed in this section. In the BCTV14 or Groth16 proving systems, this program is translated
to a Quadratic Arithmetic Program [BCTV2014a, section 2.3] [WCBTV2015]. The circuit descriptions given here are
necessary to compute witness elements for each circuit, as well as the proving and veri  cation keys.
Let FrS  be the   nite   eld over which Jubjub is de  ned, as given in § 5.4.8.3 ‘Jubjub’ on p. 68.
A quadratic constraint program consists of a set of constraints over variables in FrS , each of the form:
(                                                                                                                       )                                                                                               (   )       (       )
A                                                                                                                                                                                                                           B   =   C
                                                                                                                        (                                                                                               )   (   )           (   )
where                                                                                                                   A                                                                                               ,   B       , and   C
are linear combinations of variables and constants in FrS .
Here   and · both represent multiplication in the  eld FrS , but we use   for multiplications corresponding to gates
of the circuit, and · for multiplications by constants in the terms of a linear combination.   should not be confused
with × which is de  ned as cartesian product in § 2 ‘Notation’ on p. 9.
A.2                                                                                                                     Elliptic curve background
The Sapling circuits make use of a twisted Edwards curve, Jubjub, and also a Montgomery curve M that is bi-
rationally equivalent to Jubjub. From here on we omit “twisted” when referring to the Edwards Jubjub curve or
coordinates.  Following the notation in [BL2017] we use (u, v) for af  ne coordinates on the Edwards curve, and
(x, y) for af  ne coordinates on the Montgomery curve.
A point P is normally represented by two FrS  variables, which we name as (P u, P v ) for an af  ne Edwards point,
for instance.
The implementations of scalar multiplication require the scalar to be represented as a bit sequence. We therefore
allow the notation [k⋆] P meaning [LEBS2IPlength(k⋆) (k⋆)] P . There will be no ambiguity because variables repre-
senting bit sequences are named with a ⋆ suf  x.
121




The Montgomery curve M has parameters AM  = 40962 and BM  = 1. We use an af  ne representation of this curve
with the formula:
BM ·y2  = x3 + AM ·x2 + x
Usually, elliptic curve arithmetic over prime   elds is implemented using some form of projective coordinates,
in order to reduce the number of expensive inversions required.  In the circuit, it turns out that a division can
be implemented at the same cost as a multiplication, i.e. one constraint.  Therefore it is bene  cial to use af  ne
coordinates for both curves.
We de  ne the following types representing af  ne Edwards and Montgomery coordinates respectively:
AffineEdwardsJubjub := (u ◦ FrS ) × (v ◦ FrS ) : aJ ·u2 + v2  = 1 + dJ ·u2 ·v2
AffineMontJubjub := (x ◦ FrS ) × (y ◦ FrS ) : BM ·y2  = x3 + AM ·x2 + x
We also de  ne a type representing compressed, not necessarily valid, Edwards coordinates:
CompressedEdwardsJubjub := ( ũ ◦ B) × (v ◦ FrS )
See § 5.4.8.3 ‘Jubjub’ on p. 68 for how this type is represented as a byte sequence in external encodings.
We use af  ne Montgomery arithmetic in parts of the circuit because it is more ef  cient, in terms of the number
of constraints, than af  ne Edwards arithmetic.
An important consideration when using Montgomery arithmetic is that the addition formula is not complete, that
is, there are cases where it produces the wrong answer. We must ensure that these cases do not arise.
We will need the theorem below about y-coordinates of points on Montgomery curves.
Fact:   AM2 − 4 is a nonsquare in Fr
S
Theorem A.2.1.  Let P  =  (x, y) be a point other than (0, 0) on a Montgomery curve EMont(A,B) over Fr , such that
A2 − 4 is a nonsquare in Fr . Then y , 0.
Proof.  Substituting y = 0 into the Montgomery curve equation gives 0 = x3 + A · x2 + x = x · (x2 + A · x + 1). So
either x = 0 or x2 + A · x + 1 = 0. Since P  , (0, 0), the case x = 0 is excluded. In the other case, complete the square
for x2 + A · x + 1 = 0 to give the equivalent (2 · x + A)2  = A2 − 4. The left-hand side is a square, so if the right-hand
side is a nonsquare, then there are no solutions for x.                                                                      □
A.3                                                                                                                          Circuit Components
Each of the following sections describes how to implement a particular component of the circuit, and counts the
number of constraints required. Some components make use of others; the order of presentation is “bottom-up”.
It is important for security to ensure that variables intended to be of boolean type are boolean-constrained; and for
ef  ciency that they are boolean-constrained only once. We explicitly state for the boolean inputs and outputs of
each component whether they are boolean-constrained by the component, or are assumed to have been boolean-
constrained separately.
Af  ne coordinates for elliptic curve points are assumed to represent points on the relevant curve, unless otherwise
speci  ed.
In this section, variables have type FrS  unless otherwise speci  ed. In contrast to most of this document, we use
zero-based indexing in order to more closely match the implementation.
122




A.3.1                                                                                                                Operations on individual bits
A.3.1.1                                                                                                              Boolean constraints
                                                                                                                                                                                                                                                                     A boolean constraint b ∈ B can be implemented as:
                                                                                                                     (                               )   (                                                 )                                             (           )
                                                                                                                     1 − b                                                                                 b                     =                                   0
A.3.1.2                                                                                                                                                                                                                          Conditional equality
                                                                                                                                                                                                                                                                                                                                                                                      The constraint “either a = 0 or b = c” can be implemented as:
                                                                                                                     (                               )   (                                                 )                                             (           )
                                                                                                                     a                                   b − c                                                                   =                                   0
A.3.1.3                                                                                                                                                                                                                          Selection constraints
                                                                                                                                                                                                                                                                                                                                                                                      A selection constraint (b ? x : y) = z, where b ◦ B has been boolean-constrained, can be implemented as:
                                                                                                                     (                               )   (                                                 )                                             (           )
                                                                                                                     b                                   y − x                                                                   =                       y − z
A.3.1.4                                                                                                                                                                                                    Nonzero constraints
                                                                                                                                                                                                                                                                     Since only nonzero elements of FrS  have a multiplicative inverse, the assertion a  ,  0 can be implemented by
                                                                                                                                                         witnessing the inverse, ainv  = a−1  (mod rS ):
(                                                                                                                    )                               (   )                                                                       (                       )
ainv                                                                                                                                                 a                                                     =                     1
Non-normative note:   A global optimization allows to use a single inverse computation outside the circuit for
any number of nonzero constraints. Suppose that we have n variables (or linear combinations ) that are supposed
∏n−1
to be nonzero: a0 .. n−1. Multiply these together (using n−1 constraints) to give a∗  =                              ai; then, constrain a∗ to
                                                                                                                     i=0
be nonzero. This works because the product a∗ is nonzero if and only if all of a0 .. n−1 are nonzero. However, the
Sapling circuit does not use this optimization.
A.3.1.5                                                                                                              Exclusive-or constraints
                                                                                                                                                                                                                                                                                                                                                                                      An exclusive-or operation a ⊕ b = c, where a, b ◦ B are already boolean-constrained, can be implemented in one
constraint as:
                                                                                                                     (                               )   (                                                 )                                             (           )
                                                                                                                     2·a                                                                                   b                     =                       a + b − c
This automatically boolean-constrains c. Its correctness can be seen by checking the truth table of (a, b).
123




A.3.2                                                                                                                                                                                                                                                                                                          Operations on multiple bits
A.3.2.1                                                                                                                                                                                                                                              [Un]packing modulo rS
                                                                                                                                                                                                                                                                                                                                                             Let n ◦ N+ be a constant. The operation of converting a   eld element, a ◦ Fr                                                                                                                                                                                                                                                                                                                   , to a sequence of boolean variables
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         S
                                                                                                                                                                                                                                                                                                                                                   ∑n−1
                                                                                                                            b0 .. n−1  ◦ B[n] such that a =                                                                                                                                                                                                                                                                                  bi · 2i                                                                                                                                                                                                                    (mod rS ), is called “unpacking ”. The inverse operation is called “packing ”.
                                                                                                                                                                                                                                                                                                                                                             i=0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                In the quadratic constraint program these are the same operation (but see the note about canonical representation
                                                                                                                                                                                                                                                                                                                                                                                                                                             below). We assume that the variables b0 .. n−1 are boolean-constrained separately.
                                                                                                                                                                                                                                                                                                                                             (               )                                                                                                                                                                            (                                                                                                                         )
                                                                                                                                                                                                                                                                                                                                             ∑                                                                                                                                                                                            ∑
We have a mod rS  =                                                                                                                                                                                                                                                                                                                                bi · 2i                                                                                   mod rS  =                                                                                          bi · (2i mod rS )                                                                                                       mod rS.
                                                                                                                                                                                                                                                                                                                                             i=0                                                                                                                                                                                          i=0
                                                                                                                                                                                                                                                     This can be implemented in one constraint:
                                                                                                                            (                                                                                                                                                                                                                )
                                                                                                                            ∑                                                                                                                                                                                                                      (         )                                                                                                                                                                    (   )
                                                                                                                                                                                                                                 bi · (2i mod rS )                                                                                                           1                                                                               =                                                                                    a
i=0
Notes:
•  The bit length n is not limited by the   eld element size.
•  Since the constraint has only a trivial multiplication, it is possible to eliminate it by merging it into the boolean
constraint of one of the output bits, expressing that bit as a linear combination of the others and a. However,
this optimization requires substitutions that would interfere with the modularity of the circuit implemen-
tation (for a saving of only one constraint per unpacking operation), and so we do not use it for the Sapling
circuit.
•  In the case n = 255, for a < 2255 − rS there are two possible representations of a ◦ Fr                                  as a sequence of 255
S
bits, corresponding to I2LEBSP255 (a) and I2LEBSP255 (a + rS ). This is a potential hazard, but it may or may
not be necessary to force use of the canonical representation I2LEBSP255 (a), depending on the context in
which the [un]packing operation is used.  We therefore do not consider this to be part of the [un]packing
operation itself.
A.3.2.2                                                                                                                     Range check
∑n−1
◦
Let n  ◦ N+ be a constant, and let a  =                                                                                     ai  · 2i                                                                                             ◦    N              . Suppose we want to constrain a  ≤ c for some constant
i=0
∑n−1
c =                                                                                                                         ci · 2i  ◦   N.
i=0
Without loss of generality we can assume that cn−1  = 1, because if it were not then we would decrease n accord-
ingly.
Note that since a and c are provided in binary representation, their bit length n is not limited by the   eld element
size. We do not assume that the bits a0 .. n−1 are already boolean-constrained.
∏n−1
De  ne Πm  =                                                                                                                (ci  = 0 ∨ ai  = 1) for m ∈ {0 .. n − 1}. Notice that for any m < n − 1 such that cm  = 0, we have
i=m
Πm  = Πm+1, and so it is only necessary to allocate separate variables for the Πm such that m < n − 1 and cm  = 1.
Furthermore if cn−2 .. 0 has t > 0 trailing 1 bits, then we do not need to allocate variables for Π0 .. t−1 because those
variables will not be used below.
124




More explicitly:
Let Πn−1  = an−1.
For i from n − 2 down to t,
•  if ci  = 0, then let Πi  = Πi+1;
                                                                                                                                                                                 (                                                                                                                                                                          )                                                                                          (    )    (                                                                                                              )
                                                                                                                          •  if ci  = 1, then constrain                                                                                                      Πi+1                                                                                                                                                                                      ai   =    Πi
                                                                                                                          Then we constrain the ai as follows:
For i from n − 1 down to 0,
                                                                                                                                                                 (                                                                                                                                                                                                                                                                                     )    (    )                                                                                                              (   )
•  if ci  = 0, constrain                                                                                                                                         1 − Πi+1 − ai                                                                                                                                                                                                                                                                              ai   =                                                                                                              0   ;
                                                                                                                                                                                                                                                                                                                                                            •  if ci  = 1, boolean-constrain ai as in §A.3.1.1 ‘Boolean constraints’ on p. 123.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Note that the constraints corresponding to zero bits of c are in place of boolean constraints on bits of ai.
                                                                                                                                                                                                                                                                                                                                                            This costs n + k constraints, where k is the number of non-trailing 1 bits in cn−2 .. 0.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ∑n−1                                ∑n−1
                                                                                                                                                                                 Theorem A.3.1.  Assume c0 .. n−1  ◦  B[n]  and cn−1  =  1.  De  ne Am  :=                                                                                                                                                                                                                                                                                                                                           ai  · 2i  and Cm  :=                ci  · 2i.  For
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               i=m                                 i=m
any m  ∈  {0 .. n − 1}, Am  ≤ Cm iff the restriction of the above constraint system to i  ∈  {m .. n − 1} is satis  ed.
Furthermore the system at least boolean-constrains a0 .. n−1.
Proof.  For i  ∈  {0 .. n − 1} such that ci  =  1, the corresponding ai are unconditionally boolean-constrained. This
)
1 − Πi+1 − ai                                                                                                             ai                                     =               0                                                                           constrains ai to be 0 if Πi+1  = 1, otherwise it constrains ai  ∈ B. So all of a0 .. n−1 are
at least boolean-constrained.
To prove the rest of the theorem we proceed by induction on decreasing m, i.e. taking successively longer pre  xes
of the big-endian binary representations of a and c.
Base case m = n − 1: since cn−1  = 1, the constraint system has just one boolean constraint on an−1, which ful  ls
the theorem since An−1  ≤ Cn−1 is always satis  ed.
Inductive case m < n − 1:
•  If Am+1  > Cm+1, then by the inductive hypothesis the constraint system must fail, which ful  ls the theorem
regardless of the value of am.
•  If Am+1  ≤ Cm+1, then by the inductive hypothesis the constraint system restricted to i  ∈  {m + 1 .. n − 1}
                                                                                                                          ∏n−1                                   ∏n−1
succeeds. We have Πm+1  =                                                                                                 (ci  = 0 ∨ ai  = 1) =                  (ai  ≥ ci ).
                                                                                                                          i=m+1                                  i=m+1
–  If Am+1  = Cm+1, then ai  = ci for all i ∈ {m + 1 .. n − 1} and so Πm+1  = 1. Also Am  ≤ Cm iff am  ≤ cm.
When cm  = 1, only a boolean constraint is added for am which ful  ls the theorem.
When cm  = 0, am is constrained to be 0 which ful  ls the theorem.
-  If Am+1  < Cm+1, then it cannot be the case that ai  ≥ ci for all i ∈ {m + 1 .. n − 1}, so Πm+1  = 0.
This implies that the constraint on am  is always equivalent to a boolean constraint, which ful  ls the
theorem because Am  ≤ Cm must be true regardless of the value of am.
This covers all cases.                                                                                                    □
Correctness of the full constraint system follows by taking m = 0 in the above theorem.
The algorithm in §A.3.3.2 ‘Edwards [de]compression and validation’ on p. 126 uses range checks with c = rS − 1
to validate compressed Edwards points. In that case n = 255 and k = 132, so the cost of each such range check is
387 constraints.
125




Non-normative note:   It is possible to optimize the computation of Πt .. n−2 further. Notice that Πm is only used
when m is the index of the last bit of a run of 1 bits in c. So for each such run of 1 bits cm .. m+N −2 of length N − 1,
∏N−1
                                                                                                                                                                                                                                                                                         it is suf  cient to compute an N -ary AND of am .. m+N −2  and Πm+N −1: R =                                                                                                                                                                                                                                                                                                                   Xi. This can be computed in 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 i=0
                                                                                                                                                                                                                                                                                                                                                                       constraints for any N ; boolean-constrain the output R, and then add constraints
(                                                                                                                           ∑N−1                                                                                                                                    )   (     )      (                                                                                                                                                                    )                                                                                       ∑N−1
N −                                                                                                                                                                                           Xi                                                                        inv          =   1 − R                                                                                                                                                                                                                                  to enforce that                                                                                                            Xi  , N when R = 0;
                                                                                                                                                                                        i=0                                                                                                                                                                                                                                                                                                                                                                                                                                                       i=0
(                                                                                                                           ∑N−1                                                                                                                                    )   (     )      (   )                                                                                                                                                                                                                                                        ∑N−1
N −                                                                                                                                                                                           Xi                                                                        R     =      0                                                                                                                                                                                                                                          to enforce that                                                                                                            Xi  = N when R = 1.
                                                                                                                                                                                        i=0                                                                                                                                                                                                                                                                                                                                                                                                                                                       i=0
                                                                                                                                                                                                                                                                              (          ∑N−1                                                                                                                                                                                                                                   )
−1
where inv is witnessed as                                                                                                   N −                                                         Xi    if R  =  0 or is unconstrained otherwise.  (Since N  < rS, the sums
i=0
cannot over  ow.)
In fact the last constraint is not needed in this context because it is suf  cient to compute an upper bound on each
Πm  (i.e. it does not bene  t a malicious prover to witness R = 1 when the result of the AND should be 0). So the
cost of computing Π variables for an arbitrarily long run of 1 bits can be reduced to 2 constraints. For example, for
c = rS − 1 the overall cost would be reduced to 255 + 68 = 323 constraints.
These optimizations are not used in Sapling.
A.3.3                                                                                                                       Elliptic curve operations
A.3.3.1                                                                                                                     Checking that af  ne Edwards coordinates are on the curve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  To check that (u, v) is a point on the Edwards curve, the Sapling circuit uses 4 constraints:
(                                                                                                                           )                                                           (     )                                                                         (     )
u                                                                                                                                                                                             u                                                                     =   uu
(                                                                                                                           )                                                           (     )                                                                     (         )
v                                                                                                                                                                                             v                                                                     =   vv
(                                                                                                                           )                                                                 (                                                                     )         (      )
uu                                                                                                                                                                                            vv                                                                    =         uuvv
(                                                                                                                                                                                                                                                                   )   (     )          (                                                                                                                                                                                                                                      )
                                                                                                                            aJ ·uu + vv                                                                                                                                       1      =                                                                                 1 + dJ ·uuvv
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (        )                     (     )                                   (                     )
                                                                                                                                                                                                                                                                                                                                                                                                                                                          Non-normative note:   The last two constraints can be combined into                                                                                                                     dJ ·uu                         vv                                    =       aJ ·uu + vv − 1       The
Sapling circuit does not use this optimization.
A.3.3.2                                                                                                                     Edwards [de]compression and validation
De  ne DecompressValidate ◦ CompressedEdwardsJubjub → AffineEdwardsJubjub as follows:
DecompressValidate( ũ, v) :
// Prover supplies the u-coordinate.
Let u ◦ FrS .
// §A.3.3.1 ‘Checking that affine Edwards coordinates are on the curve’ on p. 126.
Check that (u, v) is a point on the Edwards curve.
// §A.3.2.1 ‘[Un]packing modulo rS’ on p. 124.
∑254
Unpack u to                                                                                                                 ui · 2i, equating ũ with u0.
i=0
// §A.3.2.2 ‘Range check’ on p. 124.
∑254
Check that                                                                                                                  ui · 2i  ≤ rS − 1.
i=0
Return (u, v).
126




This costs 4 constraints for the curve equation check, 1 constraint for the unpacking, and 387 constraints for the
range check (as computed in §A.3.2.2 ‘Range check’ on p. 124) for a total of 392 constraints. The cost of the range
check includes boolean-constraining u0 .. 254.
The same quadratic constraint program is used for compression and decompression.
Note:   The point-on-curve check could be omitted if (u, v) were already known to be on the curve. However, the
Sapling circuit never omits it; this provides a consistency check on the elliptic curve arithmetic.
A.3.3.3                                                                                                                    Edwards ↔ Montgomery conversion
                                                                                                                                                                                                                                                     De  ne EdwardsToMont ◦ AffineEdwardsJubjub → AffineMontJubjub as follows:
                                                                                                                                                                                                                               (                                                                                                                                                                                                                            )
                                                                                                                                                                                                                                   1 + v                                                                                                                                                                                                            1 + v
                                                                                                                                                             EdwardsToMont(u, v) =                                                                                                                                               √−40964 ·                                                                                                                                               [1 − v , 0  and u , 0]
                                                                                                                                                                                                                                   1 − v ,                                                                                                               (1 − v) · u
                                                                                                                                                                                                                                                     De  ne MontToEdwards ◦ AffineMontJubjub → AffineEdwardsJubjub as follows:
                                                                                                                                                                                                                               (                                                                                                                                                                                                                    )
                                                                                                                                                             MontToEdwards(x, y) =                                                 √−40964 · x                                                                                                                                                                                                                  [x + 1 , 0  and y , 0]
                                                                                                                                                                                                                                                                                                                                             y , x + 1
                                                                                                                                                                                                                                                                                                                                                         Either of these conversions can be implemented by the same quadratic constraint program:
(                                                                                                                          )                                                         (   )           (√                                          )
y                                                                                                                                                                                    u       =            −40964 · x
(                                                                                                                                                            )                               (   )        (                    )
x + 1                                                                                                                                                                                        v       =                 x − 1
The above conversions should only be used if the input is guaranteed to be a point on the relevant curve. If that is
the case, the theorems below enumerate all exceptional inputs that may violate the side-conditions.
Theorem A.3.2.  Let (u, v) be an af  ne point on a complete twisted Edwards curve EEdwards(a,d) .  Then the only
points with u = 0 or 1 − v = 0 are (0, 1) = OJ, and (0, −1) of order 2.
Proof.  The curve equation is a ·u2 + v2  = 1 + d ·u2 ·v2  with a , d (see [BBJLP2008, De  nition 2.1]). By substituting
u = 0 we obtain v = ±1, and by substituting v = 1 and using a , d we obtain u = 0.                                         □
Theorem A.3.3.  Let (x, y) be an af  ne point on a Montgomery curve EMont(A,B) over Fr with parameters A and B
such that A2 − 4 is a nonsquare in Fr , that is birationally equivalent to a complete twisted Edwards curve. Then
x + 1 , 0, and the only point (x, y) with y = 0 is (0, 0) of order 2.
Proof.  That the only point with y = 0 is (0, 0) is proven by Theorem A.2.1 on p. 122.
If x + 1 = 0, then subtituting x = −1 into the Montgomery curve equation gives B · y2  = x3 + A · x2 + x = A − 2. So
in that case y2  = (A − 2)/B. The right-hand-side is equal to the parameter d of a particular complete twisted Ed-
wards curve birationally equivalent to the Montgomery curve (see [BL2017, section 4.3.5]). For all complete twisted
Edwards curves, d is nonsquare, so this equation has no solutions for y, hence x + 1 , 0.                                  □
(When the theorem is applied with EMont(A,B)  = M de  ned in §A.2 ‘Elliptic curve background’ on p. 121, the com-
plete twisted Edwards curve referred to in the proof is an isomorphic rescaling of the Jubjub curve .)
127




A.3.3.4                                                                                                                  Af  ne-Montgomery arithmetic
The incomplete af  ne-Montgomery addition formulae given in [BL2017, section 4.3.2] are:
x3  = BM ·λ2 − AM − x1 − x2
y3  = (x1 − x3 ) ·λ − y1

3·x1 + 2·AM ·x1 + 1
                                                                                                                                                                  ,  if x1  = x2
                                                                                                                                                        2·BM ·y1
where λ =
                                                                                                                                                       y2 − y1
otherwise.
x2 − x1 ,
The following theorem helps to determine when these incomplete addition formulae can be safely used:
}
                                                                                                                         k1 .. 2 be integers in                                                                                                                                                                                       \ {0}. Let Pi  = [ki] Q = (xi, yi ) for i ∈ {1 .. 2}, with k2  , ±k1. Then the non-uni  ed
                                                                                                                                                                                            2                                                               2
                                                                                                                         addition constraints
(                                                                                                                                                                  )                (   )   (                                                               )
x2 − x1                                                                                                                                                                             λ   =   y2 − y1
(                                                                                                                                                       )          (                )   (                                                                                                                                         )
BM ·λ                                                                                                                                                                               λ   =                                               AM + x1 + x2 + x3
(                                                                                                                                                                  )                (   )   (                                                               )
x1 − x3                                                                                                                                                                             λ   =   y3 + y1
implement the af  ne-Montgomery addition P1 + P2  = (x3, y3 ) for all such P1 .. 2.
Proof.  The given constraints are equivalent to the Montgomery addition formulae under the side condition that
x1  , x2.  (Note that neither Pi can be the zero point since k1 .. 2  ,  0  (mod s).)  Assume for a contradiction that
x1  = x2. For any P1  =  [k1] Q, there can be only one other point −P1  with the same x-coordinate.  (This follows
                                                                                                                         {                                                                  }                                                                                                                                         {                                                                                                }
k ◦                                                                                                                                                                                                                                                         → [k] Q ◦ M is injective and k1 .. 2 are in                                                                                                                                , then k2  = ±k1 (contradiction).                                          □
                                                                                                                                                                   2                    2                                                                                                                                                                                                                                          2   2
                                                                                                                                                                                                                                                            The conditions of this theorem are called the distinct-x criterion.
                                                                                                                                                                                                                                                            {                                                                     }
                                                                                                                                                                                            In particular, if k1 .. 2 are integers in                                                                                                                                                                                                  then it is suf  cient to require k2  , k1, since that implies k2  , ±k1.
                                                                                                                                                                                                                                                            2
                                                                                                                                                                                                                                                            Af  ne-Montgomery doubling can be implemented as:
                                                                                                                         (                              )          (                )       (                                           )
                                                                                                                         x                                         x                    =   xx
                                                                                                                         (                                                          )   (   )                                           (                   )
                                                                                                                                                        2·BM ·y                             λ                                           =                   3·xx + 2·AM ·x + 1
                                                                                                                         (                                         )                    (   )                                           (                   )
                                                                                                                                                        BM ·λ                           λ   =                                                               AM + 2·x + x3
                                                                                                                         (                                         )                    (   )                                           (                   )
                                                                                                                                                        x − x3                          λ                                               =                   y3 + y
This doubling formula is valid when y  , 0, which is the case when (x, y) is not the point (0, 0) (the only point of
order 2), as proven in Theorem A.2.1 on p. 122.
A.3.3.5                                                                                                                  Af  ne-Edwards arithmetic
Formulae for af  ne-Edwards addition are given in [BBJLP2008, section 6].  With a change of variable names to
match our convention, the formulae for (u1, v1 ) + (u2, v2 ) = (u3, v3 ) are:
u1 ·v2 + v1 ·u2
u3  =
1 + dJ ·u1 ·u2 ·v1 ·v2
v3  =  v1 ·v2 − aJ ·u1 ·u2
1 − dJ ·u1 ·u2 ·v1 ·v2
128




We use an optimized implementation found by Daira Hopwood making use of an observation by Bernstein and
Lange in [BL2017, last paragraph of section 4.5.2]:
(                                                                                                                                                             )        (                      )                       (                 )
                                                                                                                        u1 + v1                                             v2 − aJ ·u2               =               T
(                                                                                                                       )                                     (   )         (             )
                                                                                                                        u1                                        v2   =    A
(                                                                                                                       )                                     (   )         (             )
v1                                                                                                                                                                u2   =    B
(                                                                                                                                                             )   (    )    (             )
                                                                                                                        dJ ·A                                     B    =                  C
(                                                                                                                                                             )   (    )                  (           )
                                                                                                                        1 + C                                     u3        =                 A + B
(                                                                                                                                                             )   (    )                  (                                                 )
                                                                                                                        1 − C                                     v3        =                         T − A + aJ ·B
The correctness of this implementation can be seen by expanding T − A + aJ ·B:
T − A + aJ ·B = (u1 + v1 ) · (v2 − aJ ·u2 ) − u1 ·v2 + aJ ·v1 ·u2
= v1 ·v2 − aJ ·u1 ·u2 + u1 ·v2 − aJ ·v1 ·u2 − u1 ·v2 + aJ ·v1 ·u2
= v1 ·v2 − aJ ·u1 ·u2
The above addition formulae are “uni  ed”, that is, they can also be used for doubling. Af                              ne-Edwards doubling
[2] (u, v) = (u3, v3 ) can also be implemented slightly more ef  ciently as:
(                                                                                                                                                             )        (                      )                       (                 )
u + v                                                                                                                                                                       v − aJ ·u                 =               T
(                                                                                                                       )                                     (   )         (             )
u                                                                                                                                                                 v    =    A
(                                                                                                                                                             )        (    )                 (       )
dJ ·A                                                                                                                                                                  A                  =   C
(                                                                                                                                                             )        (    )                 (                       )
1 + C                                                                                                                                                                  u3                 =   2·A
(                                                                                                                                                             )        (    )                 (                                             )
1 − C                                                                                                                                                                  v3                 =                           T + (aJ − 1) ·A
                                                                                                                                                                                                                                                This implementation is obtained by specializing the addition formulae to (u, v) = (u1, v1   ) = (u2, v2 ) and observing
                                                                                                                        that u · v = A = B.
A.3.3.6                                                                                                                 Af  ne-Edwards nonsmall-order check
In order to avoid small-subgroup attacks, we check that certain points used in the circuit are not of small order.
In practice the Sapling circuit uses this in combination with a check that the coordinates are on the curve (§A.3.3.1
‘Checking that affine Edwards coordinates are on the curve’ on p. 126), so we combine the two operations.
The Jubjub curve has a large prime-order subgroup with a cofactor of 8. To check for a point P of order 8 or less,
the Sapling circuit doubles three times (as in §A.3.3.5 ‘Affine-Edwards arithmetic’ on p. 128) and checks that the
resulting u-coordinate is not 0 (as in §A.3.1.4 ‘Nonzero constraints’ on p. 123).
On a twisted Edwards curve, only the zero point OJ, and the unique point of order 2 at  (0, −1) have zero u-
coordinate. The point of order 2 cannot occur as the result of three doublings. So this u-coordinate check rejects
only OJ.
The total cost, including the curve check, is 4 + 3 · 5 + 1 = 20 constraints.
Note:   This does not ensure that the point is in the prime-order subgroup.
129




Non-normative notes:
•  It would have been suf  cient to do two doublings rather than three, because the check that the u-coordinate
is nonzero would reject both OJ and the point of order 2.
•  It is possible to reduce the cost to 8 constraints by eliminating the redundant constraint in the curve point
check mentioned in §A.3.3.1 ‘Checking that affine Edwards coordinates are on the curve’ on p. 126; merg-
ing the   rst doubling with the curve point check; and then optimizing the second doubling based on the
fact that we only need to check whether the resulting u-coordinate is zero. The Sapling circuit does not use
these optimizations.
A.3.3.7                                                                                                                  Fixed-base af  ne-Edwards scalar multiplication
If the base point B is  xed for a given scalar multiplication [k] B, we can fully precompute window tables for each
window position.
It is most ef  cient to use 3-bit   xed windows. Since the length of rJ is 252 bits, we need 84 windows.
∑
Express k in base 8, i.e. k =                                                                                            ki ·8i.
i=0
∑
Then [k] B =                                                                                                             w(B, i, ki ) , where w(B, i, k                                                                                 = [ki ·8i] B.
i )
i=0
We precompute all of w(B, i, s) for i ∈ {0 .. 83}, s ∈ {0 .. 7}.
To look up a given window entry w(B, i, s)  = (us, vs ), where s = 4·s2 + 2·s1 + s0, we use:
(                                                                                                                        )                                                                                                              (               )                                                                                    (    )
s1                                                                                                                                                                                                                                      s2              =                                                                                    sî
(                                                                                                                        )                                                                                                              (
s0                                                                                                                                                                                                                                                                                                                                                    − u0 ·sî + u0 ·s2  + u0 ·s1 − u0  + u2 ·sî − u2 ·s1  + u4 ·sî − u4 ·s2 − u6 ·sî
)
                                                                                                                                                                                                                                                        + u1 ·sî − u1 ·s2 − u1 ·s1  + u1 − u3 ·sî + u3 ·s1 − u5 ·sî + u5 ·s2  + u7 ·sî       =
                                                                                                                         (                                                                                                                                                                                                                   )
                                                                                                                                                                                                                                                        us − u0 ·sî + u0 ·s2  + u0 ·s1 − u0  + u2 ·sî − u2 ·s1  + u4 ·sî − u4 ·s2 − u6 ·sî
(                                                                                                                        )                                                                                                              (
                                                                                                                         s0                                                                                                                             − v0 ·sî + v0 ·s2  + v0 ·s1 − v0  + v2 ·sî − v2 ·s1  + v4 ·sî − v4 ·s2 − v6 ·sî
                                                                                                                                                                                                                                                                                                                                             )
                                                                                                                                                                                                                                                        + v1 ·sî − v1 ·s2 − v1 ·s1  + v1 − v3 ·sî + v3 ·s1 − v5 ·sî + v5 ·s2  + v7 ·sî       =
                                                                                                                         (                                                                                                                                                                                                                   )
vs − v0 ·sî + v0 ·s2  + v0 ·s1 − v0  + v2 ·sî − v2 ·s1  + v4 ·sî − v4 ·s2 − v6 ·sî
For a full-length (252-bit) scalar this costs 3 constraints for each of 84 window lookups, plus 6 constraints for each
of 83 Edwards additions (as in §A.3.3.5 ‘Affine-Edwards arithmetic’ on p. 128), for a total of 750 constraints.
Fixed-base scalar multiplication is also used in two places with shorter scalars:
•                                                                                                                        §A.3.6 ‘Homomorphic Pedersen Commitment’ on p. 135 uses a 64-bit scalar for the v input to ValueCommit,
requiring 22 windows at a cost of 3·22 − 1 + 6·21 = 191 constraints;
•                                                                                                                        §A.3.3.10 ‘Mixing Pedersen hash’ on p. 134 uses a 32-bit scalar for the pos input to MixingPedersenHash, re-
quiring 11 windows at a cost of 3·11 − 1 + 6·10 = 92 constraints.
None of these costs include the cost of boolean-constraining the scalar.
Non-normative notes:
•  It would be more ef  cient to use arithmetic on the Montgomery curve, as in §A.3.3.9 ‘Pedersen hash’ on
p. 131. However since there are only three instances of   xed-base scalar multiplication in the Spend circuit
and two in the Output circuit 6, the additional complexity was not considered justi  ed for Sapling.
6 A Pedersen commitment uses   xed-base scalar multiplication as a subcomponent.
130




•  For the multiplications with 64-bit and 32-bit scalars, the scalar is padded to a multiple of 3 bits with zeros.
This causes the computation of sî in the lookup for the most signi  cant window to be optimized out, which
is where the “− 1” comes from in the above cost calculations. No further optimization is done for this lookup.
A.3.3.8                                                                                                                   Variable-base af  ne-Edwards scalar multiplication
When the base point B is not   xed, the method in the preceding section cannot be used. Instead we use a naïve
double-and-add method.
∑250
Given k =                                                                                                                 ki ·2i, we calculate R = [k] B using:
i=0
// Basei  = [2i] B
let Base0  = B
let Acc0  = k0  ? Base0  : 0
let Acc0  = k0  ? Base0  : 1
for i from 1 up to 250:
let Basei  = [2] Basei−1
// select Basei or OJ depending on the bit ki
let Addendi  = ki  ? Basei  : 0
i                                                                                                                         i                                                    : 1
let Acci  = Acci−1 + Addendi
let R = Acc250.
This costs 5 constraints for each of 250 Edwards doublings, 6 constraints for each of 250 Edwards additions, and 2
constraints for each of 251 point selections, for a total of 3252 constraints.
Non-normative note:   It would be more ef  cient to use 2-bit   xed windows, and/or to use arithmetic on the
Montgomery curve in a similar way to §A.3.3.9 ‘Pedersen hash’ on p. 131.  However since there are only two in-
stances of variable-base scalar multiplication in the Spend circuit and one in the Output circuit , the additional
complexity was not considered justi  ed for Sapling.
A.3.3.9                                                                                                                   Pedersen hash
The speci  cation of the Pedersen hashes used in Sapling is given in § 5.4.1.7 ‘Pedersen Hash Function’ on p. 54. It is
based on the scheme from [CvHP1991, section 5.2] -for which a tighter security reduction to the Discrete Logarithm
Problem was given in [BGG1995]- but tailored to allow several optimizations in the circuit implementation.
Pedersen hashes are the single most commonly used primitive in the Sapling circuits. MerkleDepthSapling Pedersen
hash instances are used in the Spend circuit to check a Merkle path to the note commitment of the note being
spent. We also reuse the Pedersen hash implementation to construct the commitment scheme NoteCommitSapling .
This motivates considerable attention to optimizing this circuit implementation of this primitive, even at the cost
of complexity.
First, we use a windowed scalar multiplication algorithm with signed digits.  Each 3-bit message chunk corre-
sponds to a window; the chunk is encoded as an integer from the set Digits = {−4 .. 4} \ {0}. This allows a more
ef  cient lookup of the window entry for each chunk than if the set {1 .. 8} had been used, because a point can be
conditionally negated using only a single constraint.
Next, we optimize the cost of point addition by allowing as many additions as possible to be performed on the
Montgomery curve.  An incomplete Montgomery addition costs 3 constraints, in comparison with an Edwards
addition which costs 6 constraints.
131




However, we cannot do all additions on the Montgomery curve because the Montgomery addition is incomplete.
In order to be able to prove that exceptional cases do not occur, we need to ensure that the distinct-x criterion
from §A.3.3.4 ‘Affine-Montgomery arithmetic’ on p. 128 is met.  This requires splitting the input into segments
(each using an independent generator), calculating an intermediate result for each segment, and then converting
to the Edwards curve and summing the intermediate results using Edwards addition.
Abstracting away the changes of curve, this calculation can be written as:
∑
PedersenHashToPoint(D, M ) =                                                                                                j
j=1
j  are de  ned as in § 5.4.1.7 ‘Pedersen Hash Function’ on p. 54.
We have to prove that:
•  the Montgomery-to-Edwards conversions can be implemented without exceptional cases;
•  the distinct-x criterion is met for all Montgomery additions within a segment.
                                                                                                                            {                                                                                                           }
The proof of Theorem 5.4.1 on p. 55 showed that all indices of addition inputs are in the range                             −rJ − 1                                                                                                     .. rJ − 1                                       \{0}.
                                                                                                                            2                                                                                                           2
j                                                                                                                           (which are outputs of GroupHashJ(r)∗ ) are all of prime order, and 〈Mj 〉 , 0  (mod rJ ), it is guaranteed
j  to be converted to Edwards form are of prime order. From Theorem A.3.3 on p. 127,
we can infer that the conversions will not encounter exceptional cases.
We also need to show that the indices of addition inputs are all distinct disregarding sign.
Theorem A.3.5.  For all disjoint nonempty subsets S and S′ of {1 .. c}, all m ∈ B[3][c], and all Θ ∈ {−1, 1}:
∑                                                                                                                           ∑
enc(mj ) · 24·(j−1)  , Θ ·                                                                                                  enc(mj′ ) · 24·(j′ −1) .
j∈S                                                                                                                         j′ ∈S′
                                                                                                                                                                                                                                                                                        Proof.  Suppose for a contradiction that S, S′, m, Θ is a counterexample. Taking the multiplication by Θ on the right
                                                                                                                            hand side inside the summation, we have:
∑                                                                                                                                                                                                                                       ∑
                                                                                                                            enc(mj ) · 24·(j−1)  =                                                                                      Θ · enc(mj′ ) · 24·(j′ −1) .
j∈S                                                                                                                                                                                                                                     j′ ∈S′
                                                                                                                            De  ne enc′  ◦ {−1, 1} × B[3]  → {0 .. 8} \ {4} as enc′
                                                                                                                                                                                                                                                                                        θ (mi ) := 4 + θ · enc(mi ).
                                                                                                                            ∑c
Let Δ = 4 ·                                                                                                                                                                                                                                                                             24·(i−1) as in the proof of Theorem 5.4.1 on p. 55. By adding Δ to both sides, we get
                                                                                                                            i=1
∑                                                                                                                                                                                                                                       ∑                                               ∑                                                                                                                       ∑
enc′                                                                                                                        (mj ) · 24·(j−1) +                                                                                          4 · 24·(j−1)  =                                 enc′Θ (mj′ ) · 24·(j′ −1) +                                                                                             4 · 24·(j′ −1)
                                                                                                                            1
j∈S                                                                                                                                                                                                                                     j∈{1 .. c}\S                                    j′ ∈S′                                                                                                                  j′ ∈{1 .. c}\S′
where all of the enc′                                                                                                       1                                                                                                           (mj ) and enc′Θ (mj′ ) are in {0 .. 8} \ {4}.
Each term on the left and on the right affects the single hex digit indexed by j and j′ respectively. Since S and S′
are disjoint subsets of {1 .. c} and S is nonempty, S ∩ ({1 .. c} \ S′ ) is nonempty. Therefore the left hand side has at
least one hex digit not equal to 4 such that the corresponding right hand side digit is 4; contradiction.                   □
This implies that the terms in the Montgomery addition -as well as any intermediate results formed from adding
a distinct subset of terms- have distinct indices disregarding sign, hence distinct x-coordinates by Theorem A.3.4
on p. 128. (We make no assumption about the order of additions.)
We now describe the subcircuit used to process each chunk, which contributes most of the constraint cost of the
hash. This subcircuit is used to perform a lookup of a Montgomery point in a 2-bit window table, conditionally
negate the result, and add it to an accumulator holding another Montgomery point.
132




Suppose that the bits of the chunk, [s0, s1, s2], are already boolean-constrained.
We aim to compute C = A + [(1 − 2 · s2 ) · (1 + s0 + 2 · s1 )] P for some  xed base point P and accumulated sum A.
We   rst compute sî = s0 î s1:
(                                                                                                                             )   (    )                                  (                                               )
s0                                                                                                                                s1   =
sî
Let (xk , yk ) = [k] P for k ∈ {1 .. 4}. De  ne each coordinate of (xS , yR ) = [1 + s0 + 2 · s1] P as a linear combination
of s0, s1, and sî:
let xS  = x1 + (x2 − x1 ) · s0 + (x3 − x1 ) · s1 + (x4 + x1 − x2 − x3 ) · sî
let yR  = y1 + (y2 − y1 ) · s0 + (y3 − y1 ) · s1 + (y4 + y1 − y2 − y3 ) · sî
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (        )                                                                                                                  (                                                                                   )       (                 )
                                                                                                                                                                          We implement the conditional negation as                                                                                                                                                                                                                                                                                                            2 · yR                                                                                                                      s2                                                                                      =   yR − yS                                      . After substitution of yR this becomes:
(                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               )       (    )
                                                                                                                                                                                                                                                                                                                                                                         2 · (y1 + (y2 − y1 ) · s0 + (y3 − y1 ) · s1 + (y4 + y1 − y2 − y3 ) · sî)                                                                                                                                                                                                                                                                                                                       s2       =
                                                                                                                              (                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         )
                                                                                                                                                                                                                                                                                                                                                                                                                                                    y1 + (y2 − y1 ) · s0 + (y3 − y1 ) · s1 + (y4 + y1 − y2 − y3 ) · sî − yS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Then we substitute xS  into the Montgomery addition constraints from §A.3.3.4 ‘Affine-Montgomery arithmetic’
on p. 128, as follows:
(                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   )        (   )       (                                                    )
                                                                                                                                                                                                                                                                                                                                                                         x1 + (x2 − x1 ) · s0 + (x3 − x1 ) · s1 + (x4 + x1 − x2 − x3 ) · sî − xA                                                                                                                                                                                                                                                                                                                             λ       =   yS − yA
(                                                                                                                                 )    (                                  )                                                                                                        (                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              )
BM ·λ                                                                                                                                                                     λ                                               =                                                                                                                                                                                                                                                                                                                                                                                                                               AM + xA + x1 + (x2 − x1 ) · s0 + (x3 − x1 ) · s1 + (x4 + x1 − x2 − x3 ) · sî + xC
(                                                                                                                                      )                                  (                                               )                                                                                                                                   (                                                                                     )
xA − xC                                                                                                                                                                                                                   λ                                                        =                                                                          yC  + yA
(In the sapling-crypto implementation, linear combinations are   rst-class values, so these substitutions do not
need to be done “by hand”.)
For the  rst addition in each segment, both sides are looked up and substituted into the Montgomery addition, so
the   rst lookup takes only 2 constraints.
When these hashes are used in the circuit, the   rst 6 bits of the input are   xed. For example, in the Merkle tree
hashes they represent the layer number. This would allow a precomputation for the   rst two windows, but that
optimization is not done in Sapling.
                                                                                                                                  (    )                                                                                                                                                                                                                      (                                                                                     )
                                                                                                                                  ℓ                                                                                                                                                                                                                                      ℓ
c = ceiling                                                                                                                                                                                                               and the number of segments is n = ceiling
                                                                                                                                  3                                                                                                                                                                                                                           3 · 63
The cost is then:
                                                                                                                              •        2·c constraints for the lookups;
                                                                                                                              •                                                                                                                                                    3· (c − n) constraints for incomplete additions on the Montgomery curve;
                                                                                                                              •                                                                                           2·n constraints for Montgomery-to-Edwards conversions;
                                                                                                                              •                                           6· (n − 1) constraints for Edwards additions;
for a total of 5·c + 5·n − 6 constraints. This does not include the cost of boolean-constraining inputs.
In particular,
•  for the Merkle tree hashes ℓ = 516, so c = 172, n = 3, and the cost is 869 constraints;
•  when a Pedersen hash is used to implement part of a Pedersen commitment for NoteCommitSapling  (§ 5.4.7.2
‘Windowed Pedersen commitments’ on p. 64), ℓ = 6 + ℓvalue + 2·ℓJ  = 582, c = 194, and n = 4, so the cost of the
hash alone is 984 constraints.
133




A.3.3.10                                                                                                                 Mixing Pedersen hash
A mixing Pedersen hash is used to compute ρ from cm and pos in § 4.14 ‘Note Commitments and Nullifiers’ on
p. 40. It takes as input a Pedersen commitment P , and hashes it with another input x.
Let J be as de  ned in § 5.4.1.8 ‘Mixing Pedersen Hash Function’ on p. 56.
We de  ne MixingPedersenHash ◦ {0 .. rJ − 1} × J → J by:
MixingPedersenHash(P, x) := P + [x] J .
This costs 92 constraints for the scalar multiplication (§A.3.3.7 ‘Fixed-base affine-Edwards scalar multiplication’
on p. 130), and 6 constraints for the Edwards addition (§A.3.3.5 ‘Affine-Edwards arithmetic’ on p. 128), for a total
of 98 constraints.
A.3.4                                                                                                                    Merkle path check
Checking each layer of a Merkle authentication path, as described in § 4.8 ‘Merkle path validity’ on p. 34, requires
to:
•  boolean-constrain the path bit specifying whether the previous node is a left or right child;
•  conditionally swap the previous-layer and sibling hashes (as Fr elements) depending on the path bit;
•  unpack the left and right hash inputs to two sequences of 255 bits;
•  compute the Merkle hash for this node.
The unpacking need not be canonical in the sense discussed in §A.3.2.1 ‘[Un]packing modulo rS’ on p. 124; that is,
it is not necessary to ensure that the left or right inputs to the hash represent integers in the range {0 .. rS − 1}.
Since the root of the Merkle tree is calculated outside the circuit using the canonical representations, and since
the Pedersen hashes are collision-resistant on arbitrary bit-sequence inputs, an attempt by an adversarial prover
to use a non-canonical input would result in the wrong root being calculated, and the overall path check would
fail.
For each layer, the cost is 1 + 2 · 255 boolean constraints, 2 constraints for the conditional swap (implemented as
two selection constraints), and 869 constraints for the Merkle hash (§A.3.3.9 ‘Pedersen hash’ on p. 131), for a total
of 1380 constraints.
Non-normative note:   The conditional swap (a0, a1 ) → (c0, c1 ) could be implemented in only one constraint by
substituting c1  = a0 + a1 − c0 into the uses of c1. The Sapling circuit does not use this optimization.
A.3.5                                                                                                                    Windowed Pedersen Commitment
                                                                                                                                                                                                                                  We construct windowed Pedersen commitments by reusing the Pedersen hash implementation described in
                                                                                                                         §A.3.3.9 ‘Pedersen hash’ on p. 131, and adding a randomized point:
                                                                                                                                                                                                                                  (                                                                                                     )
                                                                                                                         WindowedPedersenCommitr (s) = PedersenHashToPoint                                                        “Zcash_PH”, s                                                                                             + [r] FindGroupHashJ(r)∗ (“Zcash_PH”, “r”)
                                                                                                                         This can be implemented in:
                                                                                                                                                                                                                                                                                                                                            (                                            )
ℓ
•                                                                                                                        5 ·c + 5 ·n − 6 constraints for the Pedersen hash applied to ℓ = 6 + length(s) bits, where c = ceiling   and
3
(                                                                                                                        )
ℓ
n = ceiling                                                                                                              ;
                                                                                                                         3 · 63
•                                                                                                                        750 constraints for the   xed-base scalar multiplication;
•                                                                                                                        6 constraints for the   nal Edwards addition.
134




When WindowedPedersenCommit is used to instantiate NoteCommitSapling , the cost of the Pedersen hash is 984 con-
straints as calculated in §A.3.3.9 ‘Pedersen hash’ on p. 131, and so the total cost in that case is 1740 constraints. This
does not include the cost of boolean-constraining the input s or the randomness r.
A.3.6                                                                                                                        Homomorphic Pedersen Commitment
The windowed Pedersen commitments de  ned in the preceding section are highly ef  cient, but they do not sup-
port the homomorphic property we need when instantiating ValueCommit.
In order to support this property, we also de  ne homomorphic Pedersen commitments as follows:
HomomorphicPedersenCommitrcv (D, v) = [v] FindGroupHashJ(r)∗ (D, “v”) + [rcv] FindGroupHashJ(r)∗ (D, “r”)
In the case that we need for ValueCommit, v has 64 bits7. This value is given as a bit representation, which does not
need to be constrained equal to an integer.
ValueCommit can be implemented in:
•                                                                                                                            750 constraints for the 252-bit   xed-base multiplication by rcv;
•                                                                                                                            191 constraints for the 64-bit   xed-base multiplication by v;
•                                                                                                                            6 constraints for the Edwards addition
                                                                                                                                                                                                 for a total cost of 947 constraints. This does not include the cost to boolean-constrain the input v or randomness
rcv.
A.3.7                                                                                                                                                                                            BLAKE2s hashes
                                                                                                                                                                                                                                                                                                                                                                            BLAKE2s is de  ned in [ANWW2013]. Its main subcomponent is a “G function”, de  ned as follows:
                                                                                                                                                                                                                                                                                                                      G ◦ {0 .. 9} × {0 .. 232 −1}[4]  → {0 .. 232 −1}[4]
                                                                                                                                                                                                                                                                                                                      G(a, b, c, d, x, y) = (a′′, b′′, c′′, d′′ ) where
                                                                                                                             a′                                                                  = (a + b + x) mod 232
                                                                                                                             d′                                                                  = (d ⊕ a′ ) ≫ 16
                                                                                                                             c′                                                                  = (c + d′ ) mod 232
                                                                                                                             b′                                                                  = (b ⊕ c′ ) ≫ 12
                                                                                                                                                                                                 a′′  = (a′ + b′ + y) mod 232
                                                                                                                             d′′  = (d′ ⊕ a′′ ) ≫ 8
                                                                                                                             c′′                                                                 = (c′ + d′′ ) mod 232
                                                                                                                             b′′                                                                 = (b′ ⊕ c′′ ) ≫ 7
7 It would be suf  cient to use 51 bits, which accomodates the range {0 .. MAX_MONEY}, but the Sapling circuit uses 64.
135




The following table is used to determine which message words the x and y arguments to G are selected from:
σ0  = [                                                                                                      0,                                                                                           1,                                                                                                                   2,                                         3,                    4,                  5,                       6,   7,                                                                              8,                                                                                       9,  10,  11,  12,  13,  14,  15 ]
                                                                                                             σ1  = [ 14,  10,                                                                                                                                                                                                  4,                                         8,                                        9,  15,  13,                  6,                                                                              1,  12,                  0,                                                    2,  11,                                       7,             5,        3 ]
σ2  = [ 11,                                                                                                                                                                                                                                                                                                                    8,  12,                                    0,                    5,                                                2,  15,  13,  10,  14,                                                                                   3,                                                    6,        7,                                  1,             9,        4 ]
σ3  = [                                                                                                      7,                                                                                           9,                                                                                                                   3,                                                                                   1,  13,  12,  11,  14,                                                                                        2,             6,        5,  10,                                                         4,                                                 0,  15,   8 ]
σ4  = [                                                                                                      9,                                                                                           0,                                                                                                                   5,                                         7,                    2,                                                4,  10,  15,  14,                                                                                        1,  11,  12,                                                    6,                                  8,                       3,  13 ]
σ5  = [                                                                                                                                                                                                   2,  12,                                                                                                                                                         6,  10,                                   0,  11,                  8,   3,                                                                              4,  13,                  7,                                                              5,  15,  14,                                       1,        9 ]
σ6  = [ 12,                                                                                                                                                                                               5,                                                                                                                                                                                    1,  15,  14,  13,                                 4,  10,                                                                         0,             7,        6,                                                    3,        9,                                  2,                       8,  11 ]
                                                                                                             σ7  = [ 13,  11,                                                                                                                                                                                                                                             7,  14,  12,                              1,                       3,   9,                                                                              5,             0,  15,                                                         4,        8,                                  6,                       2,  10 ]
σ8  = [                                                                                                                                                                                                   6,  15,  14,                                                                                                                                                                          9,  11,             3,                       0,                                                                                   8,  12,        2,  13,                                                         7,        1,                                                 4,  10,   5 ]
σ9  = [ 10,                                                                                                                                                                                               2,                                                                                                                   8,                                         4,                    7,                  6,                       1,                                                                                   5,  15,  11,             9,  14,                                                                                             3,  12,  13,             0 ]
                                                                                                                                                                                                                                                                                                                               The Initialization Vector is de  ned as:
                                                                                                                                                                                                                                                                                                                                                                                                                                                  IV ◦ {0 .. 232 −1}[8]  := [ 0x6A09E667,  0xBB67AE85,  0x3C6EF372,  0xA54FF53A
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           0x510E527F,  0x9B05688C,  0x1F83D9AB,  0x5BE0CD19 ]
The full hash function applied to an 8-byte personalization string and a single                              64-byte block, in sequential mode
with 32-byte output, can be expressed as follows.
De  ne BLAKE2s-256 ◦ (p ◦ BY[8] ) × (x ◦ BY[64] ) → BY[32] as:
let PB ◦ BY[32]  = [32, 0, 1, 1] || [0x00]20 || p
let [ t0, t1, f0, f1 ] ◦   {0 .. 232 −1}[4]  = [ 0, 0, 0, 0xFFFFFFFF, 0 ]
let h ◦ {0 .. 232 −1}[8]  = [[ LEOS2IP32 (PB4·i .. 4·i + 3 ) ⊕ IVi for i from 0 up to 7 ]]
let v ◦   {0 .. 232 −1}[16]  = h || [ IV0, IV1, IV2, IV3, t0 ⊕ IV4, t1 ⊕ IV5, f0 ⊕ IV6, f1 ⊕ IV7 ]
let m ◦ {0 .. 232 −1}[16]  = [[ LEOS2IP32 (x4·i .. 4·i + 3 ) for i from 0 up to 15 ]]
for r from 0 up to 9:
set (v0, v4, v8,  v12 ) := G(v0, v4, v8,  v12, mσr,0 ,  mσr,1   )
set (v1, v5, v9,  v13 ) := G(v1, v5, v9,  v13, mσr,2 ,  mσr,3   )
set (v2, v6, v10, v14 ) := G(v2, v6, v10, v14, mσr,4 ,  mσr,5   )
set (v3, v7, v11, v15 ) := G(v3, v7, v11, v15, mσr,6 ,  mσr,7   )
set (v0, v5, v10, v15 ) := G(v0, v5, v10, v15, mσr,8 ,  mσr,9   )
set (v1, v6, v11, v12 ) := G(v1, v6, v11, v12, mσr,10 , mσr,11 )
set (v2, v7, v8,  v13 ) := G(v2, v7, v8,  v13, mσr,12 , mσr,13 )
set (v3, v4, v9,  v14 ) := G(v3, v4, v9,  v14, mσr,14 , mσr,15 )
                                                                                                             (                                                                                            (                                                                                                                    ))
return LEBS2OSP256                                                                                           concatB                                                                                      [[ I2LEBSP32 (hi ⊕ vi ⊕ vi+8 ) for i from 0 up to 7 ]]
                                                                                                                                                                                                          In practice the message and output will be expressed as bit sequences. In the Sapling circuit, the personalization
string will be constant for each use.
                                                                                                             Each 32-bit exclusive-or is implemented in 32 constraints, one for each bit position a ⊕ b                                                                                                                                                                   =  c as in §A.3.1.5
‘Exclusive-or constraints’ on p. 123.
136




Additions not involving a message word, i.e. (a + b) mod 232  = c, are implemented using 33 constraints and a 33-bit
                                                                                                                       ∑i=31                                                                                                             ∑i=32
equality check: constrain 33 boolean variables c0 .. 32, and then check                                                (ai + bi ) · 2i  =                                                                                                ci · 2i.
                                                                                                                       i=0                                                                                                               i=0
Additions involving a message word, i.e. (a + b + m) mod 232  = c, are implemented using 34 constraints and a 34-bit
                                                                                                                       ∑i=31                                                                                                             ∑i=33
equality check: constrain 34 boolean variables c0 .. 33, and then check                                                (ai + bi + mi ) · 2i  =                                                                                           ci · 2i.
                                                                                                                       i=0                                                                                                               i=0
For each addition, only c0 .. 31 are used subsequently.
The equality checks are batched; as many sets of 33 or 34 boolean variables as will   t in a FrS     eld element are
equated together using one constraint. This allows 7 such checks per constraint.
Each G evaluation requires 262 constraints:
•                                                                                                                      4 · 32 = 128 constraints for ⊕ operations;
•                                                                                                                                                                                                                                                                                                                                       2 · 33 = 66 constraints for 32-bit additions not involving message words (excluding equality checks);
•                                                                                                                                                                                                                                                                                                                                       2 · 34 = 68 constraints for 32-bit additions involving message words (excluding equality checks).
The overall cost is 21262 constraints:
•                                                                                                                                                                                                                                                   10 · 8 · 262 = 20960 constraints for 80 G evaluations, excluding equality checks;
                                                                                                                       (                                                                                                                 )
10 · 8 · 4
•  ceiling                                                                                                             = 46 constraints for equality checks;
7
•                                                                                                                      8 · 32 = 256 constraints for  nal vi ⊕ vi+8 operations (the hi words are constants so no additional constraints
are required to exclusive-or with them).
This cost includes boolean-constraining the hash output bits (done implicitly by the   nal ⊕ operations), but not
the message bits.
Non-normative notes:
•  The equality checks could be eliminated entirely by substituting each check into a boolean constraint for c0,
for instance, but this optimization is not done in Sapling.
•  It should be clear that BLAKE2s is very expensive in the circuit compared to elliptic curve operations. This is
primarily because it is inef  cient to use FrS  elements to represent single bits. However Pedersen hashes do
not have the necessary cryptographic properties for the two cases where the Spend circuit uses BLAKE2s.
While it might be possible to use variants of functions with low circuit cost such as MiMC [AGRRT2017], it
was felt that they had not yet received suf  cient cryptanalytic attention to con  dently use them for Sapling.
137




A.4                                                                                                                     The Sapling Spend circuit
The Sapling Spend statement is de  ned in § 4.15.2 ‘Spend Statement (Sapling)’ on p. 42.
The primary input is
(
rt ◦   B[ℓMerkleSapling ],
cvold  ◦   ValueCommit.Output,
nfold  ◦   B[ℓPRFnfSapling ],
)
rk ◦   SpendAuthSig.Public                                                                                              ,
                                                                                                                        which is encoded as 8 FrS  elements (starting with the   xed element 1 required by Groth16):
                                                                                                                                                                                                                                                          (       )            (
[1, u(rk), v(rk), u(cvold ), v(cvold ), LEBS2IP                                                                                                                                                                                                           nf0ld   , LEBS2IP5   nf25d1 .. 255)]
                                                                                                                                                                                                                       ℓMerkleSapling (rt) , LEBS2IP251           .. 250
The auxiliary input is
(
path ◦ B[ℓMerkle ][MerkleDepthSapling ],
pos ◦ {0 .. 2MerkleDepthSapling −1},
gd  ◦ J,
pkd  ◦ J,
vold  ◦   {0 .. 2ℓvalue −1},
rcvold  ◦   {0 .. 2ℓscalar −1},
cmold  ◦ J,
rcmold  ◦ {0 .. 2ℓscalar −1},
α ◦ {0 .. 2ℓscalar −1},
ak ◦ SpendAuthSig.Public,
nsk ◦ {0 .. 2ℓscalar −1}).
ValueCommit.Output and SpendAuthSig.Public are J, so we have cvold, cmold, rk, gd, pkd, and ak that represent Jubjub
curve points. However,
•  cvold will be constrained to an output of ValueCommit;
•  cmold will be constrained to an output of NoteCommitSapling ;
•  rk will be constrained to [α] G + ak;
•  pkd will be constrained to [ivk] gd
so cvold, cmold, rk, and pkd do not need to be explicitly checked to be on the curve.
In addition, nk⋆ and ρ⋆ used in Nulli  er integrity are compressed representations of Jubjub curve points. TODO:
explain why these are implemented as §A.3.3.2 ‘Edwards [de]compression and validation’ on p. 126 even though
the statement spec doesn’t explicitly say to do validation.
Therefore we have gd, ak, nk, and ρ that need to be constrained to valid Jubjub curve points as described in §A.3.3.2
‘Edwards [de]compression and validation’ on p. 126.
138




In order to aid in comparing the implementation with the speci  cation, we present the checks needed in the order
in which they are implemented in the sapling-crypto code:
Check                                                                                                               Implements                      Cost                                     Reference
ak is on the curve TODO: FIXME also                                                                                 ak ◦ SpendAuthSig.Public        4                                        §A.3.3.1 on p. 126
decompressed below
ak is not small order                                                                                               Small order checks              16                                       §A.3.3.6 on p. 129
α⋆ ◦ B[ℓscalar ]                                                                                                    α ◦ {0 .. 2ℓscalar −1}          252                                      §A.3.1.1 on p. 123
α′  = [α⋆] G                                                                                                        Spend authority                 750                                      §A.3.3.7 on p. 130
rk = α′ + ak                                                                                                                                        6                                        §A.3.3.5 on p. 128
inputize rk TODO: not ccteddecom-                                                                                   rk ◦   SpendAuthSig.Public      392?                                     §A.3.3.2 on p. 126
pressvalidate => wrong count
nsk⋆ ◦ B[ℓscalar ]                                                                                                  nsk ◦ {0 .. 2ℓscalar −1}        252                                      §A.3.1.1 on p. 123
nk = [nsk⋆] H                                                                                                       Nulli  er integrity             750                                      §A.3.3.7 on p. 130
ak⋆ = reprJ (ak ◦ J)                                                                                                Diversi  ed address integrity   392                                      §A.3.3.2 on p. 126
nk⋆  =  reprJ (nk) TODO: spec doesn’t                                                                               Nulli  er integrity             392                                      §A.3.3.2 on p. 126
say to validate nk since it’s calculated
(
                                                                                                                    ivk⋆ = I2LEBSP251                                                        CRHivk (ak, nk)) †                                      Diversi  ed address integrity   21262       §A.3.7 on p. 135
                                                                                                                    gd is on the curve                                                                                                     gd  ◦ J                                   4           §A.3.3.1 on p. 126
                                                                                                                    gd is not small order                                                                                                            Small order checks              16          §A.3.3.6 on p. 129
pkd  = [ivk⋆] gd                                                                                                                                                                                                                                     Diversi  ed address integrity   3252        §A.3.3.8 on p. 131
                                                                                                                                                                                                                      old                  ◦
vold  ◦   B[64]                                                                                                                                                                                                       v                    ◦         {0 .. 264 −1}                   64          §A.3.1.1 on p. 123
rcv⋆ ◦ B[ℓscalar ]                                                                                                                                                                                                                                   rcv ◦ {0 .. 2ℓscalar −1}        252         §A.3.1.1 on p. 123
                                                                                                                                                    cv = ValueCommitrcv (vold )                                                                      Value commitment integrity      947         §A.3.6 on p. 135
inputize cv                                                                                                                                                                                                                                                                          ?
rcm⋆ ◦ B[ℓscalar ]                                                                                                                                                                                                                                   rcm ◦ {0 .. 2ℓscalar −1}        252         §A.3.1.1 on p. 123
                                                                                                                                                    cm                                       (gd, pkd, vold )                                        Note commitment integrity       1740        §A.3.5 on p. 134
                                                                                                                    cmu  = ExtractJ(r) (cm)                                                                                                          Merkle path validity            0
                                                                                                                                                    rt′ is the root of a Merkle tree with                                                                                            32 · 1380   §A.3.4 on p. 134
                                                                                                                                                    leaf cmu, and authentication path
(path, pos⋆)
                                                                                                                                                    pos⋆ = I2LEBSPMerkleDepthSapling (pos)                                                                                           1           §A.3.2.1 on p. 124
                                                                                                                    if vold  , 0 then rt′  = rt                                                                                                                                      1           §A.3.1.2 on p. 123
inputize rt                                                                                                                                                                                                                                                                          ?
                                                                                                                                                    ρ = MixingPedersenHash(cmold, pos)                                                               Nulli  er integrity             98          §A.3.3.10 on p. 134
                                                                                                                    (                               )
ρ⋆ = reprJ                                                                                                          ρ                                                                        TODO: spec doesn’t say                                                                  392         §A.3.3.2 on p. 126
to validate ρ since it’s calculated
(ρ⋆)                                                                                                                21262                           §A.3.7 on p. 135
⋆
pack nf0ld                                                                                                          .. 250 and nf25d1 .. 255 into   input encoding                           2                        §A.3.2.1 on p. 124
two FrS  inputs
139




† This is implemented by taking the output of BLAKE2s-256 as a bit sequence and dropping the most signi  cant
5 bits, not by converting to an integer and back to a bit sequence as literally speci  ed.
Note:   The implementation represents α⋆, nsk⋆, ivk⋆, rcm⋆, rcv⋆, and vold as bit sequences rather than integers.
A.5                                                                                                                 The Sapling Output circuit
The Sapling Output statement is de  ned in § 4.15.3 ‘Output Statement (Sapling)’ on p. 43.
The primary input is
(
cvnew  ◦ ValueCommit.Output,
)
epk ◦ J                                                                                                             ,
which is encoded as 6 FrS  elements (starting with the   xed element 1 required by Groth16):
[1, u(cvnew ), v(cvnew ), u(epk), v(epk), LEBS2IP                                                                   ℓMerkleSapling (cmu )]
The auxiliary input is
(gd  ◦ J,
pk⋆d  ◦ B[ℓJ ],
vnew  ◦ {0 .. 2ℓvalue −1},
rcvnew  ◦ {0 .. 2ℓscalar −1},
rcmnew  ◦ {0 .. 2ℓscalar −1},
esk ◦ {0 .. 2ℓscalar −1})
ValueCommit.Output is J, so we have cvnew , epk, and gd that represent Jubjub curve points. However,
•  cvnew will be constrained to an output of ValueCommit;
•  epk will be constrained to [esk] gd
so cvnew and epk do not need to be explicitly checked to be on the curve.
Therefore we have only gd  that needs to be constrained to a valid Jubjub curve point as described in §A.3.3.2
‘Edwards [de]compression and validation’ on p. 126.
Note:   pk⋆d is not checked to be a valid compressed representation of a Jubjub curve point.
140




In order to aid in comparing the implementation with the speci  cation, we present the checks needed in the order
in which they are implemented in the sapling-crypto code:
Check                                                                                                                                                       Implements                       Cost                                                Reference
vold  ◦   B[64]                                                                                                                                             vold  ◦   {0 .. 264 −1}          64                                                  §A.3.1.1 on p. 123
rcv⋆ ◦ B[ℓscalar ]                                                                                                                                          rcv ◦ {0 .. 2ℓscalar −1}         252                                                 §A.3.1.1 on p. 123
cv = ValueCommitrcv (vold )                                                                                                                                 Value commitment integrity       947                                                 §A.3.6 on p. 135
inputize cv                                                                                                                                                                                  ?
g⋆d  = reprJ (gd  ◦ J)                                                                                                                                      Note commitment integrity        392                                                 §A.3.3.2 on p. 126
gd is not small order                                                                                                                                       Small order checks               16                                                  §A.3.3.6 on p. 129
esk⋆ ◦ B[ℓscalar ]                                                                                                                                          esk ◦ {0 .. 2ℓscalar −1}         252                                                 §A.3.1.1 on p. 123
epk = [esk⋆] gd                                                                                                                                             Ephemeral public key integrity   3252                                                §A.3.3.8 on p. 131
inputize epk                                                                                                                                                                                 ?
pk⋆d  ◦ B[ℓJ ]                                                                                                             pk⋆d  ◦ B[ℓJ ]                                                    256                                                 §A.3.1.1 on p. 123
rcm⋆ ◦ B[ℓscalar ]                                                                                                                                          rcm ◦ {0 .. 2ℓscalar −1}         252                                                 §A.3.1.1 on p. 123
cm                                                                                                                         (gd, pkd, vold )                 Note commitment integrity        1740                                                §A.3.5 on p. 134
pack inputs                                                                                                                                                                                  ?
Note:   The implementation represents esk⋆, pk⋆d, rcm⋆, rcv⋆, and vold as bit sequences rather than integers.
B   Batching Optimizations
B.1                                                                                                                        RedDSA batch veri  cation
The reference veri  cation algorithm for RedDSA signatures is de  ned in § 5.4.6 ‘RedDSA and RedJubjub’ on p. 60.
Let the RedDSA parameters G (de  ning a subgroup G(r) of order rG, a cofactor hG, a group operation +, an additive
identity OG , a bit-length ℓG , a representation function reprG , and an abstraction function abstG ); PG  ◦ G; ℓH  ◦ N;
H ◦ BY[N]  → BY[ℓH /8]; and the derived hash function H⊛  ◦ BY[N]  → Fr                                                    be as de  ned in that section.
G
Implementations MAY alternatively use the optimized procedure described in this section to perform faster veri-
cation of a batch of signatures, i.e. to determine whether all signatures in a batch are valid. Its input is a sequence
of N “batch entries ”, each of which is a (public key, message, signature) triple.
Let LEOS2BSP, LEOS2IP, and LEBS2OSP be as de  ned in § 5.2 ‘Integers, Bit Sequences, and Endianness’ on p. 49.
De  ne RedDSA.BatchEntry := RedDSA.Public × RedDSA.Message × RedDSA.Signature.
De  ne RedDSA.BatchVerify ◦ (entry0 .. N −1  ◦ RedDSA.BatchEntry[N ] ) → B as:
For each j ∈ {0 .. N − 1}:
Let (vkj , Mj , σj ) = entryj .
                                                                                                                           (                                )                                                                                    (                    )
Let Rj be the   rst ceiling                                                                                                ℓG /8                                                             bytes of σj , and let Sj be the remaining ceiling   bitlength(rG )/8     bytes.
                                                                                                                           (                                )
Let Rj  = abstG
                                                                                                                           LEOS2BSPℓG (Rj )                                                  , and let Sj  = LEOS2IP8·length(Sj ) (Sj ).
                                                                                                                           (                                )
                                                                                                                           reprG (vkj )
Let vkj  = LEBS2OSPℓG
                                                                                                                                                                                             141




Let cj  = H⊛ (Rj || vkj || Mj ).
Choose random zj  ◦ Fr                                                                                                       ←R {1 .. 2128 − 1}.
G
Return 1 if
•  for all j ∈ {0 .. N − 1}, Rj  , ⊥ and Sj  < rG; and
                                                                                                                                                                                            ([∑N −1                                                                                                                  ]                               ∑N−1   (                                                             ))
•                                                                                                                            [hG]                                                                       (zj · Sj )                                                                                       (mod rG )   PG  +                                        [zj ] Rj + [zj · cj                    (mod rG )] vkj        = OG ,
                                                                                                                                                                                            j=0                                                                                                                                                             j=0
otherwise 0.
The zj values MUST be chosen independently of the batch entries.
The performance bene  t of this approach arises partly from replacing the per-signature scalar multiplication of
the base PG with one such multiplication per batch, and partly from using an ef  cient algorithm for multiscalar
multiplication such as Pippinger’s method [Bernstein2001] or the Bos-Coster method [deRooij1995], as explained
in [BDLSY2012, section 5].
Note:   Spend authorization signatures (§ 5.4.6.1 ‘Spend Authorization Signature’ on p. 63) and binding signatures
(§ 5.4.6.2 ‘Binding Signature’ on p. 63) use different bases PG . It is straightforward to adapt the above procedure
                                                                                                                             [∑                                                             ]
to handle multiple bases; there will be one                                                                                  (zj · Sj )                                                     (mod rG )   P term for each base P .  The bene  t of this
j
relative to using separate batches is that the multiscalar multiplication can be extended across a larger batch.
B.2                                                                                                                          Groth16 batch veri  cation
The reference veri  cation algorithm for Groth16 proofs is de  ned in § 5.4.9.2 ‘Groth16’ on p. 71.
Let qS, rS, S1r)
2,T , PS1,2,T , 1S, and êS be as de  ned in § 5.4.8.2 ‘BLS12-381’ on p. 67.
De  ne MillerLoopS  ◦ S1r)  × S2r)  → STr)  and FinalExpS  ◦ STr)  → STr)  to be the Miller loop and   nal exponentiation
respectively of the êS pairing computation, so that:
(                                                                                                                            )
                                                                                                                             MillerLoopS (P, Q)
êS (P, Q) = FinalExpS
where FinalExpS (R) = Rt for some   xed t.
De  ne Groth16S.Proof := S1r)∗ × S2r)∗ × S1r)∗.
A Groth16S proof consists of a tuple (πA, πB , πC ) ◦ Groth16S.Proof .
Veri  cation of a single Groth16S proof against an instance encoded as a0 .. ℓ  ◦ FrS [ℓ+1] requires checking the equation
                                                                                                                                                                                            (∑ℓ                                                                                                          )
êS (πA, πB ) = êS (πC , Δ) · êS                                                                                                                                                                         [ai] Ψi, Γ                                                                                       · Y
                                                                                                                                                                                            i=0
                                                                                                                                                                                                                                                                                                                     [                                      ]
                                                                                                                                                                                                                                                                                                                     β ·ui (x) + α·vi (x) + wi (x)
                                                                                                                                                                                                                                                                                                                                                            PS    for i ∈ {0 .. ℓ} are elements of the
                                                                                                                             where Δ = [δ] PS2 , Γ = [γ] PS2 , Y  = [α·β] PST , and Ψi  =                                                                                                                                                            γ      1
                                                                                                                                                                                                        veri  cation key, as described (with slightly different notation) in [Groth2016, section 3.2].
This can be written as:
                                                                                                                                                                                            (∑ℓ                                                                                                          )
êS (πA, −πB ) · êS (πC , Δ) · êS                                                                                                                                                                        [ai] Ψi, Γ                                                                                       · Y         = 1S.
i=0
142




Raising to the power of random z , 0 gives:
(                                                                                                                                                                                                           )                       (            )                             (∑ℓ                              )
êS                                                                                                                          [z] πA, −πB                                                                     · êS                    [z] πC , Δ   · êS                                          [z · ai] Ψi, Γ                      · Y z  = 1S.
i=0
This justi  es the following optimized procedure for performing faster veri  cation of a batch of Groth16S proofs.
Implementations MAY use this procedure to determine whether all proofs in a batch are valid.
De  ne Groth16S.BatchEntry := Groth16S.Proof × Groth16S.PrimaryInput.
De  ne Groth16S.BatchVerify ◦ (entry0 .. N −1  ◦ Groth16S.BatchEntry[N ] ) → B as:
For each j ∈ {0 .. N − 1}:
Let ((πj,A, πj,B , πj,C ), aj, 0 .. ℓ ) = entryj .
Choose random zj  ◦ Fr                                                                                                      ←R {1 .. 2128 − 1}.
G
                                                                                                                            ∏N−1                                                                                                    (                                          )
Let AccumAB  =                                                                                                                                                                                              MillerLoopS                          [zj ] πj,A, −πj,B
                                                                                                                                                                                                            j=0
                                                                                                                            ∑                                                                               N −1
Let AccumΔ                                                                                                                  =                                                                               [zj ] πj,C .
                                                                                                                                                                                                            j=0
                                                                                                                            ∑                                                                               N −1
Let AccumΓ,i                                                                                                                =                                                                               (zj · aj,i )                         (mod rS ) for i ∈ {0 .. ℓ}.
                                                                                                                                                                                                            j=0
                                                                                                                            ∑N                                                                              −1
Let AccumY                                                                                                                  =                                                                               zj                      (mod rS ).
                                                                                                                                                                                                            j=0
Return 1 if
                                                                                                                            (
                                                                                                                                                                                                                                                 (                             )               (∑ℓ                                 ))
FinalExpS                                                                                                                                                                                                   AccumAB · MillerLoopS                AccumΔ, Δ                     · MillerLoopS                    [AccumΓ,i] Ψi, Γ   · Y AccumY     = 1S,
i=0
otherwise 0.
The zj values MUST be chosen independently of the batch entries.
The performance bene  t of this approach arises from computing two of the three Miller loops, and the                       nal ex-
ponentation, per batch instead of per proof. For the multiplications by zj , an ef  cient algorithm for multiscalar
multiplication such as Pippinger’s method [Bernstein2001] or the Bos-Coster method [deRooij1995] may be used.
Note:   Spend proofs (of the statement in § 4.15.2 ‘Spend Statement (Sapling)’ on p. 42) and output proofs (of the
statement in § 4.15.3 ‘Output Statement (Sapling)’ on p. 43) use different veri  cation keys, with different param-
eters Δ, Γ, Y , and Ψ0 .. ℓ. It is straightforward to adapt the above procedure to handle multiple veri  cation keys; the
accumulator variables AccumΔ, AccumΓ,i, and AccumY  are duplicated, with one term in the veri  cation equation
for each variable, while AccumAB is shared.
Neglecting multiplications in STr) and Fr                                                                                   , and other trivial operations, the cost of batched veri  cation is therefore
S
•  for each proof: the cost of decoding the proof representation to the form Groth16S.Proof , which requires
three point decompressions and three subgroup checks (two for S1r)∗ and one for S2r)∗);
•  for each successfully decoded proof: a Miller loop; and a 128-bit scalar multiplication by zj ;
•  for each veri  cation key: two Miller loops; an exponentiation in STr) ; a multiscalar multiplication with N
128-bit terms to compute AccumΔ; and a multiscalar multiplication with ℓ + 1 255-bit terms to compute
∑ℓ
[AccumΓ,i] Ψi;
i=0
•  one   nal exponentiation.
143





